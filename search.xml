<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux进程地址空间（程序内存布局）</title>
    <url>/APUE/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%88%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="进程地址空间分布图"><a href="#进程地址空间分布图" class="headerlink" title="进程地址空间分布图"></a>进程地址空间分布图</h1><img src="https://i.loli.net/2020/08/05/jxbWsi5ae4q1GfR.png" alt="Linux程序内存布局图.png" style="zoom:67%;" />

<p>由低地址到高地址，依次是：</p>
<ul>
<li><p><strong>程序段（text）</strong>：程序代码在内存中的映射，存放函数体的二进制代码，常常是只读的</p>
</li>
<li><p><strong>初始化过的数据（data）</strong>：在程序运行初已经对变量进行初始化的数据</p>
<ul>
<li><p>只读数据段（RO data，即常量区）：</p>
<blockquote>
<p> 这个区域的存在与否，一直是一个争议的地方，但是我们这里认同是存在的，因为我们的程序中的确出现了与其他数据段不同的一块区域，但是往往很多时候大家把只读数据段（RO data）和下面的已初始化读写数据段（RW data）合成为数据段data，但是其实这个是不合适的，因为在执行过程中，这两个区域的读写权限是不同的，顾名思义，只读数据段（RO data）是只读的，而已初始化读写数据段是可读可写的。</p>
</blockquote>
</li>
<li><p>读写数据段（RW data）：需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并具有初值，以供程序运行时读写</p>
</li>
</ul>
</li>
<li><p><strong>未初始化过的数据（bss）</strong>：未初始化数据是在程序中声明，但是没有初始化的变量，这些变量在程序运行之前不需要占用存储器的空间。Block Started by Symbol，BSS段的变量只有名称和大小却没有值</p>
</li>
<li><p>堆 （heap）<strong>：存储动态内存分配,需要程序员手工分配,手工释放。注意它与数据结构中的堆是两回事，分配方式类似于链表</strong></p>
</li>
<li><p><strong>栈（stack）</strong>：存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存，结束时自动释放内存，其操作方式类似于数据结构中的栈</p>
</li>
<li><p><strong>内核空间（kernel）</strong></p>
</li>
</ul>
<h1 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h1><p> Linux的<font color=red><strong>虚拟地址空间</strong></font>范围为0～4G，Linux内核将这4G字节的空间分为两部分：</p>
<p><strong>内核空间</strong>：将高地址的<strong>1G</strong>字节供内核使用，称为“内核空间“</p>
<p><strong>用户空间</strong>：低地址的<strong>3G</strong>字节（供各个进程使用，称为“用户空间“</p>
<p>因为每个进程可以通过系统调用进入内核，因此，<font color=red><strong>Linux内核由系统内的所有进程共享</strong></font>。</p>
<p>Linux使用两级保护机制：</p>
<ul>
<li>0级供内核使用</li>
<li>3级供用户程序使用</li>
</ul>
<h1 id="虚拟地址！！！"><a href="#虚拟地址！！！" class="headerlink" title="虚拟地址！！！"></a>虚拟地址！！！</h1><p>进程空间是<strong>虚拟地址</strong>，不管是内核空间还是用户空间，它们都处于虚拟空间中。</p>
<p>使用虚拟地址可以很好的保护内核空间被用户空间破坏，虚拟地址到物理地址转换过程由操作系统和CPU共同完成(操作系统为CPU设置好页表，CPU通过MMU单元进行地址转换)。</p>
<h1 id="段区对应数据"><a href="#段区对应数据" class="headerlink" title="段区对应数据"></a>段区对应数据</h1><table>
<thead>
<tr>
<th>进程空间段区域</th>
<th>地址空间</th>
<th>存储变量</th>
</tr>
</thead>
<tbody><tr>
<td>stack</td>
<td>栈</td>
<td>局部变量和常量</td>
</tr>
<tr>
<td>heap</td>
<td>堆</td>
<td>动态分配的数据</td>
</tr>
<tr>
<td>BSS</td>
<td>未初始化数据段</td>
<td>未初始化的全局变量以及静态变量</td>
</tr>
<tr>
<td>RW data</td>
<td>已初始化读写数据段</td>
<td>已初始化的全局变量和静态变量</td>
</tr>
<tr>
<td>RO data</td>
<td>只读文本段中的数据段</td>
<td>全局常量或者字符串面变量</td>
</tr>
<tr>
<td>text</td>
<td>只读文本段中的程序代码段</td>
<td>程序的代码</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>《UNIX环境高级编程》</p>
</li>
<li><p><a href="https://blog.csdn.net/zhangzhebjut/article/details/39060253">Linux - 进程(一) 进程空间</a></p>
</li>
<li><p><a href="https://blog.csdn.net/gatieme/article/details/43567433">C程序的内存布局(Memory Layout)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>apue</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>apue</tag>
        <tag>进程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐</title>
    <url>/APUE/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>现代计算机中内存空间都是按照<strong>字节（byte）</strong>划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p><strong>如果一个变量的内存地址正好位于它长度的整数倍</strong>，他就被称做<strong>自然对齐</strong>。比如4字节的 int 型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即对齐跟数据在内存中的位置有关。</p>
<h2 id="为什么要对齐"><a href="#为什么要对齐" class="headerlink" title="为什么要对齐"></a>为什么要对齐</h2><ul>
<li>一些平台严格要求，比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,</li>
<li><strong>为了使CPU能够对变量进行快速的访问</strong></li>
</ul>
<p>如果0x02～0x05存了一个 int ，读取这个 int 就需要先读0x01～0x04，留下0x02～0x04的内容，再读0x05～0x08，留下0x05的内容，两部分拼接起来才能得到那个 int 的值，这样读一个 int 就要两次内存访问，效率就低了。</p>
<h2 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="pragma pack"></a>pragma pack</h2><p>用 <code>sizeof</code> 运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，有时候为了内存对齐需要补齐空字节。通常写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。</p>
<p>语法：<b>#pragma pack( [show] | [push | pop] [, identifier], n )</b></p>
<p>作用：指定结构，联合和类的包对齐方式（pack alignment）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)    <span class="comment">//通知编译器 4字节对齐</span></span></span><br></pre></td></tr></table></figure>

<h2 id="字节对齐规则"><a href="#字节对齐规则" class="headerlink" title="字节对齐规则"></a>字节对齐规则</h2><p>结构体中各个成员按照它们<strong>被声明的顺序</strong>在内存中顺序存储。对齐规则如下：</p>
<ol>
<li><p>各个数据成员按各自数据类型对齐</p>
<blockquote>
<p>对齐模数是【该数据成员所占内存】与【#pragma pack指定的数值】中的<font color=red><strong>较小者</strong></font>。</p>
</blockquote>
</li>
<li><p>整个结构体字节大小向结构体模数对齐</p>
<blockquote>
<p>结构体模数是【#pragma pack指定的数值（32位机默认4字节、64位机默认8字节）】和【结构体内部最大的基本数据类型成员】长度中数值<font color=red><strong>较小者</strong></font>。结构体的长度应该是该模数的整数倍。</p>
</blockquote>
</li>
</ol>
<p>【<strong>基本数据类型</strong>】无符号字节数一样。32位机默认4字节对齐、64位机默认8字节对齐。（<strong>实践数据：linux 64位机默认16字节对齐、linux 32位机默认4字节对齐</strong>）。win64未验证。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>char</th>
<th>bool</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>long long</th>
<th>long double</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>Win-32</td>
<td>长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>模数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>Linux-32</td>
<td>长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>12</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>模数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>Linux-64</td>
<td>长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>模数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>16</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>内部数据成员都是以基本数据类型进行对齐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;        <span class="comment">// 8 bits</span></span><br><span class="line">    <span class="keyword">double</span> val2;    <span class="comment">// 8 bits</span></span><br><span class="line">&#125; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_i;            <span class="comment">// 4 bits    </span></span><br><span class="line">    A m_A;                <span class="comment">// 16 bits</span></span><br><span class="line">    <span class="keyword">double</span> m_d;    <span class="comment">// 8 bits</span></span><br><span class="line">    <span class="keyword">int</span> m_i2;            <span class="comment">// 4 bits</span></span><br><span class="line">&#125; B;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>b.m_int          = 0x61fed8                 </p>
<p>b.m_A.val      = 0x61fee0</p>
<p>b.m_A.val2    = 0x61fee8</p>
<p>b.m_double  = 0x61fef0 </p>
<p> b.m_int2        = 0x61fef8 </p>
<p>sizeof(A) = 16  </p>
<p>sizeof(B) = 40 </p>
</blockquote>
<img src="https://i.loli.net/2020/09/24/Xu15mr2JeHyjpVY.jpg" alt="字节对齐-样例.jpg" style="zoom: 25%;" /> 

<h2 id="static静态数据"><a href="#static静态数据" class="headerlink" title="static静态数据"></a>static静态数据</h2><p>静态变量的存放位置与结构体实例的存储地址无关，是单独存放在静态数据区的，因此用 sizeof() 计算其大小时没有将静态成员所占的空间计算进来。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>空类是会占用内存空间的，而且大小是</strong><font color=red><strong>1 byte</strong></font>，原因是<strong>C++要求每个实例在内存中都有独一无二的地址</strong> 。</p>
<ul>
<li><p>类内成员变量</p>
<ul>
<li><strong>non-static变量</strong>：要占用内存，参考上面对齐规则</li>
<li><strong>static变量</strong>：不占用内存，存储在全局/静态存储区</li>
</ul>
</li>
<li><p>类成员函数</p>
<ul>
<li><p>普通函数：不占内存</p>
</li>
<li><p><strong>虚函数</strong>：4字节（32位），虚表指针（vptr），指向虚函数表（vtbl)。并且，<strong>虚表指针存放在第一个4字节</strong>。</p>
<ul>
<li>一个类的虚函数所占用的地址是不变的，和虚函数的个数没有关系。</li>
<li>子类与父类共享一个虚表指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// 4 bits</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fOut</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;virtual base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerive</span> :</span> <span class="keyword">public</span> CBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 4 bits</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fPut</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;virtual derive&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印地址</span></span><br><span class="line">CDerive derive;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(derive) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;derive &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0x61fe9c </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;derive.a &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0x61fea0 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;derive.n &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0x61fea4 </span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lime1991/article/details/44536343">#pragma pack()用法详解</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>系统I/O函数与C标准库函数</title>
    <url>/APUE/%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0%E4%B8%8EC%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>先上图</p>
<img src="https://i.loli.net/2020/08/06/RIMrGxbPWyizjnK.png" alt="库函数与系统调用的层次关系.png" style="zoom: 67%;" />

<img src="https://i.loli.net/2020/08/06/tl8ykNe6wrx7VOd.png" alt="系统IO函数与C标库函数.png" style="zoom:67%;" />

<p><strong><em>read、write函数常常被称为 Unbuffered I/O。指的是无用户输入级缓冲区，但不保证不使用内核缓冲区。</em></strong></p>
<h2 id="系统I-O与标准库I-O差异"><a href="#系统I-O与标准库I-O差异" class="headerlink" title="系统I/O与标准库I/O差异"></a>系统I/O与标准库I/O差异</h2><p>用户程序在读写文件时既可以调用C标准I/O库函数，也可以直接调用底层的系统I/O函数，有什么区别呢？</p>
<ul>
<li>使用系统I/O函数每次读写都需要进入内核，调一个系统调用比调一个用户空间的函数要慢很多。（此时用户有必要维护一个I/O缓冲区，但用C标准I/O库函数就比较方便，省去了自己管理I/O缓冲区的麻烦）</li>
<li>用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，在必要时需调用<code>fflush</code></li>
<li>UNIX是Everything is a file，在读写设备文件时通常是不希望有缓冲的，例如网络编程通常直接调用Unbuffered I/O函数。</li>
</ul>
<h2 id="标准库缓冲类型"><a href="#标准库缓冲类型" class="headerlink" title="标准库缓冲类型"></a>标准库缓冲类型</h2><p>C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。</p>
<h3 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h3><p>如果缓冲区写满了就写回内核。对于驻留在<strong>磁盘</strong>上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。</p>
<h3 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h3><p>如果用户程序写的数据中有<strong>换行符</strong>就把这一行写回内核，或者如果<strong>缓冲区写满</strong>了就写回内核。<font color=red><strong>标准输入</strong></font>和<font color=red><strong>标准输出</strong></font>对应终端设备时通常是行缓冲的。 </p>
<h3 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h3><p>用户程序每次调库函数做写操作都要通过系统调用写回内核。</p>
<p><font color=red><strong>标准错误输出</strong></font>通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。这里的无缓冲，并不是指缓冲区大小为0，其实，还是有缓冲的，大小为1。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>apue</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>apue</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Union-Find算法详解</title>
    <url>/Algorithm/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Union-Find%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>【<font color=red><strong>声明</strong></font>】 <strong>本文转载自 <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md">Union-Find算法详解 - GitHub</a></strong> </p>
<p> Union-Find 算法，也就是常说的并查集算法，主要是解决图论中「<strong>动态连通性</strong>」问题的。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>简单说，动态连通性其实可以抽象成给一幅有 <code>N</code> 个结点的图连线，其中结点按 0~N 编号。</p>
<p>Union-Find 算法主要需要实现以下API：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<p>1、自反性：结点 <code>a</code> 和 <code>a</code> 是连通的。</p>
<p>2、对称性：如果结点 <code>a</code> 和 <code>b</code> 连通，那么 <code>b</code> 和 <code>a</code> 也连通。</p>
<p>3、传递性：如果结点 <code>a</code> 和 <code>b</code> 连通， <code>b</code> 和 <code>c</code> 连通，那么 <code>a</code> 和 <code>c</code> 也连通。</p>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>假定我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 其他函数 **/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;            <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;    <span class="comment">// parent[i]: 结点 i 的父节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UnionFind::UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">    <span class="comment">// 初始时所有结点互不连通</span></span><br><span class="line">    <span class="comment">// 父节点指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        parent.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionFind::connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (rootA == rootB)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 将一棵树接在另一棵树上</span></span><br><span class="line">    parent[a] = rootB;</span><br><span class="line">    <span class="comment">// 连通分量 -1</span></span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UnionFind::isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRoot(a) == findRoot(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnionFind::findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根结点有 x == parent[x]</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x])</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，主要 API <code>isConnected</code> 和 <code>connect</code> 中的复杂度都是 <code>findRoot</code> 函数造成的，所以说它们的复杂度和 <code>findRoot</code> 一样。<code>findRoot</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度<strong>最坏情况</strong>下可能变成 <code>N</code>。</p>
<h3 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h3><p>我们一开始就是简单粗暴的把 <code>a</code> 所在的树接到 <code>b</code> 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 其他函数 **/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;            <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;    <span class="comment">// parent[i]: 结点 i 的父节点</span></span><br><span class="line">    <span class="comment">// 新增一个数组记录树的 “重量”</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UnionFind::UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">    <span class="comment">// 初始时所有结点互不连通</span></span><br><span class="line">    <span class="comment">// 父节点指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        parent.push_back(i);</span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionFind::connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (rootA == rootB)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 小树根节点接到大树根节点下 「较平衡」</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootA] &lt; size[rootB])&#123;</span><br><span class="line">        parent[rootA] = rootB;</span><br><span class="line">        size[rootB] += size[rootA];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootB] = rootA;</span><br><span class="line">        size[rootA] += size[rootB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连通分量 -1</span></span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。此时，<code>findRoot</code> 、<code>connect</code>、<code>isConnected</code> 的时间复杂度都下降为 <code>O(logN)</code> 。</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？这样<code>findRoot</code> 就能以 <code>O(1)</code> 的时间找到某一节点的根节点，相应的， <code>connect</code> 和 <code>isConnected</code>  复杂度都下降为 <code>O(1)</code> 。要做到这一点，非常简单，只需要在 <code>findRoot</code>  中加一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnionFind::findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根结点有 x == parent[x]</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">        <span class="comment">// 「路径压缩」 减少查询迭代次数</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n);         </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;        <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125; <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span></span>;            <span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line">    <span class="comment">/** 其他函数 **/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;            <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;    <span class="comment">// parent[i]: 结点 i 的父节点    </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;    <span class="comment">// 新增一个数组记录树的 “重量”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UnionFind::UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">    <span class="comment">// 初始时所有结点互不连通</span></span><br><span class="line">    <span class="comment">// 父节点指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        parent.push_back(i);</span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionFind::connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (rootA == rootB)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 小树根节点接到大树根节点下 「较平衡」</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootA] &lt; size[rootB])&#123;</span><br><span class="line">        parent[rootA] = rootB;</span><br><span class="line">        size[rootB] += size[rootA];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootB] = rootA;</span><br><span class="line">        size[rootA] += size[rootB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连通分量 -1</span></span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UnionFind::isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRoot(a) == findRoot(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnionFind::findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根结点有 x == parent[x]</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">        <span class="comment">// 「路径压缩」 减少查询迭代次数</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Algorithm/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>排序算法可以分为内部排序和外部排序，<strong>内部排序</strong>是数据记录在内存中进行排序，而<strong>外部排序</strong>是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<p><img src="https://i.loli.net/2021/01/12/7of3z16dpaKVUgh.png" alt="十大排序算法"></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p>顾名思义，就像一堆气泡，大的气泡往上冒，一次遍历完的结果是待排序的气泡中最大的气泡冒出到有序序列。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>从第一个元素开始比较相邻元素，若前者更大，则交换这两个元素；</li>
<li>一次遍历完，一个元素完成有序；</li>
<li>重复第一步，直到所有元素有序。</li>
</ol>
<p>【<strong>优化</strong>】<strong>当一次遍历结束，没有发生交换，整个序列便已完成排序。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">bubble_sort</span>(<span class="title">vector</span>&lt;T&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 优化 一次遍历是否发生交换</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+<span class="number">1</span> &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums[i], nums[i+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)    <span class="keyword">break</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>每次遍历，选择待排序元素中最大元素，放置到待排序子数组最后位置。一次遍历至多只进行交换一次。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>遍历待排序子数组，选择最大待排序元素；</li>
<li>将待排序最大元素放置在待排序子数组最后位置；</li>
<li>重复第一步，直到所有元素有序。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">select_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[max_index] &lt; nums[i])</span><br><span class="line">                max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[max_index], nums[n<span class="number">-1</span>]);</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote>
<p>将待排序元素依次插入有序序列</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>将第一个元素视为有序序列，往后为待排序序列；</li>
<li>依次向有序序列插入元素到合适的位置。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ordered = <span class="number">1</span>; ordered &lt; n; ++ordered)&#123;</span><br><span class="line">        Type value = nums[ordered];</span><br><span class="line">        <span class="keyword">int</span> i = ordered - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; value)&#123;</span><br><span class="line">            nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<p>也称递减增量排序算法，希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
</blockquote>
<p>【图解】</p>
<p>参考：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">shell_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// 增量 gap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="comment">// 增量为 gap 的子序列【插入排序】</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; value &lt; nums[j - gap]) &#123; </span><br><span class="line">                nums[j] = nums[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>归并排序采用分而治之的思想。将原序列均分为两个子序列，选排序子序列，再合并有序子序列。</p>
</blockquote>
<p>【图解】</p>
<p>参考：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*logn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">merge_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    _merge_sort(nums, start, mid);    <span class="comment">// [start, mid]</span></span><br><span class="line">    _merge_sort(nums, mid + <span class="number">1</span>, end);  <span class="comment">// [mid+1, end]</span></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">temp</span><span class="params">(end - start + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 暂存数组 可只使用一个 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> left = start, right = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[right])</span><br><span class="line">            temp[t++] = nums[left++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[t++] = nums[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid)</span><br><span class="line">        temp[t++] = nums[left++];</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= end)</span><br><span class="line">        temp[t++] = nums[right++];</span><br><span class="line">    <span class="comment">// 拷贝暂存的有序序列</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">        nums[start++] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    _merge_sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>【步骤】</p>
<ol>
<li>待排序列中取一个“基准”</li>
<li>所有比“基准”小的元素放”基准“前面，所有比“基准”大的元素放“基准”后面。</li>
<li>递归处理基准两侧的子序列。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*logn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">quick_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 基准 nums[start]</span></span><br><span class="line">    <span class="keyword">int</span> low = start, high = end;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= nums[start])  <span class="comment">// 先从右找小于基准</span></span><br><span class="line">            --high;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= nums[start])   <span class="comment">// 再从左找大于基准</span></span><br><span class="line">            ++low;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">            swap(nums[low], nums[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将基准归位</span></span><br><span class="line">    swap(nums[start], nums[low]);  </span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    _quick_sort(nums, start, low - <span class="number">1</span>);</span><br><span class="line">    _quick_sort(nums, low + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">quick_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    _quick_sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>堆排序将待排序数组视为静态二叉树组。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>构建（大顶）堆：此处从有孩子的结点开始调整；</li>
<li>取堆顶元素与末尾元素交换；</li>
<li>调整堆结构，循环执行，直到所有元素有序。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*logn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// 自顶向下调整堆 [start, end]</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">adjustMaxHeap</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dad = start; <span class="comment">// 父结点</span></span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 子结点</span></span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// 选择较大的子结点</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; nums[son] &lt; nums[son + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++son;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[son] &lt;= nums[dad]) <span class="comment">// 满足大顶堆条件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 不满足大顶堆添加 交换父子结点 继续向下调整</span></span><br><span class="line">            swap(nums[dad], nums[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">heap_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 1. 构建堆 从最后一个有孩子的结点开始往上调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        adjustMaxHeap(nums, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 依次取最大元素放置末尾</span></span><br><span class="line">    --n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[n]);</span><br><span class="line">        adjustMaxHeap(nums, <span class="number">0</span>, --n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><blockquote>
<p>计数排序算法思想就是先遍历一遍得到所有元素的值区间[min, max]，然后使用临时数组统计区间中每个值出现的次数，再得到小于等于该元素的元素个数，便得到该元素放在目标数组中的位置，最后给目标数组赋值。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>得到待排序序列的最值 [min, max]；</li>
<li>统计 [min, max] 中值出现的次数；</li>
<li>对所有的计数累加，得到小于等于该元素的个数（即该元素排序的位置）；</li>
<li>反向填充临时数组；</li>
<li>赋值目标数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">counting_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 得到待排序序列的最值 [min, max]</span></span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; nums[i])</span><br><span class="line">            min = nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (max &lt; nums[i])</span><br><span class="line">            max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计 [min, max] 中值出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> n_count = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">count</span><span class="params">(n_count, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ++count[nums[i] - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 对所有的计数累加，得到小于等于该元素的个数（即该元素排序的位置）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_count; ++i) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 反向填充临时数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">temp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        temp[--count[nums[i] - min]] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 给目标数组赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><blockquote>
<p>桶排序是计数排序的升级。设置一个定量的数组当作空桶，得到待排序元素范围 [min, max] 后，将元素放入对应的<strong>桶</strong>中。对非空的桶进行排序。最后将非空桶中的元素放回目标数组。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>得到待排序序列的元素范围 [min, max]；</li>
<li>将待排序元素放入对应的桶中；</li>
<li>队非空的桶进行排序；</li>
<li>将非空桶中的元素放回目标数组。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n+m)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n+m)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">bucket_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">bucketCount</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 设置一个定量的数组当作空桶</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Type&gt;&gt; <span class="title">temp</span><span class="params">(bucketCount, <span class="built_in">vector</span>&lt;Type&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// 2. 得到待排序序列的元素范围[min, max]</span></span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; nums[i])</span><br><span class="line">            min = nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (max &lt; nums[i])</span><br><span class="line">            max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 将待排序元素放入对应的桶中</span></span><br><span class="line">    <span class="keyword">int</span> space = (max - min + <span class="number">1</span>) / bucketCount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp[(nums[i] - min) / space].push_back(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 对非空的桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; ++i) &#123;</span><br><span class="line">        insert_sort(temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 将非空桶中的元素放回目标数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp[i].size(); ++j) &#123;</span><br><span class="line">            nums[index++] = temp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<p>基数排序是计数排序和桶排序的结合。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>计算最大位数 <code>bits</code></li>
<li>进行 <code>bits</code> 次排序<ol>
<li>清空计数</li>
<li>统计每个桶中的记录数</li>
<li>将临时数组中的位置依次分配给每个桶</li>
<li>反向将所有桶中记录依次收集到临时数组中</li>
<li>将临时数组的内容复制到目标数组中</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*m)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n+m)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">radix_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 计算最大位数 bits</span></span><br><span class="line">    <span class="keyword">int</span> max_value = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_value &lt; nums[i])</span><br><span class="line">            max_value = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;  <span class="comment">// 最大位数</span></span><br><span class="line">    <span class="keyword">while</span> (max_value) &#123;</span><br><span class="line">        max_value /= <span class="number">10</span>;</span><br><span class="line">        ++bits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 进行 bits 次排序</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">temp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (bits--) &#123;</span><br><span class="line">        <span class="comment">// 2.1 清空计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.2 统计每个桶中的记录数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++count[(nums[i] / radix) % <span class="number">10</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.3 将 temp 中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.4 反向将所有桶中记录依次收集到 temp 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            temp[--count[(nums[i] / radix) % <span class="number">10</span>]] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.5 将临时数组的内容复制到 nums 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>笔记</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法收录</title>
    <url>/Algorithm/%E7%AE%97%E6%B3%95%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><blockquote>
<p>约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p><a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环——公式法（递推公式）</a> </p>
<p><strong>递推公式：</strong><br><font color=red><b><em>f</em>(<em>N</em>,<em>M</em>) = ( <em>f</em>(<em>N</em>−1,<em>M</em>) + <em>M</em> ) % <em>N</em></b></font> </p>
<ul>
<li><em>f</em>(<em>N</em>,<em>M</em>) 表示，N个人报数，每报到M时杀掉那个人，最终胜利者的编号</li>
<li><em>f</em>(<em>N</em>−1,<em>M</em>) 表示，N-1个人报数，每报到M时杀掉那个人，最终胜利者的编号</li>
</ul>
<p><em>注：求出的结果是数组中的下标，若从1开始编号，最终的编号还要加 1。</em> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circle</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>; <span class="comment">// 仅一个人时 胜利者下标为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        p=(p + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【<strong>例题</strong>】</p>
<p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">孩子们的游戏(圆圈中最后剩下的数)</a> </p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>动态规划（Dynamic Programming）问题一般形式是<strong>求最值</strong> 。</p>
<p>求解动态规划问题的核心是<strong>穷举</strong>，由于这类问题存在<strong>重叠子问题</strong>，因此简单的暴力算法效率极低，便需要 <strong>DP table</strong> 来优化穷举过程。</p>
</blockquote>
<p>动态规划的核心思想是 <font color=red><strong>以空间换时间</strong></font> 。</p>
<p>【<strong>算法解析</strong>】</p>
<p><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a> </p>
<p>【<strong>例题分析</strong>】</p>
<p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架- labuladong的算法小抄</a> </p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11智能指针</title>
    <url>/C++/C++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>程序使用 <code>new</code> 从堆（自由存储区）分配内存，在不需要时，应使用 <code>delete</code> 将其释放。这个内存管理过程由程序员控制，内存泄露是困扰C/C++程序员的一大难题。，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放）、二次释放、程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p>
<p>在C++11中摒弃了auto_ptr（在 C++ 17 中被移除），新增三种智能指针：</p>
<ul>
<li><code>shared_ptr</code> ：通过指针保持对象<strong>共享</strong>所有权的智能指针；</li>
<li><code>weak_ptr</code>：到 std::shared_ptr 所管理对象的<strong>弱引用</strong>，在访问所引用的对象前必须先转换为 std::shared_ptr ；</li>
<li><code>unique_ptr</code>： 拥有<strong>独有</strong>对象所有权语义的智能指针。</li>
</ul>
<h2 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h2><p><code>shared_ptr</code> 、 <code>unique_ptr</code> 都有一个 <code>explicit</code> 构造函数，因此不能自动将指针转换为智能指针对象，<strong>必须显式调用</strong>。</p>
<blockquote>
<p>4.8.2</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line"><span class="function">        : __shared_ptr&lt;_Tp&gt;<span class="params">(__p)</span> </span>&#123; &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(pointer __p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _<span class="title">M_t</span><span class="params">(__p, deleter_type())</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">static_assert</span>(!is_pointer&lt;deleter_type&gt;::value,</span><br><span class="line">              <span class="string">&quot;constructed with null function pointer deleter&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>std::shared_ptr</code> 是通过指针保持对象共享所有权的智能指针。<code>shared_ptr</code>的目标非常简单：多个指针可以同时指向一个对象。下列情况之一出现时销毁对象并解分配其内存：</p>
<ul>
<li>最后剩下的占有对象的 <code>shared_ptr</code> 被销毁；</li>
<li>最后剩下的占有对象的 <code>shared_ptr</code> 被通过<code>operator=</code> 或 <code>reset()</code>]赋值为另一指针时。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_int = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sptr1</span><span class="params">(p)</span></span>;            <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr2 = sptr1;        <span class="comment">// OK 引用计数+1</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr3 = p_int;        <span class="comment">// Error!!!</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>); <span class="comment">// OK 使用 make_shared</span></span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr析构"><a href="#shared-ptr析构" class="headerlink" title="shared_ptr析构"></a>shared_ptr析构</h3><p><code>shared_ptr</code> 默认调用 <code>delete</code> 释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个 <code>shared_ptr</code> 的策略。如下：当离开作用域时，默认的析构函数调用 <code>delete</code> 释放资源。实际上，我们应该调用 <code>delete[]</code> 来销毁这个数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Test&gt; <span class="title">sptr1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;  <span class="comment">// 默认使用 delete 析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以通过调用一个<strong>函数</strong>，例如一个 <strong>lamda 表达式</strong>，来指定一个通用的释放步骤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Test&gt; <span class="title">sptr1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], [ ](Test* p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li><p><code>shared_ptr</code> 也提供解引用操作符 <code>*</code> 、<code>-&gt;</code> 。</p>
</li>
<li><p><code>std::make_shared</code> ：创建管理一个新对象的共享指针</p>
</li>
<li><p><code>get()</code> ：获取<code>shared_ptr</code>绑定的资源。</p>
</li>
<li><p><code>reset()</code> ：释放关联内存块的所有权，如果是最后一个指向该资源的<code>shared_ptr</code>,就释放这块内存。</p>
</li>
<li><p><code>unique</code> ：判断是否是唯一指向当前内存的<code>shared_ptr</code>。</p>
</li>
<li><p><code>operator bool</code> ：判断当前的<code>shared_ptr</code>是否指向一个内存块，可以用if 表达式判断。</p>
</li>
</ul>
<h3 id="原始指针初始化shared-ptr"><a href="#原始指针初始化shared-ptr" class="headerlink" title="原始指针初始化shared_ptr"></a>原始指针初始化shared_ptr</h3><p><strong>不要用一个原始指针初始化多个 <code>shared_ptr</code>，否则会造成二次释放同一内存。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;  <span class="comment">// 引用计数 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;  <span class="comment">// 引用计数 1   p1、p2两者不知对方存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，直接使用原始指针初始化多个 <code>shared_ptr</code> ，使用时，智能指针相互间不知道彼此的存在。p1、p2存储在栈上，程序结束时，首先 p2 死亡时引用计数为 0 ，释放掉 ptr 。接着 p1 死亡，p1 记录的引用计数也为 0 。再次对对象进行释放，<font color=red><strong>Crash !!!</strong></font> 。</p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Parent() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Child&gt; m_child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Child() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Parent&gt; m_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p_parent</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Child&gt; <span class="title">p_child</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">    p_child-&gt;m_parent = p_parent;</span><br><span class="line">    p_parent-&gt;m_child = p_child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个对象的引用计数都是 2 。当 <code>p_child</code> 离开作用域时，子类对象引用计数 -1 （值为1）。当 <code>p_parent</code> 离开作用域时，父类对象引用计数 -1 （值为1）。两个智能指针生命期都结束了，但是对象内存却都没得到释放！！！</p>
<p>【<strong>解决循环引用</strong>】</p>
<ul>
<li>当只剩下最后一个引用的时候需要手动打破循环引用释放对象。</li>
<li>当parent的生存期超过child的生存期的时候，child改为使用一个普通指针指向parent。</li>
<li>使用<strong>弱引用</strong>的智能指针打破这种循环引用。</li>
</ul>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>为了解决<strong>循环引用</strong>，<code>C++</code>提供了另外一种智能指针：<code>weak_ptr</code> 。</p>
<p><code>std::weak_ptr</code> 是一种智能指针，它对被 <code>std::shared_ptr</code> 管理的对象存在非拥有性（“弱”）引用。在访问所引用的对象前必须先转换为 <code>std::shared_ptr</code>。</p>
<p><strong>强引用</strong>：被引用的对象活着，这个引用就存在。只要有一个强引用存在，这个对象就不能被释放。</p>
<p><strong>弱引用</strong>：弱引用不修改对象的引用计数，意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Parent() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;Child&gt; m_child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Child() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;Parent&gt; m_parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>std::unique_ptr</code> 是通过指针占有并管理另一对象，并在 <code>unique_ptr</code> 离开作用域时释放该对象的智能指针。</p>
<p>在下列两者之一发生时用关联的删除器释放对象：</p>
<ul>
<li>销毁了管理的 <code>unique_ptr</code> 对象。</li>
<li>通过 <code>operator=</code> 或 <code>reset()</code> 赋值另一指针给管理的 <code>unique_ptr</code> 对象。</li>
</ul>
<p><code>unique_ptr</code>的创建方法和<code>shared_ptr</code>一样，除非创建一个指向数组类型的<code>unique_ptr</code>。<code>unique_ptr</code>提供了创建数组对象的特殊方法，当指针离开作用域时，调用<code>delete[]</code>代替<code>delete</code>。当创建<code>unique_ptr</code>时，这一组对象被视作模板参数的部分。这样，程序员就不需要再提供一个指定的析构方法</p>
<p><code>unique_ptr</code>提供一个<code>release()</code>的方法，释放所有权。<code>release</code>和<code>reset</code>的区别在于，<code>release</code>仅仅释放所有权但不释放资源，<code>reset</code>释放所有权同时也释放资源。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记(面向对象高级编程--侯捷)</title>
    <url>/C++/C++%E7%AC%94%E8%AE%B0(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--%E4%BE%AF%E6%8D%B7)/</url>
    <content><![CDATA[<blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV14s411E772">https://www.bilibili.com/video/BV14s411E772</a> </p>
<p>别人的git：<a href="https://github.com/harvestlamb/Cpp_houjie">https://github.com/harvestlamb/Cpp_houjie</a> </p>
</blockquote>
<h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>在C/C++中，有些函数会被频繁的调用，会有频繁的函数入栈、出栈操作，这样就造成一定程度上时间以及空间的消耗。于是在C++中便提出了内联函数的概念。</p>
<p><strong>内联函数的特征：</strong> </p>
<ul>
<li>在编译时，编译器使用函数的定义替换掉函数的调用语句，这种替代行为发生在编译阶段而非程序运行阶段</li>
<li><strong>在类声明中定义的函数, 除了虚函数的其他函数都会自动隐式的成为内联函数</strong></li>
<li><strong>关键字<code>inline</code>必须与函数定义体放在一起才能使函数成为内联, 仅将inline放在函数声明前不起任何作用</strong> </li>
</ul>
<p><strong>优点：</strong> </p>
<ul>
<li>省去函数调用时的参数压栈, 栈帧开辟, 结构返回等步骤, 从而提高了程序的运行速度</li>
<li>内联函数优于宏，宏不能按值传递，并且内联函数可以访问类的成员变量</li>
<li>内联函数在运行时可以调试, 而宏定义则不行(因为宏定义是被预定义处理的, 所以不会有人黑的编译符号和调试信息, 调试的时候基本只能用肉眼去看)</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>代码膨胀，内联函数增大了可执行程序的体积</li>
<li>C++内联函数的展开是中编译阶段，这就意味着如果你的内联函数发生了改动，那么就需要重新编译代码</li>
<li><font color=red><b>是否内联是程序员不可控的，<code>inline</code> 只是对编译器的建议，最终有编译器决定</b></font></li>
</ul>
<h2 id="构造函数（初始化、赋值）"><a href="#构造函数（初始化、赋值）" class="headerlink" title="构造函数（初始化、赋值）"></a>构造函数（初始化、赋值）</h2><p>构造函数可以分为两步：</p>
<ul>
<li><strong>初始化</strong></li>
<li><strong>赋值</strong></li>
</ul>
<p>对比以下两种方式的构造函数，方式一在直接通过参数初始化变量；而方式二先初始化，然后再对变量进行赋值。显然效率就有差异。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：初始化</span></span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : re(r), im(i) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：赋值</span></span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">    re = r;</span><br><span class="line">    im = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>关键字 <code>const</code> 限定<strong>常量只读</strong>。仅在声明时进行初始化，若声明变量时没有提供值，则该常量的值将是不确定的，且无法修改。</p>
<p><code>const</code> 优于 <code>#define</code> ：</p>
<ol>
<li>const 能够明确指定类型</li>
<li>可以使用C++的作用域规则将定义限定在特定的函数或文件中</li>
<li>可以将 const 用于更复杂的类型</li>
</ol>
<h3 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h3><p>通常我的理解是用 <strong>const</strong> 修饰函数也就是标识函数不会修改数据。此时有了新的理解。先看简略代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的部分定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : re(r), im(i) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="comment">/* const */</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="comment">/* const */</span> </span>&#123; <span class="keyword">return</span> im; &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类对象的使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 常量对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.real() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.imag(); <span class="comment">// 函数调用可能修改值，矛盾！编译器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以上面代码来分析为什么要用 <strong>const</strong> ，我们定义的<strong>常量复数类对象</strong>打印输出复数实部和虚部，假如两个函数没有 const 修饰，意思是<strong>函数可能改数据</strong>，但是对象是常量，<strong>不允许改数据</strong>，这是 <font color=red><strong>矛盾的</strong></font> ，那么编译器表示不行。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">const object（data members 不可改变）</th>
<th align="center">non-const object（data members 可改变）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const member functions</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">non-const member functions</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong><em>当成员函数的 <code>const</code> 和 <code>non-const</code> 版本同时存在，const object 只会（只能）调用 const 版本，non-const object 只会（只能）调用 non-const 版本。</em></strong> </p>
<h2 id="friend友元"><a href="#friend友元" class="headerlink" title="friend友元"></a>friend友元</h2><p>友元函数可直接访问<strong>私有成员</strong>。</p>
<p><font color=red><b>同一个 <code>lass</code> 的各个 <code>objects</code> 互为友元。</b></font> （如：拷贝构造函数）</p>
<p>友元关系<strong>不可传递</strong>、<strong>不可继承</strong>。（你是我的朋友，但你的朋友不一定是我的朋友）</p>
<h2 id="拷贝构造、拷贝赋值"><a href="#拷贝构造、拷贝赋值" class="headerlink" title="拷贝构造、拷贝赋值"></a>拷贝构造、拷贝赋值</h2><p>class 带有 <code>pointer members</code> 必须有<strong>拷贝构造（深拷贝）</strong>和<strong>拷贝赋值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr) &#123; <span class="comment">// 拷贝构造</span></span><br><span class="line">   <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">      m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;   </span><br><span class="line">      m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">      *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str) &#123; <span class="comment">// 拷贝赋值</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">   <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数、析构函数"><a href="#构造函数、析构函数" class="headerlink" title="构造函数、析构函数"></a>构造函数、析构函数</h2><p><b><code>new</code></b> ：先分配内存 <code>memory</code> ，再调用构造 <code>constructor</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String* ps = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器转化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String* ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(String)); <span class="comment">// 分配内存 内部调用 malloc</span></span><br><span class="line">ps = <span class="keyword">static_cast</span>&lt;String*&gt;(mem);            <span class="comment">// 转型</span></span><br><span class="line">ps-&gt;String::String(<span class="string">&quot;Hello&quot;</span>);            <span class="comment">//构造函数</span></span><br></pre></td></tr></table></figure>

<p><b><code>delete</code></b> ：先再析构 <code>destructor</code> ，再释放内存 <code>memory</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> ps;</span><br></pre></td></tr></table></figure>

<p>编译器转化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String::~String(ps);             <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;            <span class="comment">// 释放内存 内部调用 free(ps)</span></span><br></pre></td></tr></table></figure>

<h2 id="动态分配所得内存块（in-VC）"><a href="#动态分配所得内存块（in-VC）" class="headerlink" title="动态分配所得内存块（in VC）"></a>动态分配所得内存块（in VC）</h2><p>创建Complex对象、String对象，编译器（VC）给两对象分配内存如下：</p>
<img src="https://i.loli.net/2020/09/16/oXHKxDMsbdeuZ7w.png" alt="动态分配所得内存块.png" style="zoom: 67%;" />

<ul>
<li><p><font color=00FF33><strong>绿色部分</strong></font>是<strong>对象实际占有的空间</strong> </p>
</li>
<li><p><font color=CC3333><strong>红色部分</strong></font>是<strong>cookie</strong>，编译器在对象内存的头尾插入cookie，cookie值表示内存块大小以及状态，如图中：</p>
<blockquote>
<p>cookie = 0x00000041</p>
<p>内存块大小 64 字节，对应十六进制数 0x40</p>
<p>内存块是已分配的（给出去了）cookie最后一位为 1 标识，由此的到cookie值 0x00000041</p>
</blockquote>
</li>
<li><p><font color=gray><strong>灰色部分</strong></font>是debug模式下编译器分配空间时需要插入的字节，VC下为 *<em>4</em>8+4** 字节</p>
</li>
<li><p><font color=33CCCC><strong>青色部分</strong></font>为<strong>字节对齐</strong>（VC为16字节对齐）</p>
</li>
</ul>
<p>对于数组array，内存块如下：</p>
<img src="https://i.loli.net/2020/09/16/D2OunVsfGLHo4tN.png" alt="动态分配array所得内存块.png" style="zoom: 50%;" />

<p><font color=red><strong>array new 一定要搭配 array delete</strong></font>，下图给出内存泄露位置：</p>
<img src="https://i.loli.net/2020/09/16/5ib9a1IGFDvWm2M.png" alt="array-new一定要搭配array-delete.png" style="zoom: 55%;" />

<h2 id="复合、委托、继承"><a href="#复合、委托、继承" class="headerlink" title="复合、委托、继承"></a>复合、委托、继承</h2><p><code>Composition</code> （复合）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="built_in">deque</span> c; <span class="comment">// 复合 （包含对象）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表示 <strong>has-a</strong> 关系。</li>
<li>构造函数<strong>由内向外</strong> </li>
<li>析构函数<strong>由外向内</strong> </li>
</ul>
<p><code>Delegation</code> （委托）：</p>
<p>个人理解有点文件存储node结点的味道。引用计数。写时复制，读时共享。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    StringRep* rep; <span class="comment">// 指针 指向实现功能的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Inheritance</code> （继承）：</p>
<ul>
<li>表示 <strong>is-a</strong> 关系（是一种）</li>
<li>构造函数由内而外（父类—子类）</li>
<li>析构函数由外而内（子类—父类）、父类析构必须为 <code>virtual</code> </li>
</ul>
<h3 id="复合-Composition-继承-Inheritance"><a href="#复合-Composition-继承-Inheritance" class="headerlink" title="复合(Composition)+继承(Inheritance)"></a>复合(Composition)+继承(Inheritance)</h3><p>析构函数顺序与构造函数恰好相反。</p>
<ul>
<li><p>情况一</p>
<blockquote>
<p><strong>构造函数</strong> ：Base —&gt; Composition —&gt; Derived<img src="https://i.loli.net/2020/09/16/iqjHPfFJ3s5malX.png" alt="Inheritance_Composition关系下的构造和析构_一_.png" style="zoom:67%;" /></p>
</blockquote>
</li>
<li><p>情况二（直接推导即知）</p>
<blockquote>
<p><strong>构造函数</strong> ：Composition —&gt; Base —&gt; Derived</p>
<img src="https://i.loli.net/2020/09/16/hanmBwb6gKfuqso.png" alt="Inheritance_Composition关系下的构造和析构_二_.png" style="zoom:67%;" />
</blockquote>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><code>non-virtual</code> 函数：非虚函数，不希望派生类重新定义（override）它；</p>
<p><code>vitual</code> 函数：虚函数，希望派生类重新定义，且已有默认定义；</p>
<p><code>pure virtual</code> 函数：纯虚函数，希望派生类一定要重新定义它，且，没有默认的定义。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p>仿函数（functors）另名函数对象（function objects）。</p>
<p>函数有函数名称，用一个 <code>()</code> 作用上去，任何一个东西如果可以接受 <code>()</code> 操作符，我们就称它 <strong>function-like</strong> 。每个<strong>仿函数</strong>都是某个类重载 <code>()</code> 运算符，然后变成了“仿函数”，实质还是一个类，但看起来具有函数的属性。</p>
<p>对 <code>()</code> 的重载，都继承了 <code>unary_function</code> 或 <code>binary_function</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span>  <span class="comment">// 一元函数</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span>  <span class="comment">// 二元函数</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="模板泛化、特化"><a href="#模板泛化、特化" class="headerlink" title="模板泛化、特化"></a>模板泛化、特化</h2><p><strong>泛化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>特化</strong>：模板特化指的是模板中指定特定的数据类型，这和泛化是不同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; retrun x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板特化也有程度之分，可以部分类型指定，称之为<strong>偏特化</strong>。</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="数量不定的模板参数"><a href="#数量不定的模板参数" class="headerlink" title="数量不定的模板参数"></a>数量不定的模板参数</h3><p><code>...</code> 就是所谓的 <strong>pack(包)</strong> ，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">firstArg</span>, <span class="title">const</span> <span class="title">Types</span>&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ite = find(c.begin(), c.end(), target);</span><br></pre></td></tr></table></figure>

<h3 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (decl : coll)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚指针、虚表"><a href="#虚指针、虚表" class="headerlink" title="虚指针、虚表"></a>虚指针、虚表</h2><p>只要类里有<strong>虚函数</strong>，类的对象就有一个<strong>指针（<code>vptr</code>）</strong>，指向一个<strong>虚函数表（虚表，<code>vtbl</code>）</strong>。基类有虚函数，派生类必然有虚函数。</p>
<img src="https://i.loli.net/2020/09/17/ImqXaP8hBDcLvWu.jpg" alt="虚函数-虚指针-虚表.jpg" style="zoom:67%;" />]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类型转换运算符</title>
    <url>/C++/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<ul>
<li><code>dynamic_cast</code>：有虚函数的类，指针或引用，类层次结构中进行转换（主要是向上转换）；</li>
<li><code>const_cast</code>：去掉 const 或 volatile 属性；</li>
<li><code>static_cast</code>：编译期间转换，没有运行时类型检查来保证转换的安全性；</li>
<li><code>reinterpret_cast</code>：仅仅重新解释类型，没有对数据进行调整。</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>

<p><code>dynamic_cast</code>动态类型转换，用于实现RTTI。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</p>
<ul>
<li><p>只能用于有<strong>虚函数</strong>的类；</p>
</li>
<li><p>只能用于<strong>指针</strong>或<strong>引用</strong>；</p>
</li>
<li><p>对运行期类型信息（RTTI）进行了检查，类层次结构中<strong>向上转换</strong>成功，其余转换返回空指针；</p>
<blockquote>
<p>若是基类指针指向派生类对象，再将基类指针向下转型，成功！</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> A();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    B *pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败 赋值NULL</span></span><br><span class="line">    C *pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败 赋值NULL</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> D();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const_cast</span> &lt; new_type &gt; ( expression )        </span><br></pre></td></tr></table></figure>

<p>修改类型的 <code>const</code> 或 <code>volatile</code> 属性。除了 const 或 volatile 修饰之外， new_type 和 expression 的类型必须是一样的。</p>
<p>函数指针和成员函数指针不可用于 <code>const_cast</code></p>
<p><strong><em>expression 内存空间是只读的，转换类型后，只能读，不能写</em></strong>。<font color=red><strong>转换后的指针或引用能修改值，源数据值却未改变，但是他们的地址是同一个！！！</strong></font>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;                 <span class="comment">// 不声明 i 为 const</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rci = i; </span><br><span class="line">    <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(rci) = <span class="number">4</span>; <span class="comment">// OK：修改 i</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// i = 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_val = <span class="number">233</span>;  <span class="comment">//声明为常量类型</span></span><br><span class="line">    <span class="keyword">int</span> &amp;use_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(c_val); <span class="comment">//使用去const 引用</span></span><br><span class="line">    <span class="keyword">int</span> *ptr_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;c_val);<span class="comment">//使用去const 指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;c_val = &quot;</span> &lt;&lt; &amp;c_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    use_val = <span class="number">111</span>;  <span class="comment">//未定义行为</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; <span class="string">&quot;\t&amp;use_val = &quot;</span> &lt;&lt; &amp;use_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    *ptr_val = <span class="number">222</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; <span class="string">&quot;\tptr_val = &quot;</span> &lt;&lt; ptr_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;&amp;c_val = &quot; &lt;&lt; &amp;c_val &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  https://zh.cppreference.com/w/cpp/language/const_cast  输出为</span></span><br><span class="line"><span class="comment">    i = 4</span></span><br><span class="line"><span class="comment">    &amp;c_val = 0x7ffd3abc86cc</span></span><br><span class="line"><span class="comment">    233    111    111    &amp;use_val = 0x7ffd3abc86cc</span></span><br><span class="line"><span class="comment">    233    222    222    ptr_val = 0x7ffd3abc86cc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>

<p><code>static_cast</code> 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。<code>static_cast</code> 是“静态转换”的意思，也就是在<strong>编译期间转换</strong>，转换失败的话会抛出一个编译错误。</p>
<ul>
<li>能使用隐式转换的地方，均可以使用<code>static_cast</code>转换；</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证；</li>
<li>如果类型不兼容，使用<code>static_cast</code>编译检查，会报错；</li>
<li>类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。向上转换是安全的，向下转换不安全；</li>
<li>把void指针转换成目标类型的指针(不安全！！)；</li>
<li>把任何类型的表达式转换成void类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是正确的用法</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">long</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line"><span class="keyword">void</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line"><span class="comment">//下面的用法是错误的</span></span><br><span class="line"><span class="keyword">float</span> *p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);  </span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reinterpret_cast</span>&lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>

<p>用于高度危险的类型转换，仅仅是对二进制位的<strong>重新解释</strong>，不会对数据进行调整。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1  = <span class="string">&quot;hello world&quot;</span>;                       </span><br><span class="line"><span class="keyword">int</span>  *p2  = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>能不能在头文件中定义全局变量？</title>
    <url>/C++/%E8%83%BD%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译器驱动程序</strong>（compiler driver），它代表用户在需要时调用语言<strong>预处理器</strong>、<strong>编译器</strong>、<strong>汇编器</strong>、和<strong>链接器</strong>。</p>
<p>我们所常说的 <em>“编译生成可执行文件”</em> 实际包括以下过程：</p>
<ol>
<li><p><strong>预处理器</strong> （某些编译系统，预处理器被集成到 <strong><em>编译器</em></strong>  中）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpp [other arguments] main.c /tmp/main.i</span><br></pre></td></tr></table></figure>

<p>处理预处理指令，生成<strong>中间文件</strong>，所有的预处理器命令都是以井号（#）开头。主要任务包括：</p>
<ul>
<li>删除注释；</li>
<li>插入被 #include 指令所包含的的文件内容；</li>
<li>定义和替换由#define指令定义的符号；</li>
<li>确定代码的部分内容是否应该根据一些条件编译指令进行编译；</li>
</ul>
</li>
<li><p><strong>编译器</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s</span><br></pre></td></tr></table></figure>

<p>将预处理后的中间文件翻译成一个<strong>ASCII汇编语言文件</strong>。</p>
</li>
<li><p><strong>汇编器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">as [other arguments] -o /tmp/main.o /tmp/main.s</span><br></pre></td></tr></table></figure>

<p>将ASCII汇编语言文件翻译成一个<strong>可重定位目标文件</strong>。</p>
</li>
<li><p><strong>链接器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o</span><br></pre></td></tr></table></figure>

<p>将一个或多个可重定位目标文件，以及必要的系统目标文件组合起来，创建一个<strong>可执行文件</strong>。</p>
</li>
</ol>
<img src="https://i.loli.net/2020/10/10/9y28jwNmZRcgiGE.png" alt="编译生成可执行文件过程.png" style="zoom:67%;" />

<h2 id="非静态全局变量"><a href="#非静态全局变量" class="headerlink" title="非静态全局变量"></a>非静态全局变量</h2><p>先个下结论：<font color=red><strong>可以，但非常非常非常不建议！！</strong></font> </p>
<ul>
<li>若头文件仅被一个源文件使用到，可以正常生成可执行文件。</li>
<li>若头文件被多个源文件包含，可正常执行完 cpp、cc1、as，但在链接(ld)时便会报错（重复定义）。</li>
</ul>
<p>由上面的图可以分析出，源程序代码在生成可执行文件的过程中，前三步均可看做独立完成的，仅在最后一步将多个源文件生成的目标文件链接起来。</p>
<p>如下代码：</p>
<p>a.cpp 、 b.cpp 在经过预处理器、编译器、汇编器时均认为是没有定义变量 A 的，于是都有变量定义。在链接时，便出现了二义性（重复定义）。</p>
<blockquote>
<p>[root@localhost val]# g++ a.cpp b.cpp </p>
<p>/tmp/ccVzRqVG.o:(.bss+0x0): multiple definition of `A’</p>
<p>/tmp/ccjI4zgp.o:(.bss+0x0): first defined here</p>
<p>collect2: error: ld returned 1 exit status</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H</span></span><br><span class="line"><span class="keyword">int</span> A;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line">                                              </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a.cpp : &quot;</span> &lt;&lt; A &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    funcA();</span><br><span class="line">    A =<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b.cpp : &quot;</span> &lt;&lt; A &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><p>上面的代码如若将变量 A定义为 static，编译执行没有问题。<strong>但是</strong>，静态变量的<strong>作用域仅在 ”当前源文件“</strong> ，即两处的变量 A 不是同一个变量，是不同的文件作用域内的静态变量。</p>
<p>“静态全局变量” 这个称谓其实就有点怪异，静态变量在文件作用域内就是全局的，且仅在文件作用域内。</p>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>全局变量在某一个源文件中定义，其余源文件若要使用，将外部声明 <code>extern</code> 写在头文件中，源文件包含这个头文件。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">int</span> nums;  <span class="comment">// 全局变量定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// out.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> nums;    <span class="comment">//外部变量声明</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;out.h&quot;</span> <span class="comment">// 相当于声明了外部变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_nums</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    nums = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>g++ a.cpp b.cpp</p>
</blockquote>
<h2 id="更加深入-全局变量"><a href="#更加深入-全局变量" class="headerlink" title="更加深入-全局变量"></a>更加深入-全局变量</h2><p>如果在 a.h 中变量定义时，定义为 <strong>“弱定义”</strong>，那么是能达到预期的目标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  A __attribute__((weak));</span><br></pre></td></tr></table></figure>

<h3 id="Linux-gcc"><a href="#Linux-gcc" class="headerlink" title="Linux gcc"></a>Linux gcc</h3><p><font color=red><strong><em>注意：仅在 gcc 下正确，换做 g++ 同样报错（重复定义）。</em></strong></font> </p>
<p>在编译时，编译器向汇编器输出每个全局符号，或者是<em>强（strong）</em>或者是<em>弱（weak）</em>，而编译器把这个信息隐含地编码在可重定位目标文件的符号表里。<strong>函数</strong>和<strong>已初始化的全局变量</strong>是*<strong>强(strong)符号*** 。<strong>未初始化的全局变量</strong>是*</strong>弱(weak)符号***。</p>
<p>根据弱符号的定义，<strong>Linux链接器</strong>使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li>规则1：不允许有多个同名的强符号。</li>
<li>规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>规则3：若干有多个弱符号同名，那么从这些弱符号中任意选择一个。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; &quot;begin f() x = &quot; &lt;&lt; x &lt;&lt; std::endl;      </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin f() x = %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">654321</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x  = <span class="number">12345</span>; <span class="comment">// 已初始化 强符号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f();</span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; &quot;after f() x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after f() x = %d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost 7]# gcc foo.c bar.c </span><br><span class="line">[root@localhost 7]# ./a.out </span><br><span class="line">begin f() x = 12345</span><br><span class="line">after f() x = 654321</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-分配器Allocators</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%88%86%E9%85%8D%E5%99%A8Allocator/</url>
    <content><![CDATA[<h1 id="先谈operator-new-和malloc"><a href="#先谈operator-new-和malloc" class="headerlink" title="先谈operator new()和malloc()"></a>先谈operator new()和malloc()</h1><p> <strong>new</strong>：指我们在C++里通常用到的<strong>运算符</strong></p>
<p><strong>operator new()**：指对new的重载形式，它是一个</strong>函数**，并不是运算符</p>
<p>函数operator new中调用malloc()进行内存分配。</p>
<p>malloc实际内存分配得到的内存空间如下：</p>
<p><img src="https://i.loli.net/2020/08/04/xN2TpBZyt3eKSoP.png" alt="malloc-new-分配得到的内存空间.png"></p>
<p>new 运算符执行过程：</p>
<ol>
<li>调用operator new分配内存（可重载）</li>
<li>调用构造函数构造生成类对象</li>
<li>返回相应的指针</li>
</ol>
<h1 id="SGI标准的分配器-—-allocator"><a href="#SGI标准的分配器-—-allocator" class="headerlink" title="SGI标准的分配器 — allocator"></a>SGI标准的分配器 — allocator</h1><p>最重要的两个函数：<code>allocate</code> 、<code>deallocate</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用 operator new()</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//调用 operator delete()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocato::deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br></pre></td></tr></table></figure>

<p>不建议使用，效率不佳，只对C++的<code>::operator new</code> 和 <code>::operator delete</code> 做了简单的包装在STL实际使用中，并没有使用 <code>allocator</code> 这个分配器。</p>
<h1 id="SGI-STL分配器-—-alloc（G2-9"><a href="#SGI-STL分配器-—-alloc（G2-9" class="headerlink" title="SGI STL分配器 — alloc（G2.9)"></a>SGI STL分配器 — alloc（G2.9)</h1><p><strong><em>注意：G4.9以后默认的分配器又变成了allocator；G4.9的__pool_alloc就是G2.9的alloc</em></strong></p>
<p>16条链表，每一条链表负责不同大小的区块。第0条负责8字节大小，以8字节大小增长</p>
<p>优点：减少内存分配时多余空间的分配</p>
<img src="https://i.loli.net/2020/08/04/NJt2yKDZ7E4Xo6P.png" alt="SGI-STL使用的分配器alloc原理图.png" style="zoom:70%;" />]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-RB-tree</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-RB-tree/</url>
    <content><![CDATA[<p><strong>在线演示：</strong><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树在线操作演示</a></p>
<h2 id="红黑树概念"><a href="#红黑树概念" class="headerlink" title="红黑树概念"></a>红黑树概念</h2><p><strong>RB Tree</strong>，全称是Red-Black Tree，又称为“红黑树”。红黑树本质上是一种<strong>二叉查找树</strong>，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 <code>O(logn)</code>。</p>
<h2 id="红黑树的性质-重点"><a href="#红黑树的性质-重点" class="headerlink" title="红黑树的性质(重点)"></a>红黑树的性质(重点)</h2><ol>
<li>每个节点不是<font color=red><strong>红色</strong></font>就是<strong>黑色</strong></li>
<li><strong>根结点</strong>永远都是<strong>黑色</strong></li>
<li>所有<strong>叶节点</strong>都是<strong>黑色</strong>（注意这里说叶子节点其实是上图中的 <code>NIL</code> 节点）</li>
<li>父子节点不同为<font color=red><strong>红色</strong></font></li>
<li>从任一节点到其子树中每个叶子节点的r任一路径都包含<strong>相同数量</strong>的<strong>黑色</strong>节点</li>
</ol>
<p><strong>注意</strong>：</p>
<blockquote>
<p>性质(3)中的叶子节点，是只为空(NIL或null)的节点。</p>
<p>性质(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/10/vfWSnHY2ZmdX3D6.jpg" alt="红黑树.jpg"></p>
<h2 id="树的旋转操作"><a href="#树的旋转操作" class="headerlink" title="树的旋转操作"></a>树的旋转操作</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>简略记忆：<font color=red size=5><strong>“右子变老子”</strong></font>，<strong>左旋中的“左”，意味着“被旋转的节点将变成一个左节点”</strong>。如图所示</p>
<ol>
<li>旋转点右孩子的左子树(B)变成旋转点的右子树</li>
<li>旋转点右孩子顶替旋转点位置</li>
<li>修改旋转点与右孩子关系</li>
</ol>
<img src="https://i.loli.net/2020/09/07/7JhabscBD6kIler.png" alt="左旋.png" style="zoom: 80%;" />

<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-左旋代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 左旋 右子节点变为父节点（原父节点变为右子节点的左节点）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __x-&gt;_M_right;</span><br><span class="line">  __x-&gt;_M_right = __y-&gt;_M_left; <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="comment">/* Step 1: right_child 的左子树 B 变成 p 的右子树 */</span></span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_left !=<span class="number">0</span>)</span><br><span class="line">    __y-&gt;_M_left-&gt;_M_parent = __x; <span class="comment">// B 的父节点修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: right_child 顶替 p 的位置 */</span></span><br><span class="line">  __y-&gt;_M_parent = __x-&gt;_M_parent;</span><br><span class="line">  <span class="keyword">if</span> (__x == __root)<span class="comment">// right_child 的父节点修改 </span></span><br><span class="line">    __root = __y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_left) <span class="comment">// p 为父节点的左孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_left = __y; </span><br><span class="line">  <span class="keyword">else</span>                                     <span class="comment">// p 为父节点的右孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 修改 p 和 right_child 关系 */</span></span><br><span class="line">  __y-&gt;_M_left = __x;</span><br><span class="line">  __x-&gt;_M_parent = __y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>简略记忆：<font color=red size=5><strong>“左子变老子”</strong></font>，<strong>右旋中的“右”，意味着“被旋转的节点将变成一个右节点”</strong>。如图所示</p>
<ol>
<li>旋转点左孩子的右子树(B)变成旋转点的左子树</li>
<li>旋转点左孩子顶替旋转点位置</li>
<li>修改旋转点与右孩子关系</li>
</ol>
<img src="https://i.loli.net/2020/09/07/VOxf3ajq8hH7ETd.png" alt="右旋.png" style="zoom: 80%;" />

<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-右旋代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 右旋 左子节点变为父节点（原父节点变为左孩子的右孩子）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __x-&gt;_M_left; <span class="comment">// 左孩子</span></span><br><span class="line">  <span class="comment">/* Step 1: left_child 的右子树 B 变成 p 的左子树 */</span></span><br><span class="line">  __x-&gt;_M_left = __y-&gt;_M_right; </span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">    __y-&gt;_M_right-&gt;_M_parent = __x; <span class="comment">// B 的父节点修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: left_child 顶替 p 的位置 */</span></span><br><span class="line">  __y-&gt;_M_parent = __x-&gt;_M_parent; <span class="comment">// left_child 的父节点修改</span></span><br><span class="line">  <span class="keyword">if</span> (__x == __root) <span class="comment">// p 为根节点</span></span><br><span class="line">    __root = __y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_right) <span class="comment">// p 为父节点的左孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line">  <span class="keyword">else</span>                                      <span class="comment">// p 为父节点的右孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_left = __y;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Step 3: 修改 p 和 left_child 关系 */</span></span><br><span class="line">  __y-&gt;_M_right = __x;</span><br><span class="line">  __x-&gt;_M_parent = __y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="STL红黑树插入节点"><a href="#STL红黑树插入节点" class="headerlink" title="STL红黑树插入节点"></a>STL红黑树插入节点</h2><p>红黑树的插入操作主要步骤如下：</p>
<ul>
<li>插入节点，和<strong>二叉查找树</strong>一样</li>
<li>调整结构，保证满足红黑树状态<ul>
<li>旋转操作</li>
<li>重新着色（新插入节点初始为<font color=red><strong>红色</strong></font>）</li>
</ul>
</li>
</ul>
<p><strong>假设：</strong></p>
<blockquote>
<p><strong>X</strong>：新节点（默认<font color=red><strong>红色</strong></font>）</p>
<p><strong>P</strong>：父节点</p>
<p><strong>S</strong>：伯父节点（父节点的兄弟节点）</p>
<p><strong>G</strong>：祖父节点</p>
<p><strong>GG</strong>：曾祖父节点</p>
</blockquote>
<table><tr><td bgcolor=yellow><b>强调：只有当父节点P为<font color=red >红色</font>时需要调整树形!!!</b></td></tr></table>

<p><strong>插入节点分为以下情况：</strong></p>
<ul>
<li><p><strong>状况1：无父</strong></p>
<blockquote>
<p>没有父节点（即插入后为根节点）</p>
</blockquote>
<p>直接着色新节点为<strong>黑色</strong>。</p>
</li>
<li><p><strong>状况2：父黑</strong></p>
<blockquote>
<p>父节点为黑色</p>
</blockquote>
<p>不用变色，新节点为<font color=red><strong>红色</strong></font>。</p>
</li>
<li><p><strong>状况3：父红，伯黑（或NIL），父子同侧</strong></p>
</li>
<li><p><strong>状况4：父红，伯黑（或NIL），父子异侧</strong></p>
</li>
<li><p><strong>状况5：父红，伯红</strong></p>
</li>
</ul>
<h3 id="状况3：父红，伯黑（或NIL），父子同侧"><a href="#状况3：父红，伯黑（或NIL），父子同侧" class="headerlink" title="状况3：父红，伯黑（或NIL），父子同侧"></a>状况3：父红，伯黑（或NIL），父子同侧</h3><blockquote>
<p>父节点是红色，伯父节点也是黑色（或NIL），祖父节点必定是黑色。</p>
<p>父子节点同侧，即，子节点、父节点、以及祖父节点是直线型。</p>
</blockquote>
<ol start="2">
<li>父节点、祖父节点<strong>变色</strong>（父节点变为黑色，祖父节点变为红色）</li>
<li>单旋，以<strong>祖父节点</strong>为旋转点<ul>
<li>父节点在左侧——右旋</li>
<li>父节点在右侧——左旋</li>
</ul>
</li>
</ol>
<img src="https://i.loli.net/2020/09/10/nSV3irRho1fXECK.png" alt="红黑树-父红-伯黑_或NIL_-父子同侧.png" />

<h3 id="状况4：父红，伯黑（或NIL），父子异侧"><a href="#状况4：父红，伯黑（或NIL），父子异侧" class="headerlink" title="状况4：父红，伯黑（或NIL），父子异侧"></a>状况4：父红，伯黑（或NIL），父子异侧</h3><blockquote>
<p>父节点是红色，伯父节点也是黑色（或NIL），祖父节点必定是黑色。</p>
<p>父子节点异侧，即，子节点、父节点、以及祖父节点是非直线型。</p>
</blockquote>
<ol>
<li>单旋，以父节点为旋转点<ul>
<li>子节点在左侧——右旋</li>
<li>子节点在右侧——左旋</li>
</ul>
</li>
<li>把<strong>父节点</strong>作为<strong>“新节点”</strong></li>
<li>按 <strong>状况3：父红，伯黑（或NIL），父子同侧</strong> 继续处理</li>
</ol>
<img src="https://i.loli.net/2020/09/10/WaumZbHoJGAKRU4.png" alt="红黑树-父红-伯黑_或NIL_-父子异侧.png" style="zoom:67%;" />

<h3 id="状况5：父红，伯红"><a href="#状况5：父红，伯红" class="headerlink" title="状况5：父红，伯红"></a>状况5：父红，伯红</h3><blockquote>
<p>父节点是红色，伯父节点也是红色，祖父节点必定是黑色。</p>
</blockquote>
<ol>
<li><p>变色</p>
<ul>
<li>父节点变<strong>黑色</strong></li>
<li>伯父节点变<strong>黑色</strong></li>
<li>祖父节点变<font color=red><strong>红色</strong></font></li>
</ul>
</li>
<li><p>把<strong>祖父节点</strong>作为<strong>“新节点”</strong></p>
</li>
<li><p>向上继续调整：</p>
<p>3.1 曾祖父节点为<strong>黑色</strong>，结束</p>
<p>3.2 当前新节点为<strong>根</strong>，直接设置成<strong>黑色</strong>，结束</p>
<p>3.3 曾祖父节点为<font color=red><strong>红色</strong></font>，所属状况，继续调整树形</p>
</li>
</ol>
<img src="https://i.loli.net/2020/09/10/Xzra3KJARyQPIWB.png" alt="红黑树-父红-伯红.png" style="zoom:67%;" />

<h3 id="STL红黑树调整平衡源码"><a href="#STL红黑树调整平衡源码" class="headerlink" title="STL红黑树调整平衡源码"></a>STL红黑树调整平衡源码</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-STL红黑树调整平衡</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  __x-&gt;_M_color = _S_rb_tree_red; <span class="comment">// 新节点 设置为红</span></span><br><span class="line">  <span class="comment">/* 当前新节点不是根节点，并且其父节点为红色 */</span></span><br><span class="line">  <span class="keyword">while</span> (__x != __root &amp;&amp; __x-&gt;_M_parent-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">    <span class="comment">/* 父红，父节点为祖父节点的左孩子 */</span></span><br><span class="line">    <span class="keyword">if</span> (__x-&gt;_M_parent == __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left) &#123;</span><br><span class="line">      _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_right; <span class="comment">// 伯父节点</span></span><br><span class="line">      <span class="comment">/* 状况5：父(左)红，伯(右)红 */</span></span><br><span class="line">      <span class="keyword">if</span> (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123; </span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; <span class="comment">//父变黑</span></span><br><span class="line">        __y-&gt;_M_color = _S_rb_tree_black; <span class="comment">//伯变黑</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; <span class="comment">//祖父变红</span></span><br><span class="line">        __x = __x-&gt;_M_parent-&gt;_M_parent; <span class="comment">//设置祖父为 当前新节点</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 伯父节点为黑色（或NIL）</span></span><br><span class="line">      <span class="comment">/* 状况4：父(左)红，伯(右)黑(或NIL)，新节点为右子 #附加# */</span></span><br><span class="line">        <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_right) &#123;</span><br><span class="line">          __x = __x-&gt;_M_parent;</span><br><span class="line">          _Rb_tree_rotate_left(__x, __root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 状况3：父(左)红，伯(右)黑(或NIL)，新节点为左子 */</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        _Rb_tree_rotate_right(__x-&gt;_M_parent-&gt;_M_parent, __root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left; <span class="comment">// 伯父节点</span></span><br><span class="line">      <span class="comment">/* 状况5：父(右)红，伯(左)红 */</span></span><br><span class="line">      <span class="keyword">if</span> (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; <span class="comment">//父变黑</span></span><br><span class="line">        __y-&gt;_M_color = _S_rb_tree_black; <span class="comment">//伯父变黑</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; <span class="comment">//祖父变红</span></span><br><span class="line">        __x = __x-&gt;_M_parent-&gt;_M_parent; <span class="comment">//祖父为 新节点</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 状况4：父(右)红，伯(左)黑(或NIL)，新节点为左子 */</span></span><br><span class="line">        <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_left) &#123;</span><br><span class="line">          __x = __x-&gt;_M_parent;</span><br><span class="line">          _Rb_tree_rotate_right(__x, __root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 状况3：父(右)红，伯(左)黑(或NIL)，新节点为右子 */</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        _Rb_tree_rotate_left(__x-&gt;_M_parent-&gt;_M_parent, __root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __root-&gt;_M_color = _S_rb_tree_black; <span class="comment">// 根节点设置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="STL红黑树删除节点"><a href="#STL红黑树删除节点" class="headerlink" title="STL红黑树删除节点"></a>STL红黑树删除节点</h2><p>红黑树可以看成是具有特殊性质的二叉查找树，因此红黑树的删除过程可分为两步：</p>
<ul>
<li><strong>第一步：二叉树的删除过程</strong></li>
<li><strong>第二步：红黑树的调整过程</strong></li>
</ul>
<h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><p>二叉查找树的删除分为以下情况：</p>
<ol>
<li>删除节点是叶子节点，直接删除；</li>
<li>删除节点只有左孩子（或右孩子），孩子节点替代删除节点位置；</li>
<li>删除节点有两个孩子，选择一个合适的<strong>子孙节点</strong>替代删除节点位置，该节点称为<strong>继承节点</strong>。</li>
</ol>
<h3 id="红黑树的调整过程"><a href="#红黑树的调整过程" class="headerlink" title="红黑树的调整过程"></a>红黑树的调整过程</h3><p>按照二叉查找树的规则删除节点后，还需要检查是非满足红黑树的性质。</p>
<p>根据红黑树的性质，主要是性质4）父子节点不同为<font color=red><strong>红色</strong></font>，性质5）从任一节点到其子树中每个叶子节点的r任一路径都包含<strong>相同数量</strong>的<strong>黑色</strong>节点。</p>
<p>待补充。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u011240877/article/details/53329023">重温数据结构：深入理解红黑树</a> </p>
<p><a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-deque</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-deque/</url>
    <content><![CDATA[<img src="https://i.loli.net/2020/08/08/wGu91Lk2fCWIN5U.jpg" alt="deque示意图.jpg" style="zoom: 10%;" />

<h2 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h2><ul>
<li>deque 是一种<strong>双向开口</strong>的<strong>连续线性</strong>空间。可以在头尾两端分别做元素的插入和删除操作。</li>
<li>deque是有一段一段的定量连续空间构成，是<strong>动态分段连续</strong>。</li>
<li>deque 和 vector 的差异：<ul>
<li>deque 允许于常数时间内对两端进行元素的插入或移除操作。</li>
<li>deque 没有容量，它是动态地以分段连续空间组合而成。</li>
</ul>
</li>
<li>deque 采用一块所谓的 <code>map</code> 作为主控。这个 map 是一小块连续空间（默认初值大小<strong>8个节点</strong>），其中每个节点都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。</li>
<li>deque 是分段连续空间，迭代器维持其“整体连续”的<strong>假象</strong>，并提供随机存取的接口。</li>
<li>一旦<code>map</code>提供的节点不足，就必须重新配置一个更大的一块<code>map</code>（<strong>至少两倍+2</strong>）。并将原来的数据放在<strong>中央</strong>，以使头尾两端的扩充能量一样大。</li>
<li>插入数据时，deque会根据插入位置与两端的距离判断向前还是向后。</li>
</ul>
<img src="https://i.loli.net/2020/08/08/nl75O1bUu9TzIQ4.png" alt="deque分段连续示意图.png" style="zoom:80%;" />

<h2 id="deque-的中控器map"><a href="#deque-的中控器map" class="headerlink" title="deque 的中控器map"></a>deque 的中控器map</h2><p>deque 采用一块所谓的 <code>map</code> 作为主控。这个 map 是一小块连续空间，其中每个节点都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。</p>
<h3 id="map默认初始大小为8"><a href="#map默认初始大小为8" class="headerlink" title="map默认初始大小为8"></a>map默认初始大小为8</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; _S_initial_map_size = <span class="number">8</span> &#125;; <span class="comment">// map默认初始大小 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _M_initialize_map(size_t __num_elements)中</span></span><br><span class="line"><span class="comment">// map最少8个节点，最多“所需节点数+2”（前后各预留一个，扩容时可以用）</span></span><br><span class="line"><span class="keyword">this</span>-&gt;_M_impl._M_map_size = <span class="built_in">std</span>::<span class="built_in">max</span>((<span class="keyword">size_t</span>)_S_initial_map_size, <span class="keyword">size_t</span>(__num_nodes + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="map空间重新配置"><a href="#map空间重新配置" class="headerlink" title="map空间重新配置"></a>map空间重新配置</h3><p>扩容一次至<strong>至少两倍+2</strong>。</p>
<blockquote>
<p>size_type __new_map_size = _M_map_size + max(_M_map_size, __nodes_to_add) + 2;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _M_reserve_map_at_back (size_type __nodes_to_add = <span class="number">1</span>) &#123; <span class="comment">/*默认新增节点数=1*/</span></span><br><span class="line">  <span class="keyword">if</span> (__nodes_to_add + <span class="number">1</span> &gt; _M_map_size - (_M_finish._M_node - _M_map))</span><br><span class="line">    _M_reallocate_map(__nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_reserve_map_at_front (size_type __nodes_to_add = <span class="number">1</span>) &#123; <span class="comment">/*默认新增节点数=1*/</span></span><br><span class="line">  <span class="keyword">if</span> (__nodes_to_add &gt; size_type(_M_start._M_node - _M_map))</span><br><span class="line">    _M_reallocate_map(__nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;_Tp,_Alloc&gt;:</span>:_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          <span class="keyword">bool</span> __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + <span class="number">1</span>;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">   <span class="comment">/* map节点总数 &gt; 2倍新需节点数，则移动调整节点到中央 */</span></span><br><span class="line">  <span class="keyword">if</span> (_M_map_size &gt; <span class="number">2</span> * __new_num_nodes) &#123;</span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / <span class="number">2</span> </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      copy(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      copy_backward(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/* map节点总数不足2倍新需节点数，从新配置 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 重点!!!  现有map节点数 + max(现有map节点数, 新增节点数) +2  !!! */</span></span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + <span class="built_in">max</span>(_M_map_size, __nodes_to_add) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拷贝原map节点数据到新map中央 */</span></span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);</span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / <span class="number">2</span></span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    copy(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size); <span class="comment">/* 释放原map空间 */</span></span><br><span class="line">    </span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/* 设置新的map的start、finish迭代器 */</span></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="deque迭代器"><a href="#deque迭代器" class="headerlink" title="deque迭代器"></a>deque迭代器</h2><ul>
<li>指向连续空间</li>
<li>能判断空间边界，在边界上移动能指向正确的下一个连线空间</li>
<li>随机存取</li>
</ul>
<p><strong>_Deque_iterator</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Tp* _M_cur;        <span class="comment">//此迭代器所指的缓冲区的当前元素位置</span></span><br><span class="line">_Tp* _M_first;        <span class="comment">//此迭代器所指的缓冲区的头</span></span><br><span class="line">_Tp* _M_last;        <span class="comment">//此迭代器所指的缓冲区的尾</span></span><br><span class="line">_Map_pointer _M_node;    <span class="comment">//指向管控中心 map</span></span><br></pre></td></tr></table></figure>

<h2 id="deque插入数据"><a href="#deque插入数据" class="headerlink" title="deque插入数据"></a>deque插入数据</h2><ol>
<li><p>若头部插入：<code>push_front</code></p>
</li>
<li><p>若尾部插入： <code>push_back</code></p>
</li>
<li><p>中间位置插入：</p>
<p>1）判断距离哪端近</p>
<p>2）移动元素</p>
<p>3）插入新元素</p>
</li>
</ol>
<h2 id="deque基本操作"><a href="#deque基本操作" class="headerlink" title="deque基本操作"></a>deque基本操作</h2><p><code>push_back()</code>：尾端插入</p>
<p><code>push_front()</code>：头端插入</p>
<p><code>pop_back()</code>：尾端取出</p>
<p><code>pop_front()</code>：头端取出</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-list</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-list/</url>
    <content><![CDATA[<p>STL list 容器，又称<strong>双向链表容器</strong>，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p>
<p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速<strong>插入</strong>或<strong>删除</strong>元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p>
<p>查找元素需要遍历容器链表，时间复杂度为<code>O(n)</code>。</p>
<h1 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h1><p>增加一个”哨兵“，便能符合STL对于”前闭后开“区间的要求。</p>
<img src="https://i.loli.net/2020/08/04/vMCmnAWwHZXK39Y.png" alt="list-双向环形链表.png" style="zoom:67%;" />

<h1 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h1><p>由于STL list是一个<strong>双向环形链表</strong>，迭代器必须具备前移、后移的能力，所以list提供的是 <code>Bidirectional Iterators</code> 。</p>
<p>list一重要性质：插入（insert）和拼接（splice）都<strong>不会</strong>造成原有的list迭代器失效（区别于vector）。</p>
<p>list迭代器部分设计：</p>
<p> <strong><em>因前 <code>++</code> （或前 <code>--</code> ）返回值为引用，故允许：<code>++++i</code> 、 <code>----i</code> ；</em></strong></p>
<p><strong><em>后 <code>++</code> (或 <code>--</code> )则不允许这样</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对迭代器累计+1 也就是前进一个结点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;     <span class="comment">// 前++ (++i) 无参数</span></span><br><span class="line">    node = (link_type)(node-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   <span class="comment">// 后++ (i++) 有参数，参数无意义</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//对迭代器累计-1 也就是前进一个结点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    node = (link_type)(node-&gt;prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="list数据结构"><a href="#list数据结构" class="headerlink" title="list数据结构"></a>list数据结构</h1><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>返回一个引用，指向最后一个元素</td>
</tr>
<tr>
<td>begin()</td>
<td>返回指向第一个元素的迭代器</td>
</tr>
<tr>
<td>clear()</td>
<td>删除所有元素</td>
</tr>
<tr>
<td>empty()</td>
<td>如果list是空的则返回true</td>
</tr>
<tr>
<td>end()</td>
<td>返回末尾的迭代器</td>
</tr>
<tr>
<td>erase()</td>
<td>删除以pos指示位置的元素, 或者删除<em>start</em>和<em>end</em>之间的元素。 返回值是一个迭代器，指向最后一个被删除元素的下一个元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回一个引用，指向第一个元素</td>
</tr>
<tr>
<td><strong>insert()</strong></td>
<td>插入元素val到位置pos，返回值是一个迭代器，指向被插入的元素。 或者插入num个元素val到pos之前。或者插入start到end之间的元素到pos的位置。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个list（合并到this上，必须先经过<strong>递增排序</strong>）</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除最后一个元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除第一个元素</td>
</tr>
<tr>
<td>push_back()</td>
<td>在list的末尾添加一个元素</td>
</tr>
<tr>
<td>push_front()</td>
<td>在list的头部添加一个元素</td>
</tr>
<tr>
<td>remove()</td>
<td>从list删除所有值为val的元素</td>
</tr>
<tr>
<td>remove_if()</td>
<td>按指定条件删除元素</td>
</tr>
<tr>
<td>resize()</td>
<td>改变list的大小</td>
</tr>
<tr>
<td>reverse()</td>
<td>把list的元素倒转</td>
</tr>
<tr>
<td>size()</td>
<td>返回list中的元素个数</td>
</tr>
<tr>
<td><strong>sort()</strong></td>
<td>给list排序</td>
</tr>
<tr>
<td>splice()</td>
<td>合并两个list</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个list</td>
</tr>
<tr>
<td>unique()</td>
<td>删除list中<strong>数值相同的连续</strong>元素（保留连续的值相同的第一个元素）</td>
</tr>
</tbody></table>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><code>list</code> 不能使用 STL 算法 <code>sort()</code> ，必须使用自己的 <code>sort()</code> 。</p>
<p>因为STL算法sort()只能接受 <code>RamdonAccessIterator</code> 。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-slist</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-slist/</url>
    <content><![CDATA[<p>STL list是一个双向链表（double linked list）。SGI STL提供了另一个单向链表（single linked list）也就是<code>slist</code>。</p>
<p><code>slist</code>与<code>list</code>差异：</p>
<ol>
<li>slist迭代器是单向的Forward Iterator，list迭代器是双向的Bidirectional Iterator。（slist迭代器没有<code>--</code>操作，因为是单向的Forward Iterator）。</li>
<li>单向链表所耗空间更小。</li>
<li>list是<strong>双向环形</strong>链表，slist是<strong>单向</strong>链表。</li>
<li>slist不提供push_back()，仅提供**push_front()**（头插法）。</li>
</ol>
<p><code>slist</code>与<code>list</code>相同点：</p>
<ol>
<li>都具有“头节点”，且都不放置元素数据。</li>
<li>进行插入、删除、接合等操作，均不会导致原迭代器失效（当然，指向被移除的那个节点的迭代器肯定会失效）。</li>
<li><code>list</code>和<code>slist</code>都不能使用 STL 算法 <code>sort()</code> ，必须使用自己的 <code>sort()</code> 。</li>
</ol>
<p>slist基本操作：</p>
<p><code>push_front()</code>：从头部插入元素</p>
<p><code>pop_front()</code>：从头部取出元素</p>
<p><code>front()</code>：取头部元素</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-stack-queue</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-stack-queue/</url>
    <content><![CDATA[<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack是一种先进后出(First In Last Out, <strong>FILO</strong>)的数据结构。只有一个出口。</p>
<p>SGI STL 默认是以<strong>deque</strong>作为缺省情况下的stack底层结构。也可以 <strong>list</strong> 作为 stack 的底层容器。</p>
<p>STL stack 往往不被归类为 container(容器)，而被归类为 <strong>container adapter</strong>。</p>
<p>stack所有的元素都必须符合“先进后出”的条件，只有从stack顶端对其进行新增、移除、读取操作，即stack<strong>不允许遍历</strong>行为，stack<strong>不提供迭代器</strong>。</p>
<img src="https://i.loli.net/2020/08/09/SLDxIahQRYBuc5y.jpg" alt="stack.jpg" style="zoom: 25%;" />

<p>stack基本操作：</p>
<p><code>push()</code>：顶部入栈</p>
<p><code>pop()</code>：顶部出栈</p>
<p><code>top()</code>：：指向栈顶</p>
<p><code>empty()</code>：判断栈空</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue是一种先进先出(First In First Out, FIFO)的数据结构。有两个出口，从最底端加入元素、最顶端取出元素。</p>
<p>SGI STL 默认是以 <strong>deque</strong> 作为缺省情况下的 queue 底部结构。也可以 <strong>list</strong> 作为 stack 的底层容器。</p>
<p>STL queue往往不被归类为 container(容器)，而被归类为 <strong>container adapter</strong>。</p>
<p>stack所有的元素都必须符合“先进先出”的条件，只有从queue尾端增加元素、头端取出元素。queue<strong>不允许遍历</strong>行为，queue<strong>不提供迭代器</strong>。</p>
<img src="https://i.loli.net/2020/08/09/jFngpJdNtEyoqAm.jpg" alt="queue.jpg" style="zoom:25%;" />

<p>queue基本操作：</p>
<p><code>push()</code>：尾端入队</p>
<p><code>pop()</code>：首端出队</p>
<p><code>front()</code>：返回队首</p>
<p><code>back()</code>：返回队尾</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-vector</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-vector/</url>
    <content><![CDATA[<p>vector 常被称为向量容器，因为该容器擅长在<strong>尾部</strong>插入或删除元素，在常量时间内就可以完成，时间复杂度为<code>O(1)</code>；而对于在容器<strong>头部或者中部</strong>插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶<code>O(n)</code>。</p>
<p>vector实现的关键在于其对<strong>大小的控制</strong>以及<strong>重新配置时的数据移动效率</strong>。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>vector 与 array 唯一区别是空间的运用的灵活性。<ul>
<li>array 是<strong>静态空间</strong>，一旦配置了就不能改变。</li>
<li>vector是<strong>动态空间</strong>。</li>
</ul>
</li>
<li>vector 维护的是一个<strong>连续线性空间</strong>，所以不论其元素类型为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。</li>
<li>增加新元素时，如果超过当时的容量，则容量会扩大至<strong>两倍</strong>。</li>
</ul>
<img src="https://i.loli.net/2020/08/07/5KPtrc42gBWpMnz.png" alt="vector-两倍增长示意图.png" style="zoom:67%;" />

<ul>
<li><p>所谓动态增加大小，并不是在原空间之后接续新空间(因为无法保证原空间之后尚有可供配置的空间)，而是以原空间的两倍大小另外配置一块较大空间，然后将原内容拷贝过来并插入新元素，释放原空间，最后更新迭代器！！！</p>
</li>
<li><p>一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p>
</li>
<li><p><code>at()</code> 函数 比 <code>[]</code> 运算符更加安全, 因为它不会让你去访问到Vector内越界的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_THROW_RANGE_ERRORS</span></span><br><span class="line">  <span class="keyword">void</span> _M_range_check(size_type __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt;= <span class="keyword">this</span>-&gt;<span class="built_in">size</span>())</span><br><span class="line">      __stl_throw_range_error(<span class="string">&quot;vector&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">reference <span class="title">at</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; _M_range_check(__n); <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">at</span><span class="params">(size_type __n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; _M_range_check(__n); <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_THROW_RANGE_ERRORS */</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vector动态增加容量原理-M-insert-aux"><a href="#vector动态增加容量原理-M-insert-aux" class="headerlink" title="vector动态增加容量原理_M_insert_aux"></a>vector动态增加容量原理_M_insert_aux</h2><p><strong>过程分析：</strong></p>
<blockquote>
<ol>
<li><p>配置一块更大空间（2倍，初始为0则配置新的空间大小为1）</p>
</li>
<li><p>拷贝原数据并插入新元素</p>
<p>1）拷贝插入位置前的数据</p>
<p>2）在插入位置插入新元素</p>
<p>3）拷贝插入位置后的数据</p>
</li>
<li><p>释放原空间</p>
</li>
<li><p>更新迭代器！！！</p>
</li>
</ol>
</blockquote>
<p>源码参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp, _Alloc&gt;:</span>:_M_insert_aux(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line">&#123; <span class="comment">/* 判断是否有备用空间 */</span></span><br><span class="line">  <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">    construct(_M_finish, *(_M_finish - <span class="number">1</span>));</span><br><span class="line">    ++_M_finish;</span><br><span class="line">    _Tp __x_copy = __x;</span><br><span class="line">    copy_backward(__position, _M_finish - <span class="number">2</span>, _M_finish - <span class="number">1</span>);</span><br><span class="line">    *__position = __x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">/* 扩容两倍。 注意：初始时为0，扩容后为1 */</span></span><br><span class="line">    <span class="keyword">const</span> size_type __len = __old_size != <span class="number">0</span> ? <span class="number">2</span> * __old_size : <span class="number">1</span>;</span><br><span class="line">    iterator __new_start = _M_allocate(__len); <span class="comment">/*分配新的连续空间*/</span></span><br><span class="line">    iterator __new_finish = __new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="comment">/* 拷贝插入位置前的数据到新空间 [old_start, position) --&gt; [new_start, position) */</span></span><br><span class="line">      __new_finish = uninitialized_copy(_M_start, __position, __new_start);</span><br><span class="line">      <span class="comment">/* 插入新元素 position */</span></span><br><span class="line">      construct(__new_finish, __x);</span><br><span class="line">      ++__new_finish;</span><br><span class="line">      <span class="comment">/* 拷贝插入位置后的数据到新空间 [position, finish) -- [position+1, new_finish) */</span></span><br><span class="line">      __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 释放原空间 */</span></span><br><span class="line">    __STL_UNWIND((destroy(__new_start,__new_finish), </span><br><span class="line">                  _M_deallocate(__new_start,__len)));</span><br><span class="line">    destroy(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    <span class="comment">/* 更新迭代器 */</span></span><br><span class="line">    _M_start = __new_start;</span><br><span class="line">    _M_finish = __new_finish;</span><br><span class="line">    _M_end_of_storage = __new_start + __len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector基本操作"><a href="#vector基本操作" class="headerlink" title="vector基本操作"></a>vector基本操作</h2><p><code>push_back()</code>：插入操作(末尾)</p>
<p><code>pop_back()</code>：删除操作(末尾)</p>
<p><code>erase()</code>：清除某范围 <code>[first, last)</code> 元素，或删除某个位置上的元素</p>
<p><code>insert()</code>：从某个位置，插入 n 个元素，元素初值为x</p>
<p><code>clear()</code>：清除所有元素</p>
<p><code>begin()</code>：返回第一个元素的迭代器</p>
<p><code>end()</code>：返回最末元素的迭代器(译注:实指向最末元素的下一个位置)</p>
<p>注意：</p>
<p><code>reserve(size_type __n)</code>：配置vector容量为<code>__n</code>，如果 vector 的容量已经大于或等于<code>__n</code>个元素，那么什么也不做；调用 reserve() 不会影响已存储的元素，也不会生成任何元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; __x);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(size_type __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (capacity() &lt; __n) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">    iterator __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);</span><br><span class="line">    destroy(_M_start, _M_finish);</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    _M_start = __tmp;</span><br><span class="line">    _M_finish = __tmp + __old_size;</span><br><span class="line">    _M_end_of_storage = _M_start + __n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器priority_queue-heap(算法)</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8priority_queue-heap(%E7%AE%97%E6%B3%95)/</url>
    <content><![CDATA[<img src="https://i.loli.net/2020/08/09/KF12cDuCQVkaYmT.png" alt="完全二叉树即其array表述式.png" style="zoom: 67%;" />

<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>heap的实现就是数据结构中的<strong>堆</strong>（大顶堆、小顶堆）。STL提供<code>max-heap</code>。</p>
<p>STL中并没有把<code>heap</code>作为一种容器组件，heap的实现亦需要更低一层的容器组件，诸如list，array，vector。heap并不属于STL容器，但它是其中一个容器<code>priority queue</code>必不可少的一部分。</p>
<p><strong>heap没有迭代器，</strong>heap的所有元素都必须遵循特别的排列规则，所以heap不提供遍历功能，也不提供迭代器。</p>
<h3 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h3><blockquote>
<ol>
<li><p>最新加入的源放在最下层叶子节点，填补从左至右第一个空闲单元</p>
</li>
<li><p>percolate up（上溯）：与父节点比较，调整位置</p>
<blockquote>
<p>将新节点与父节点比较，如果其键值比父节点大，就交换父子的位置，如此一直上溯，直到不需要交换或者到根节点为止。</p>
</blockquote>
</li>
</ol>
</blockquote>
<img src="https://i.loli.net/2020/08/09/5Dz7RYnrlGKIkmc.png" alt="push_heap演示.png" style="zoom: 67%;" />

<h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h3><blockquote>
<ol>
<li><p>把原尾端节点的值拿出来放至一临时变量里，然后该位置放根节点的值（最后会被pop_back()给移除）</p>
</li>
<li><p>重新构建大顶堆，实施如下调整堆：</p>
<p>1）<strong>percolate down</strong>（下溯）：从根节点开始将空洞节点（一开始是根节点）和较大子节点交换，并持续向下进行，直到到达叶节点为止。然后将已保存的原容器vector尾端节点赋给这个已到达叶层的空洞节点。</p>
<p>2）此时可能尚未满足次序特性，再执行一次<strong>percolate up</strong>（上溯）操作</p>
</li>
</ol>
</blockquote>
<p><strong><em>注意：pop_heap之后，最大元素只是被放置于底部容器的最尾端，尚未被取走。如果要取其值，可使用底部容器的back()函数。如果要移除它，可使用底部容器所提供的pop_back()函数。</em></strong></p>
<img src="https://i.loli.net/2020/08/09/PXJQOjWxi9Scezq.png" alt="pop_heap演示.png" style="zoom: 67%;" />

<h3 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h3><p><strong>堆排序算法</strong>。执行此操作之后，容器vector中的元素按照从小到大的顺序排列。</p>
<img src="https://i.loli.net/2020/08/09/fnZlGrWJxibYPo2.png" alt="sort_heap演示.png" style="zoom:67%;" />

<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>构建堆实质是一个不断调整堆的过程—通过不断调整子树，使得子树满足堆的特性来使得整个树满足堆的性质。</p>
<p>第一个需要执行调整操作的子树的根节点是从后往前的第一个非叶结点。从此节点往前到根节点对每个子树执行调整操作，即可构建堆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个 heap。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">make_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    __make_heap(first, last, value_type(first), distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">make_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">    <span class="title">Distance</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; ) <span class="keyword">return</span>; <span class="comment">// 如果長度為 0 或 1，不必重新排列。</span></span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以 parent 标示出。由于任何叶子节点都不需执行</span></span><br><span class="line">        <span class="comment">// perlocate down（下沉），所以有以下计算。</span></span><br><span class="line">        Distance parent = (len - ) / ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len 是为了让 __adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, T(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == ) <span class="keyword">return</span>; <span class="comment">// 直至根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// 未到根节点，就将（即将重排的子树的）索引值向前一個节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><code>priority_queue</code> 是一个拥有权值观念的 queue。</p>
<p>默认情况下以 <code>vector</code> 为底部容器完成其所有工作，再加上 <code>heap</code> 处理规则。</p>
<p>priority_queue的所有元素，都不一定的进程出规则，只有queue顶端的元素（权值最高）才有机会被外界取用。故<code>priority_queue</code>不提供遍历功能，也不提供迭代器。</p>
<p>priority_queue 基本操作：</p>
<p><code>priority_queue()</code>：调用 <code>make_heap()</code>， 使进入的元素后，始终保持一个堆。</p>
<p><code>top()</code>：队顶元素。</p>
<p><code>push()</code>：<code>push_back()</code>尾端插入元素，然后调用 <code>push_heap()</code> 重排堆。</p>
<p><code>pop()</code>：用 <code>pop_heap() </code>将最大元素放到底部容器的最尾端，<strong>并不是真正弹出</strong>，再调用底部容器 vector 所提供的 <code>pop_back()</code> 弹出元素。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.shuzhiduo.com/A/E35pRNwRzv/">STL源码剖析——序列式容器#5 heap</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-迭代器-iterators</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8-iterators/</url>
    <content><![CDATA[<p>迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL中迭代器一个最重要的作用就是作为容器(vector,list等)与STL算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。</p>
<p>从实现的角度来看，迭代器是一种将 <code>operator*</code>，<code>operator-&gt;</code>，<code>operator++</code>，<code>operator--</code> 等指针相关操作予以重载的 class template。 所有 STL 容器都附带有自己专属的迭代器。 native pointer 也是一种迭代器。</p>
<p>为什么每一种 STL 容器都提供有专属迭代器？主要是暴露太多细节，所以把迭代器的开发工作交给容器去完成，这样所有实现细节可以得到封装，不被使用者看到。</p>
<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><img src="https://i.loli.net/2020/08/10/MQOyeBwmSgTt8j9.png" alt="iteratortraits.png" style="zoom: 80%;" />

<h2 id="迭代器所指对象类型-associated-types"><a href="#迭代器所指对象类型-associated-types" class="headerlink" title="迭代器所指对象类型(associated types)"></a>迭代器所指对象类型(associated types)</h2><p>迭代器所指的对象类型有五种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tempalte&lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category  iterator_category;    <span class="comment">//迭代器的分类</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type  value_type;                 <span class="comment">//迭代器所指对象的型别</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type  difference_type;        <span class="comment">//两迭代器之间的距离</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer  pointer;                        <span class="comment">//指针，指向迭代器所指之物</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference  reference;                    <span class="comment">//类似引用类型，允许改变“所指对象的值”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h2><ol>
<li>Input Iterator ：能从所指向元素读取的迭代器（<strong>只读</strong>）。仅保证单趟算法的合法性。</li>
<li>Output Iterator ：能写入所指元素的迭代器（<strong>只写</strong>）。</li>
<li>Forward Iterator ：一种能从所指向元素读取数据的迭代器 。</li>
<li>Bidirectional Iterator：能<strong>双向移动</strong>（即自增与自减）的迭代器 。</li>
<li>Random Access Iterator ：<strong>随机读写</strong>，能在常数时间内移动到指向任何元素的双向迭代器。</li>
</ol>
<img src="https://i.loli.net/2020/08/10/NBfOK4GX572eFYL.png" alt="迭代器的分类于从属关系.png" style="zoom:67%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>traits 本质是什么？多一层间接性，换来灵活性。</p>
<p>iterator_traits 负责萃取迭代器的特性，__type_traits 负责萃取类型的特性。</p>
<p>STL的中心思想是将数据容器与算法分开，彼此独立设计。迭代器便作为连接两者的“桥梁”，统一访问不同容器时的访问方式，并将实际细节封装，不被使用者看到。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析概述</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>源代码：SGI-STL V3.3</strong></p>
</blockquote>
<p><em>注：SGI STL并不是原封不动的被用于GCC，所以在GCC中使用STL可能会和SGI STL有一些微小的区别</em></p>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ul>
<li>容器 – <strong>containers</strong></li>
<li>配置器 – <strong>allocators</strong></li>
<li>算法 – <strong>algorithms</strong></li>
<li>迭代器 – <strong>iterators</strong></li>
<li>适配器 – <strong>adaptors</strong></li>
<li>仿函数 – <strong>functors</strong></li>
</ul>
<h3 id="STL六大组件关系"><a href="#STL六大组件关系" class="headerlink" title="STL六大组件关系"></a>STL六大组件关系</h3><img src="https://i.loli.net/2020/08/04/8O6uUKpjax4o7RP.png" alt="STL六大组件.png" style="zoom: 67%;" />

<h3 id="STL部分组件包含关系"><a href="#STL部分组件包含关系" class="headerlink" title="STL部分组件包含关系"></a>STL部分组件包含关系</h3><img src="https://i.loli.net/2020/08/04/aMjYyL1ktgQx8JN.jpg" alt="STL部分组件包含关系.jpg" style="zoom: 67%;" />

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><img src="https://i.loli.net/2020/08/04/l5AoyGxt6RpfSJ9.png" alt="STL容器结构与分类图.png" style="zoom:67%;" />

<h2 id="GCC-编译器版本"><a href="#GCC-编译器版本" class="headerlink" title="GCC 编译器版本"></a>GCC 编译器版本</h2><p>Ubuntu 16.04下gcc version <kbd>5.4.0</kbd>，源码在目录<kbd>/usr/include/c++/5.4.0/bits</kbd>下 stl_xxxx</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《STL 源码剖析》 侯捷</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型中的同步&amp;异步-阻塞&amp;非阻塞</title>
    <url>/UNP/IO%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5&amp;%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E&amp;%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<p>I/O模型中：</p>
<ul>
<li><p><strong>同步&amp;异步</strong>：同步和异步关注的是<strong>消息通信机制</strong>。</p>
</li>
<li><p><strong>阻塞&amp;非阻塞</strong>：阻塞和非阻塞关注的是程序在<strong>等待调用结果时的状态</strong>。</p>
</li>
</ul>
<blockquote>
<p>张三爱喝茶，烧水泡茶。</p>
<ol>
<li>张三把水壶放火上，立等水开。（同步阻塞）</li>
<li>张三把水壶放火上，去客厅看电视，时不时去厨房看水开没有。（同步非阻塞）</li>
</ol>
<p>张三买了个智能水壶，烧开后铃声提示。</p>
<ol>
<li>张三把智能水壶放火上，立等水开。（异步阻塞）</li>
<li>张三把智能水壶放火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</li>
</ol>
<p><strong>同步&amp;异步</strong>，只是对<strong>水壶（被调用）</strong>而言。普通水壶——同步。智能水壶——异步。智能水壶能自己干完活后提示张三水开了，普通水壶智能让张三去轮询查看（造成张三效率低下）。</p>
<p><strong>阻塞&amp;非阻塞</strong>，仅仅对于<strong>老张（调用者）</strong>而言。 立等的张三——阻塞；看电视的张三——非阻塞。 </p>
<p>一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<p>从理论上说，<font color=red><strong>阻塞I/O</strong>、<strong>I/O复用</strong>以及<strong>信号驱动I/O</strong>都是<strong>同步I/O模型</strong></font>。</p>
<p><strong>异步I/O</strong>的读写操作总是<strong>立即返回</strong>，而不论I/O是否是阻塞的，因为真正读写操作已经由内核接管。</p>
<p><strong>同步I/O模型</strong>要求用户代码自行执行I/O操作，而<strong>异步I/O机制</strong>由内核来执行I/O操作。即，<strong>同步I/O</strong>向应用程序通知的是I/O就绪事件，异步I/O向应用程序通知的是<strong>I/O完成事件</strong>。</p>
<hr>
<table>
<thead>
<tr>
<th>I/O模型</th>
<th>读写操作和阻塞阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞I/O</td>
<td>程序阻塞与读写函数</td>
</tr>
<tr>
<td>I/O复用</td>
<td>程序阻塞于I/O复用系统调用，但可以同时监听多个I/O事件，对于I/O本身的读写操作是非阻塞的。</td>
</tr>
<tr>
<td>SIGIO信号</td>
<td>信号触发I/O就绪事件，用户程序执行读写操作。程序没有阻塞阶段。</td>
</tr>
<tr>
<td>异步I/O</td>
<td>内核执行读写操作并触发I/O完成事件。程序没有阻塞阶段。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Posix消息队列</title>
    <url>/UNP/Posix%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>程序示例可见参考链接：<a href="https://blog.csdn.net/zx714311728/article/details/53197196"><em>Posix消息队列_ZX714311728的博客-CSDN博客</em></a> </p>
</blockquote>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以认为是一个消息链表，消息队列是<strong>随内核持续</strong>的。队列中每个消息的属性有：</p>
<ol>
<li><p>一个无符号整数<strong>优先级</strong>（Posix）或一个长整数类型（System V）；</p>
</li>
<li><p>消息的<strong>数据部分长度</strong>（可以为0）；</p>
</li>
<li><p><strong>数据</strong>本身（如果长度大于0）。</p>
</li>
</ol>
<p>链表头含有当前队列的两个属性：</p>
<ol>
<li>队列中运行的最大消息数 <code>mq_maxmsg</code> ；</li>
<li>每个消息的最大大小 <code>mq_msgsize</code> 。</li>
</ol>
<p>消息队列的可能布局如下：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E5%90%AB%E6%9C%89%E4%B8%89%E4%B8%AA%E6%B6%88%E6%81%AF%E7%9A%84Posix%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E8%83%BD%E5%B8%83%E5%B1%80.png"></p>
<p>Posix 消息队列与System V消息队列主要区别：</p>
<ol>
<li>Posix 消息队列的读总是返回「最高优先级的最早消息」；System V 消息队列的读则可以返回任一指定优先级消息。</li>
<li>往空队列放置消息时，Posix 消息队列允许产生一个信号或启动一个线程；System V则不提供类似机制。</li>
</ol>
<p>Posix消息队列与管道或FIFO的主要区别：</p>
<ol>
<li><p>在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。对管道和FIFO来说，除非读出者已存在，否则先有写入者是没有意义的。</p>
</li>
<li><p>管道和FIFO是字节流模型，没有消息边界。消息队列则指定了数据长度，有边界。</p>
</li>
</ol>
<h2 id="mq-open-、-mq-close和-mq-unlink"><a href="#mq-open-、-mq-close和-mq-unlink" class="headerlink" title="mq_open 、  mq_close和 mq_unlink"></a>mq_open 、  mq_close和 mq_unlink</h2><blockquote>
<p>mq_xxx() 函数不是标准库函数，所以链接时需指定库，通过在最后加上 <strong><code>-lrt</code></strong> 选项来指定</p>
</blockquote>
<h3 id="mq-open"><a href="#mq-open" class="headerlink" title="mq_open"></a>mq_open</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 「创建」新消息队列或「打开」已存在的消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，<strong>消息队列描述符</strong>； 出错，-1</p>
<p>mode 和 attr 仅创建时使用</p>
<p>创建的 “文件” 存放在 <code>/dev/mqueue/</code> 下</p>
</blockquote>
<p><code>name</code> 规则：必须以一个<code>/</code> 开头，并且不能再包含任何其他斜杠符；</p>
<p><code>oflag</code> ：O_RDONLY、O_WRONLY、O_RDWR三者之一，按位或上O_CREAT、O_EXCL</p>
<p><code>mode</code> ：S_ISRUSR、S_ISWUSR、S_ISRGRP、S_ISWGRP、S_ISROTH、S_ISWOTH </p>
<p><code>attr</code> ：mq_open 只能设置 mq_maxmsg 和 mq_msgsize 属性，并且两个必须要同时设置；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mq_flags;<span class="comment">// 阻塞标志， 0或O_NONBLOCK</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg;<span class="comment">// 最大消息数</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize;<span class="comment">// 每个消息最大大小</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs;<span class="comment">// 当前消息数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mq-close和mq-unlink"><a href="#mq-close和mq-unlink" class="headerlink" title="mq_close和mq_unlink"></a>mq_close和mq_unlink</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭已打开的消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqd)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错，-1</p>
</blockquote>
<p>与 <code>close</code>  函数类似：调用进程可以不再使用该描述符，但消息队列并不从系统中删除。</p>
<p> 一个进程终止时，它的所有打开的消息队列都关闭，如同调用了mq_close。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除消息队列的name</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错，-1</p>
</blockquote>
<p>每个消息队列有一个保存其当前打开的描述符数的引用计数，只有当引用计数为0时，才删除该消息队列。当一个消息队列的引用计数仍大于0时，其 name 就能删除，但是该队列的析构（这与从系统中删除其名字不同）要等到最后一个 mq_close 发生时才进行。</p>
<h2 id="mq-getattr、-mq-setattr"><a href="#mq-getattr、-mq-setattr" class="headerlink" title="mq_getattr、  mq_setattr"></a>mq_getattr、  mq_setattr</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取、设置消息队列属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqd, struct mq_attr *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错，-1</p>
<p>mq_setattr 只能设置 mq_flags 属性；mq_getattr 返回全部4个属性。</p>
</blockquote>
<h2 id="mq-send、-mq-receive"><a href="#mq-send、-mq-receive" class="headerlink" title="mq_send、  mq_receive"></a>mq_send、  mq_receive</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往消息队列中放置一个消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从消息队列中取走一个消息</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *prio)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>mq_send</code> 中优先级 prio 要小于 <code>MQ_PRIO_MAX</code>；</li>
<li><code>mq_send</code> 的 prio 参数：<ul>
<li>为非空指针，优先级通过该指针存放；</li>
<li>为空指针，指定优先级值为 0 。</li>
</ul>
</li>
<li><code>mq_receive</code> 总是返回指定队列中 最高优先级的最早消息；</li>
<li><code>mq_receive</code> 的 len 参数值不能小于能加到所指队列中消息的最大大小（mq_msgsize）。若小于该值则立即返回 EMSGSIZE 错误。</li>
</ul>
<h2 id="消息队列限制"><a href="#消息队列限制" class="headerlink" title="消息队列限制"></a>消息队列限制</h2><ul>
<li><code>mq_maxmsg</code>：消息队列中最大消息数</li>
<li><code>mq_msgsize</code>：给定消息队列的最大字节数</li>
<li><code>MQ_OPEN_MAX</code>：一个进程能够同时拥有的打开着的消息队列的最大数目（Posix要求它至少为8）</li>
<li><code>MQ_PRIO_MAX</code>：任意消息的最大优先级值加1</li>
</ul>
<h2 id="mq-notify"><a href="#mq-notify" class="headerlink" title="mq_notify"></a>mq_notify</h2><p>Posix消息队列允许<strong>异步事件通知</strong>，以告知何时有一个消息放置到了某个空消息队列中。这种通知有两种方式可供选择：</p>
<ol>
<li>产生一个信号</li>
<li>创建一个线程来执行指定的函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为指定队列建立或删除异步事件通知</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">const</span> struct sigevent *notification)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错-1</p>
</blockquote>
<ul>
<li><code>notification</code> 参数：<ul>
<li>非空，该进程被注册为接收该消息队列的通知</li>
<li>空指针，当前进程被注册为接收该消息队列的通知，已存在的注册将被撤销</li>
</ul>
</li>
<li>对一个消息队列来说，任一时刻只有一个进程可以被注册</li>
<li>当通知被发送给注册进程时，注册即被撤销，该进程若要重新注册，则必须重新调用 mq_notify() （一次注册，接收一次）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> sigval &#123;          <span class="comment">/* Data passed with notification */</span></span><br><span class="line">    <span class="keyword">int</span> sival_int;         <span class="comment">/* Integer value */</span></span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;         <span class="comment">/* Pointer value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sigev_notify; <span class="comment">/* Notification method */</span></span><br><span class="line">    <span class="keyword">int</span> sigev_signo;  <span class="comment">/* Notification signal */</span></span><br><span class="line">    <span class="keyword">union</span> sigval sigev_value;  <span class="comment">/* Data passed with</span></span><br><span class="line"><span class="comment">                                         notification */</span></span><br><span class="line">    <span class="keyword">void</span> (*sigev_notify_function) (<span class="keyword">union</span> sigval);  <span class="comment">/* Function used for thread notification (SIGEV_THREAD) */</span></span><br><span class="line">    <span class="keyword">void</span> *sigev_notify_attributes;   <span class="comment">/* Attributes for notification thread (SIGEV_THREAD) */</span></span><br><span class="line">    <span class="keyword">pid_t</span> sigev_notify_thread_id;   <span class="comment">/* ID of thread to signal (SIGEV_THREAD_ID) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sigev_notify</code> 取值：<ul>
<li>SIGEV_NONE：事件发生时，什么也不做；</li>
<li>SIGEV_SIGNAL：事件发生时，将sigev_signo指定的信号发送给指定的进程；</li>
<li>SIGEV_THREAD：事件发生时，内核会（在此进程内）以 sigev_notify_attributes 为线程属性创建一个线程，并让其执行 sigev_notify_function，并以 sigev_value 为其参数</li>
</ul>
</li>
<li><code>sigev_signo</code>：在 sigev_notify=SIGEV_SIGNAL 时使用，指定信号类别</li>
<li><code>sigev_value</code>：sigev_notify=SIGEV_SIGEV_THREAD 时使用，作为 sigev_notify_function 的参数</li>
<li><code>sigev_notify_function</code>：在 sigev_notify=SIGEV_THREAD 时使用，其他情况下置NULL</li>
</ul>
<h2 id="Posix实时信号"><a href="#Posix实时信号" class="headerlink" title="Posix实时信号"></a>Posix实时信号</h2><p>信号可划分为两个大组：</p>
<ol>
<li>值在 SIGRTMIN（值34） 和 SIGRTMAX（值64） 之间（包括两者在内）的<strong>实时信号</strong>；</li>
<li>所有<strong>其他信号</strong>：SIGALRM、SIGINT、SIGKILL等</li>
</ol>
<p>实时信号中 “<strong>实时</strong>” 的意思是：</p>
<ol>
<li><strong>信号是排队的</strong>，是按先进先出(FIFO)顺序排队的。同一信号产生3次，则递交3次</li>
<li>当有多个 SIGRTMIN 到 SIGRTMAX 范围内的解阻塞信号排队时，值较小的信号先与较大的信号递交</li>
<li>实时信号能比非实时信号<strong>携带更多信息</strong></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>unp</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>共享内存区</title>
    <url>/UNP/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="共享内存区介绍"><a href="#共享内存区介绍" class="headerlink" title="共享内存区介绍"></a>共享内存区介绍</h2><p><strong>共享内存区</strong> 是可用IPC形式中 <strong>最快</strong> 的。一旦内存映射到共享它的进程的地址空间，这些进程间的数据传递就 <strong>不再涉及内核</strong> 。当然对共享内存区的数据的存取操作需要某种形式的同步：<a href="../Unix%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F">Unix同步方式</a>。</p>
<p>服务器-客户端文件复制程序的通常步骤如下图：</p>
<p>一组数据传递，<strong>内核空间</strong> 和 <strong>进程空间</strong> 之间的数据复制有 <strong>4次</strong> 。</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%B0%E5%AE%A2%E6%88%B7%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="从服务器到客户的文件数据流"></p>
<p>通过使用进程间共享内存区，一组数据传递，<strong>内核空间</strong> 和 <strong>进程空间</strong> 之间的数据复制有 <strong>2次</strong> 。如下图：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8C%BA%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%B0%E5%AE%A2%E6%88%B7%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="使用共享内存区从服务器到客户的文件数据流"></p>
<h2 id="映射到进程地址空间"><a href="#映射到进程地址空间" class="headerlink" title="映射到进程地址空间"></a>映射到进程地址空间</h2><p><code>mmap</code> 函数把一个 <strong>文件</strong> 或一个 <strong>Posix共享内存对象</strong> 映射到调用进程的 <strong>进程地址空间</strong> 。该函数有三个目的：</p>
<ol>
<li>使用 <strong>普通文件</strong> 以提供 <strong>内存映射I/O</strong> ；</li>
<li>使用 <strong>特殊文件</strong> 以提供 <strong>匿名内存映射</strong> ；</li>
<li>使用 <strong><code>shm_open</code></strong> 以提供 <strong>无亲缘关系进程间的Posix共享内存区</strong> 。</li>
</ol>
<p>内存映射文件的例子：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2020-xx/mmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84.png" alt="mmap文件映射"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>【<strong>注意</strong>】不是所有的文件都能进行内存映射，例如：访问终端或套接字的描述符。</p>
<ul>
<li><p><code>addr</code> ：指定映射到进程空间的 <strong>起始地址</strong> 。通常被指定为 <code>NULL</code>，由内核自己选择起始地址。</p>
</li>
<li><p><code>length</code> ：映射到调用进程地址空间中的 <strong>字节数</strong>，从 offset 偏移处开始算。</p>
</li>
<li><p><code>prot</code> ：内存映射区的保护</p>
<table>
<thead>
<tr>
<th>prot</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PROT_READ</code></td>
<td>数据可读</td>
</tr>
<tr>
<td><code>PROT_WRITE</code></td>
<td>数据可写</td>
</tr>
<tr>
<td>PROT_EXEC</td>
<td>数据可执行</td>
</tr>
<tr>
<td>PROT_NONE</td>
<td>数据不可访问</td>
</tr>
</tbody></table>
</li>
<li><p><code>flags</code> ：内存映射区属性</p>
<ul>
<li><code>MAP_PRIVATE</code> ：调用进程对映射区数据的修改仅对该进程可见，并且不改变其底层支撑对象（文件或共享内存区对象）。</li>
<li><code>MAP_SHARED</code> ：调用进程对映射区数据的修改，在所有共享该对象的所有进程都可见，并且改变同步到其底层支撑对象。</li>
<li><code>MAP_ANON</code> 或 <code>MAP_ANONYMOUS</code> ：匿名内存映射</li>
<li>MAP_FIXED ：准确的解释 addr 参数，从移植性上考虑，该参数不应该指定。</li>
</ul>
</li>
<li><p><code>fd</code> ：底层对象描述符。</p>
</li>
<li><p><code>offset</code> ：底层对象映射从 offset 偏移处开始的 length 长度的字节映射到到调用进程地址空间中。</p>
</li>
</ul>
<p>在设置了 <code>MAP_SHARED</code> 属性的前提下，修改了内存区中的数据，内核将在稍后某个时刻相应的更新底层支撑对象。如果我们期望底层支撑对象与内存映射区中的内容一致，使用 msync 来执行同步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>addr</code> 和 <code>length</code> 通常指代整个内存映射区，不过也可以指定该内存区的一个子集。</p>
</li>
<li><p><code>flags</code> ：<code>MS_ASYNC</code> 和<code>MS_SYNC</code> <strong>必须指定一个，且仅指定一个</strong>。 </p>
<table>
<thead>
<tr>
<th>flags</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>MS_ASYNC</code></td>
<td>执行异步写（立即返回）</td>
</tr>
<tr>
<td><code>MS_SYNC</code></td>
<td>执行同步写（等待写完返回）</td>
</tr>
<tr>
<td><code>MS_INVALIDATE</code></td>
<td>使高速缓存的数据失效（与最终副本不一致的都失效，后续从底层支撑中取）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="匿名内存映射"><a href="#匿名内存映射" class="headerlink" title="匿名内存映射"></a>匿名内存映射</h2><ol>
<li><ol start="4">
<li><p>4BSD提供<code>MAP_ANON</code> 或 <code>MAP_ANONYMOUS</code> ，<strong>彻底避免了文件的创建和打开</strong>。</p>
<p>把 <code>mmap</code> 的 flags 参数指定成 <code>MAP_SHARED | MAP_ANON</code> ，<code>fd = -1</code>，offset 参数将被忽略。这样内存区初始化为0.</p>
</li>
</ol>
</li>
<li><p>SVR4提供 <code>/dev/zero</code> 设备文件</p>
<p>从该设备读时返回的字节全为0，写往该设备的任何字节则被丢弃。</p>
</li>
</ol>
<h2 id="映射区内存"><a href="#映射区内存" class="headerlink" title="映射区内存"></a>映射区内存</h2><p><strong>内核的内存保护是以页面为单位的！</strong> 内核允许我们读写最后一页中映射区以外的部分，但是我们写在映射区以外这一部分的任何内容都不会同步到底层支撑（如文件）。</p>
<p>页面大小4096，mmap大小 = 文件大小（5000）：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2020-xx/mmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%8C%BA%E5%A4%A7%E5%B0%8F%E7%AD%89%E4%BA%8E%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F.png" alt="mmap文件映射区大小等于文件大小"></p>
<p>页面大小4096，mmap大小(15000) &gt; 文件大小(5000)：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/mmap%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%97%B6.png" alt="mmap大小超过文件大小时"></p>
<h2 id="Posix共享内存区"><a href="#Posix共享内存区" class="headerlink" title="Posix共享内存区"></a>Posix共享内存区</h2><p>考虑 <strong>无亲缘关系</strong> 进程间共享内存的方法：</p>
<ol>
<li><strong>内存映射文件</strong>；</li>
<li><strong>共享内存区对象</strong>。</li>
</ol>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/Posix%E5%86%85%E5%AD%98%E5%8C%BA%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8C%BA%E5%AF%B9%E8%B1%A1.png" alt="Posix内存区对象：内存映射文件和共享内存区对象"></p>
<h3 id="共享内存区对象操作"><a href="#共享内存区对象操作" class="headerlink" title="共享内存区对象操作"></a>共享内存区对象操作</h3><p><code>shm_open</code>  操作类似于文件 open ，<strong>创建</strong> 或 <strong>打开</strong> 一个<strong>共享内存区对象</strong>。<code>shm_unlink</code> 删除一个共享内存区对象的名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code> 参数指定共享内存区对象的名称，由 <code>/</code> 开头，且仅有一个斜杠组成。</li>
<li><code>shm_unlink</code> 函数类似于其他的 unlink 函数，删除一个名字不会影响对于其底层支撑对象的现有引用，直到该对象的引用全部关闭为止。（删掉名字 <strong>!=</strong> 析构清除）</li>
</ul>
<p>【<strong>注意</strong>】<strong>Posix共享内存区</strong> 具有 <strong>随内核</strong> 的持续性。</p>
<p>【<strong>疑问</strong>】Posix共享内存区，调用 <code>shm_unlink</code> 删除名称，但还未未释放时，再次 <code>shm_open</code> 会如何？</p>
<p>答：manpage 给出了说明，<code>shm_open</code> 将会失败，除非指定了 <code>O_CRAET</code> 。同时，新建的 Posix共享内存内对象 区别于已存在的。</p>
<blockquote>
<p>After a successful shm_unlink(), attempts to shm_open() an object with the same name <strong>will fail (unless O_CREAT was specified, in which case a new, distinct object is created)</strong>.</p>
</blockquote>
<h3 id="ftruncate和fstat"><a href="#ftruncate和fstat" class="headerlink" title="ftruncate和fstat"></a>ftruncate和fstat</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">// 获取属性信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li><code>ftruncate</code> 用于修改普通文件或共享内存区对象的大小。<ul>
<li>须是以<strong>写入模式</strong>打开的；</li>
<li><strong>普通文件</strong>：<ul>
<li>如果原文件大小大于 length，则额外的数据将被丢弃；如果原来的文件大小比参数length小，则文件将被扩展，与 lseek 系统调用类似，文件的扩展部分将以 ‘\0’ 填充。</li>
<li>扩展文件时，此函数并未实质性的向磁盘写入数据，只是分配了一定的空间供当前文件使用。</li>
</ul>
</li>
<li><strong>共享内存区对象</strong>：把该对象的大小设置成 length 字节。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>unp</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式(一)管道</title>
    <url>/UNP/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F(%E4%B8%80)%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p>Linux环境下，<strong>进程地址空间相互独立</strong>，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过<strong>内核</strong>，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong>（<strong>IPC</strong>，InterProcess Communication）。</p>
<h2 id="管道-pipe-（半双工）"><a href="#管道-pipe-（半双工）" class="headerlink" title="管道 pipe （半双工）"></a>管道 pipe （半双工）</h2><p>管道 （<code>pipe</code>）是一种最基本的IPC机制，作用于<strong>有血缘关系</strong>的进程之间，完成数据传递。</p>
<img src="https://i.loli.net/2020/08/16/BPgd7qliosW94VM.png" alt="pipe管道-进程通信.png" style="zoom:67%;" />

<h3 id="管道特质"><a href="#管道特质" class="headerlink" title="管道特质"></a>管道特质</h3><ol>
<li>其本质是一个<strong>伪文件</strong>（实为内核缓冲区）</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>规定数据从管道的写端流入管道，从读端流出</li>
</ol>
<h3 id="pipe的原理"><a href="#pipe的原理" class="headerlink" title="pipe的原理"></a>pipe的原理</h3><p>管道实为内核使用<strong>环形队列</strong>机制，借助内核缓冲区(4k)实现。</p>
<h3 id="pipe的局限性"><a href="#pipe的局限性" class="headerlink" title="pipe的局限性"></a>pipe的局限性</h3><p>​    ① 管道采用<strong>半双工</strong>通信方式。即数据只能在一个方向上流动。</p>
<p>​    ② 只能在有<strong>公共祖先</strong>的进程间使用管道。</p>
<p>​    ③ 数据一旦被读走，便不在管道中存在，<strong>不可反复读取</strong>。</p>
<p>​    <del>④ 数据自己读不能自己写。</del></p>
<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><p>从管道中<strong>「读数据」</strong>：</p>
<ol>
<li><p>管道中<strong>有数据</strong>：</p>
<p>read返回实际读到的字节数。</p>
</li>
<li><p>管道中<strong>无数据</strong>：</p>
<p>(1) 管道<strong>写端全部关闭</strong>（管道写端引用计数为0），read返回0 (就像读到文件结尾)。</p>
<p>(2)  管道写端<strong>没</strong>有<strong>全部关闭</strong>，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)。</p>
</li>
</ol>
<p>往管道<strong>「写数据」</strong>：</p>
<ol>
<li><p>管道<strong>读端全部关闭</strong>：</p>
<p>进程异常终止（也可使用捕捉 <strong>SIGPIPE</strong> 信号，使进程不终止，errno设置为EPIPE）。</p>
</li>
<li><p>管道读端<strong>没有全部关闭</strong>：</p>
<p>(1) 管道已满，write阻塞。</p>
<p>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</p>
</li>
</ol>
<h3 id="pipe程序示例"><a href="#pipe程序示例" class="headerlink" title="pipe程序示例"></a>pipe程序示例</h3><p>【实际步骤】</p>
<blockquote>
<p>「父进程」向「子进程」发送消息：</p>
<ol>
<li>创建管道；</li>
<li>fork；</li>
<li>父进程关闭读端 fd[0] ，子进程关闭写端 fd[1] ；</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 创建 pipe</span></span><br><span class="line">  ret = pipe(fd);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pipe create error: &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. fork</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == (pid = fork())) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error: &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 父进程关闭读端 fd[0] ，子进程关闭写端 fd[1] </span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程写管道</span></span><br><span class="line">    close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 父进程sleep，管道无数据且写端未全部关闭，子进程阻塞等待</span></span><br><span class="line">    write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str)); <span class="comment">// 写入数据</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    close(fd[<span class="number">1</span>]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123; <span class="comment">// 子进程读管道</span></span><br><span class="line">    close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">    ret =read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;  <span class="comment">// 读数据</span></span><br><span class="line">      perror(<span class="string">&quot;read error: &quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(STDOUT_FILENO, buf, ret); <span class="comment">// 输出到屏幕</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO指*<em>先进先出**</em>（first in，first out），常被称为<strong>有名管道</strong>（named pipe），以区分管道(pipe)。管道(pipe)只能用于 「有血缘关系」的进程间。<strong>使用 FIFO，不相关的进程也能交换数据</strong>。</p>
<p>FIFO是<strong>Linux基础文件类型</strong>中的一种。但，<strong>FIFO文件在磁盘上没有数据块</strong>，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行<code>read/write</code>，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">// 默认 O_CREAT | O_EXCL</span></span><br></pre></td></tr></table></figure>



<h3 id="FIFO读写性质"><a href="#FIFO读写性质" class="headerlink" title="FIFO读写性质"></a>FIFO读写性质</h3><p><strong>只有读写都存在时，才能打开FIFO</strong>。及以下情况：</p>
<ol>
<li>有进程以只写方式打开，且有进程以只读方式打开；</li>
<li>以读写方式打开。</li>
</ol>
<p>由下面程序可验证:</p>
<ul>
<li><strong>当没有写进程打开 FIFO 时读进程打开 FIFO 将阻塞</strong>；</li>
<li><strong>当所有读进程结束后，写进程将终止</strong>。</li>
</ul>
<h3 id="FIFO程序示例"><a href="#FIFO程序示例" class="headerlink" title="FIFO程序示例"></a>FIFO程序示例</h3><p>【<strong>写进程</strong>实际步骤】</p>
<blockquote>
<ol>
<li>创建 FIFO （已存在则跳过）；</li>
<li>以只写方式打开 FIFO；</li>
<li>写数据；</li>
<li>关闭 FIFO 写。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter like this: ./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 创建 FIFO （已存在则跳过）</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(argv[<span class="number">1</span>], S_IRUSR | S_IWUSR) &amp;&amp; errno != EEXIST)</span><br><span class="line">        sys_err(<span class="string">&quot;caon&#x27;t create FIFO&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 以只写方式打开 FIFO</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 写数据</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello FIFO %d\n&quot;</span>, i++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭 FIFO</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【<strong>读进程</strong>实际步骤】</p>
<blockquote>
<ol>
<li>创建 FIFO （已存在则跳过）；</li>
<li>以只读方式打开 FIFO；</li>
<li>读数据；</li>
<li>关闭 FIFO 读。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 创建 FIFO （已存在则跳过）</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(argv[<span class="number">1</span>], S_IRUSR | S_IWUSR) &amp;&amp; errno != EEXIST)</span><br><span class="line">        sys_err(<span class="string">&quot;caon&#x27;t create FIFO&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 以只读方式打开 FIFO</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 读数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">        sleep(<span class="number">3</span>);           <span class="comment">//多个读端时应增加睡眠秒数,放大效果.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭 FIFO 读</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管道和FIFO的额外属性"><a href="#管道和FIFO的额外属性" class="headerlink" title="管道和FIFO的额外属性"></a>管道和FIFO的额外属性</h2><ul>
<li><strong>O_NONBLOCK</strong> 标志对管道和FIFO的影响</li>
</ul>
<p><img src="https://i.loli.net/2020/08/19/OwERLep16s9Kgqa.png" alt="O_NONBLOCK标志对管道和FIFO的影响.png"></p>
<ul>
<li><strong>原子性</strong> 完全由所请求字节是否小于等于 <code>PIPE_BUF</code> 。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《UNIX环境高级编程：第3版》</p>
<p>《UNIX网络编程：第2卷 进程间通信》</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>unp</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>高效事件处理模式--Proactor模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F--Proactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>同步I/O模型</strong>通常用于实现<strong>Reactor模式</strong>，<strong>异步I/O模型</strong>则用于实现<strong>Proactor模式</strong>。</p>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>与 Reactor 模式不同，Proactor 模式将所有 <strong>I/O 操作</strong>都交给<strong>主线程</strong>和<strong>内核</strong>来处理， <strong>工作线程</strong>仅仅负责<strong>业务逻辑</strong>。</p>
<ul>
<li><strong>主线程</strong>：负责<strong>监听已连接文件描述符</strong>上是否有事件发生。</li>
<li><strong>内核</strong>：负责处理<strong>I/O读写</strong>操作。</li>
<li><strong>工作线程</strong>：仅负责<strong>业务逻辑</strong>。</li>
</ul>
<img src="https://i.loli.net/2020/12/17/BHf5AtxvRQsWUV1.png" alt="Proactor模式.png" style="zoom:67%;" />

<p>使用异步 I/O 模型（以 aio_read 和 aio_write为例）实现的 Proactor 模式的工作流程是：</p>
<ol>
<li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以 通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li>
</ol>
<p>主线程中的 epoll_wait 调用<strong>仅能用来检测监听（已连接）socket</strong> 上的连接请求事件，而<strong>不能用来检测连接 socket</strong> 上的读写事件。</p>
<hr>
<p>参考：《Linux高性能服务器编程》 游双</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>基本TCP套接字</title>
    <url>/UNP/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>#include &lt;sys/types.h&gt;          /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
</blockquote>
<img src="https://i.loli.net/2020/10/23/tngDJxl8XPbZmRO.png" alt="基本TCP客户-服务器程序套接字函数.png" style="zoom:67%;" />

<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><blockquote>
<p>创建一个套接字，指定通信协议类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回文件描述符    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>domain</code> ：协议族</p>
<p><code>AF_INET</code>、<code>AF_INET6</code>、AF_LOCAL、AF_ROUTE、AF_KEY</p>
<p><code>AF_XXX</code> 指<strong>地址族</strong>，<code>PF_XXX</code> 指协议族。但是在实际中，支持多个地址族的协议族从来没有实现过，且&lt;sys/socket.h&gt;中 PF_ 值总是与对应的 AF_ 值相等，因此，<strong>两者值相等，现在可看成是一个意思</strong>。</p>
</li>
<li><p><code>type</code> ：套接字类型</p>
<p><code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、SOCK_SEQPACKET、SOCK_RAW </p>
</li>
<li><p><code>protocol</code> ：某协议类型的常值，通常为0</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/10/23/2XiDWoOtZMe1rLk.png" alt="domain-type组合.png"></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote>
<p>把一个本地<strong>协议地址</strong>赋予一个套接字。</p>
<p>协议地址：<strong>ip地址 + port</strong> </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno（常见：EACCES、EADDRINUSE）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">   <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">   <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sockfd</code> ：文件描述符（套接字）</li>
<li><code>addr</code>：指向特定协议的<strong>地址结构</strong>的指针</li>
<li><code>addrlen</code> ：地址结构长度</li>
</ul>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><blockquote>
<p>做两件事：</p>
<ol>
<li>把一个未连接的<strong>主动套接字</strong>转换成<strong>被动套接字</strong>，指示内核接收指向该套接字的连接请求，<strong>CLOSED状态</strong> –&gt; <strong>LISTEN状态</strong> </li>
<li>backlog规定<strong>已完成连接队列</strong>的最大连接个数</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li><strong>未完成连接队列</strong>：正在等待完成TCP三次握手，处于 <strong>SYN_RCVD</strong> 状态</li>
<li><strong>已完成连接队列</strong>：已完成TCP三次握手，等待通过 <code>accept</code> 从队列中取出已连接套接字，处于 <strong>ESTABLISED</strong> 状态</li>
</ul>
<p>Linux 2.2 以后，backlog 表示已完成连接队列的 socket 上限。<strong>实际测试</strong>中，队列最大长度为 <font color=red><strong>backlog + 1</strong></font>。</p>
<p><strong>测试代码及数据</strong>：<a href="https://github.com/JakeLin0fly/unp-code/tree/master/listen_backlog">listen()函数backlog参数测试</a> </p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><blockquote>
<p>TCP客户端使用，用于建立与TCP服务器的连接</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><blockquote>
<p>有TCP服务器调用，从<strong>已完成连接队列</strong>队头返回一个描述符。若队列为空，进程睡眠（默认阻塞方式）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回非负描述符    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若对返回客户端协议地址不感兴趣，可把 addr、addrlen 均值为空指针。</p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><blockquote>
<p>关闭套接字，该套接字不能再被调用进程使用。并发服务器中，close调用实际是相应套接字引用计数减1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当close关闭套接字时，TCP将尝试发送<strong>已排队等待发送</strong>到对端的任何数据，发送完毕后的是正常的TCP连接终止序列（四次握手）。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>unp</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>高效并发模式--半同步/半异步模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F--%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>并发编程的目的是让程序“同时”执行多个任务。若程序是<strong>计算密集型</strong>的，并发编程并没有优势，相反由于任务的切换使得效率降低。但如果程序是<strong>I/O密集型</strong>的，比如经常读写文件，访问数据库等，则情况不同。由于I/O操作的速度远没有CPU计算的速度快，所以当程序阻塞于I/O操作将浪费大量CPU时间。</p>
<p>并发模式是指I/O处理单元和多个逻辑单元之间的协调完成任务的方法。</p>
<p><font color=red><strong>并发模式</strong>中，<strong>“同步”</strong>指的是程序完全按照代码序列的顺序执行；<strong>“异步”</strong>指的是程序的执行需要由系统事件来驱动。</font></p>
<p>以<strong>异步线程</strong>执行的程序相对复杂，难于调适和扩展，并且<strong>不适合于大量的并发</strong>。<strong>同步线程</strong>则相反，程序效率相对较低，实时性较差，但逻辑简单。</p>
<h3 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h3><p><strong>同步线程</strong>用于处理客户逻辑，相当于逻辑单元；<strong>异步线程</strong>用于处理I/O事件，相当于I/O处理单元。</p>
<img src="https://i.loli.net/2020/12/21/uP2neT3l7QIZaUF.png" alt="半同步半异步模式工作流程.png" style="zoom: 80%;" />

<h3 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步/半反应堆模式"></a>半同步/半反应堆模式</h3><blockquote>
<p><strong>half-sync / half-reactive</strong></p>
<p>事件处理模式是<strong>Reactor模式</strong>：要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。</p>
</blockquote>
<img src="https://i.loli.net/2020/12/21/gcyLzCZjOGFfid4.png" alt="半同步-半反应堆模式.png" style="zoom:80%;" />

<p><strong>主线程</strong>：<strong>异步</strong>线程。负责监听<strong>所有 socket</strong> 上的事件。</p>
<ul>
<li>当有新的连接请求到来，主线程接受连接请求得到新的连接socket，然后往epoll内核事件表中注册socket上的读写事件。</li>
<li>有新的已连接客户端请求到来或有数据要发送至客户端，主线程将该连接socket插入请求队列。</li>
</ul>
<p><strong>工作线程</strong>：<strong>同步</strong>线程。所有的工作线程都休眠在请求队列上，当有任务到来，它们通过竞争获得任务的接管权。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>主线程和工作线程共享请求队列：主线程添加任务，工作线程取出任务，都需要对请求队列加锁保护，耗费CPU时间。</li>
<li>每个工作线程在同一时间只能处理一个客户请求：若客户较多，工作线程较少，则请求队列中任务堆积，客户端响应慢。若增加工作线程，线程切换耗费大量CPU时间。</li>
</ul>
<h3 id="相对高效的半同步-半异步模式"><a href="#相对高效的半同步-半异步模式" class="headerlink" title="相对高效的半同步/半异步模式"></a>相对高效的半同步/半异步模式</h3><blockquote>
<p>每个线程都是<strong>异步线程</strong>，故并非严格意义上的半同步/半异步模式。</p>
</blockquote>
<img src="https://i.loli.net/2020/12/21/i6BpGWfeAcVD4YU.png" alt="高效的半同步-半异步模式.png" style="zoom:80%;" />

<p><strong>主线程</strong>：<strong>异步</strong>线程。<strong>只</strong>负责管理<strong>监听socket（listen_socket）</strong>。当有新的连接请求到来，主线程接受连接请求得到新的连接socket，并将新返回的连接socket派发给某个工作线程。</p>
<p><strong>工作线程</strong>：<strong>异步</strong>线程。负责管理<strong>请求socket（connected_socket）</strong>。主线程向工作线程派发新的连接socket后，工作线程负责该socket的任何I/O操作，直到客户端关闭。</p>
<hr>
<p>参考：《Linux高性能服务器编程》 游双</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>高效事件处理模式--Reactor模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F--Reactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>同步I/O模型</strong>通常用于实现<strong>Reactor模式</strong>，<strong>异步I/O模型</strong>则用于实现<strong>Proactor模式</strong>。</p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><ul>
<li><strong>主线程（I/O处理单元）</strong>：只负责<strong>监听文件描述符</strong>上是否有事件发生，有的话以及将该事件通知工作线程。</li>
<li><strong>工作线程（逻辑单元）</strong>：<strong>读写数据</strong>，<strong>接受新的连接</strong>，<strong>处理用户请求</strong>均在工作线程中完成。</li>
</ul>
<img src="https://i.loli.net/2020/12/17/4QTMAk8369fYsDv.png" alt="Reactor模式.png" style="zoom:67%;" />

<p>使用同步 I/O 模型（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</p>
<ol>
<li>主线程往 epoll 内核事件表中注册 socket 上的<strong>读就绪事件</strong>。</li>
<li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li>
<li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的<strong>写就绪事件</strong>。</li>
<li>主线程调用 epoll_wait 等待 socket 可写。</li>
<li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作进程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li>
</ol>
<hr>
<p>参考：《Linux高性能服务器编程》 游双</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>高效并发模式--领导者/追随者模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F--%E9%A2%86%E5%AF%BC%E8%80%85%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>并发模式是指I/O处理单元和多个逻辑单元之间的协调完成任务的方法。</p>
<p><font color=red><strong>并发模式</strong>中，<strong>“同步”</strong>指的是程序完全按照代码序列的顺序执行；<strong>“异步”</strong>指的是程序的执行需要由系统事件来驱动。</font></p>
<h3 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者/追随者模式"></a>领导者/追随者模式</h3><p>领导者/追随者模式是<strong>多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式</strong>。</p>
<p><strong>领导者线程</strong>：在任意时间点，程序都仅有一个领导者线程。负责监听I/O事件。</p>
<p><strong>追随者线程</strong>：当前时间点，除领导者线程之外的所有线程都是追随者，都休眠在线程池中等待成为新的领导者。</p>
<p>当前的领导者如果检测到I/O事件：</p>
<ol>
<li>从线程池中推线新的领导者；</li>
<li>旧的领导者去处理I/O事件；</li>
<li>新的领导者等待新的I/O事件。</li>
</ol>
<img src="https://i.loli.net/2020/12/22/5NeaoEdxAW4THrX.png" alt="领导者-追随者模式.png" style="zoom:80%;" />

<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><img src="https://i.loli.net/2020/12/22/JFtIr9V6qHRlj2E.png" alt="领导者-追随者模式的组件.png" style="zoom:80%;" />

<ul>
<li><p><strong>句柄集（HandleSet）</strong></p>
<p>句柄（Handle）用于表示<strong>I/O资源</strong>，Linux下通常是文件描述符。句柄集管理从多句柄。</p>
<ul>
<li><code>wait_for_event()</code>：监听句柄集中的所有句柄的I/O事件，并将就绪事件通知给领导者进程。</li>
<li><code>register_handle()</code>：绑定句柄和事件处理器。</li>
<li><code>unregister_handle()</code>：解绑句柄和事件处理器。</li>
</ul>
</li>
<li><p><strong>线程集（ThreadSet）</strong></p>
<p><strong>所有工作线程</strong>，包括领导者线程和追随者线程。线程集主要负责<strong>线程之间的同步</strong>，以及<strong>推选新的领导者</strong>。线程状态包括：</p>
<img src="https://i.loli.net/2020/12/22/erUN2d16DGFc9Tg.png" alt="领导者-追随者模式的状态转移.png" style="zoom: 80%;" />

<ul>
<li>Leader：领导者身份，等待句柄集上的I/O事件。当检测到新的I/O事件，可以推选新的领导者，本线程转为Processing处理事件，也可能指定其他追溯者来处理事件；</li>
<li>Processing：正在处理事件；</li>
<li>Follower：追随者身份，等待成为新的领导者，也可能被当前领导者指定来处理新的任务。</li>
</ul>
</li>
<li><p><strong>事件处理器（EventHandler）和具体事件处理器（ConcreteEventHandler）</strong></p>
<p>事件处理器通常包含一个或多个回调函数<code>handle_event</code>。这些回调函数用于处理事件对应的业务逻辑。</p>
</li>
</ul>
<h4 id="优势-amp-缺陷"><a href="#优势-amp-缺陷" class="headerlink" title="优势&amp;缺陷"></a>优势&amp;缺陷</h4><p>优势：</p>
<ol>
<li>不需要在线程之间传递任何额外的数据（领导者自己监听I/O事件并处理请求）；</li>
<li>线程之间无须同步队请求队列的访问（对比半同步/半反应堆模式）。</li>
</ol>
<p>缺陷：</p>
<ol>
<li>仅支持一个事件源集合</li>
<li>无法让每个工作线程独立地管理多个客户连接</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos扩容</title>
    <url>/doc/Centos%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p>CVM存储在 <code>/var</code> 下，虽然固态硬盘大部分存储空间，都给了 <code>/var</code> ，但是虚拟机多一点，就担心空间不足。于是便通过以下步骤对 <code>/var</code> 进行扩容。</p>
<p>更新–查看磁盘分区情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lsblk</span><br><span class="line">NAME              MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0 447.1G  0 disk </span><br><span class="line">├─sda1              8:1    0    50M  0 part /boot/efi</span><br><span class="line">├─sda2              8:2    0     1G  0 part /boot</span><br><span class="line">└─sda3              8:3    0 446.1G  0 part </span><br><span class="line">  ├─centos00-root 253:0    0    80G  0 lvm  /</span><br><span class="line">  ├─centos00-swap 253:1    0    64G  0 lvm  [SWAP]</span><br><span class="line">  └─centos00-var  253:2    0 742.1G  0 lvm  /var</span><br><span class="line">sdb                 8:16   0 447.1G  0 disk </span><br><span class="line">└─centos00-var    253:2    0 742.1G  0 lvm  /var</span><br><span class="line">sdc                 8:32   0 447.1G  0 disk</span><br></pre></td></tr></table></figure>



<ol>
<li><p>查看分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -hT</span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root xfs        40G  3.9G   37G  10% /</span><br><span class="line">devtmpfs                devtmpfs   12G     0   12G   0% /dev</span><br><span class="line">tmpfs                   tmpfs      12G     0   12G   0% /dev/shm</span><br><span class="line">tmpfs                   tmpfs      12G   33M   12G   1% /run</span><br><span class="line">tmpfs                   tmpfs      12G     0   12G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdc2               xfs       497M  155M  343M  32% /boot</span><br><span class="line">/dev/sdc1               vfat       50M   12M   39M  23% /boot/efi</span><br><span class="line">/dev/mapper/centos-var  xfs       375G  254G  121G  68% /var  # 大小 375G</span><br><span class="line">tmpfs                   tmpfs     2.4G     0  2.4G   0% /run/user/0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看磁盘编号</p>
<p>也可以使用 <code>fdisk -l</code> 查看磁盘信息。其中 <code>/dev/sdb</code> 是用于扩容的磁盘。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls /dev/sd*</span><br><span class="line">/dev/sda  /dev/sdb  /dev/sdc  /dev/sdc1  /dev/sdc2  /dev/sdc3</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建pv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate /dev/sdb </span><br><span class="line">  Physical volume &quot;/dev/sdb&quot; successfully created.</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看vg组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize    VFree</span><br><span class="line">  centos   1   3   0 wz--n- &lt;446.59g    0    # 此时vfree为0</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展vg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgextend centos /dev/sdb </span><br><span class="line">  Volume group &quot;centos&quot; successfully extended</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次查看vg组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize  VFree  </span><br><span class="line">  centos   2   3   0 wz--n- &lt;1.35t 931.51g     # 此时vfree为 931.51g</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展lv（+500G）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvextend -L +500G /dev/mapper/centos-var </span><br><span class="line">  Size of logical volume centos/var changed from &lt;374.59 GiB (95895 extents) to &lt;874.59 GiB (223895 extents).</span><br><span class="line">  Logical volume centos/var successfully resized.</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统重新读取大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# xfs_growfs /dev/mapper/centos-var </span><br><span class="line">meta-data=/dev/mapper/centos-var isize=256    agcount=4, agsize=24549120 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=98196480, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line">log      =internal               bsize=4096   blocks=47947, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 98196480 to 229268480</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看扩容是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   40G  3.9G   37G  10% /</span><br><span class="line">devtmpfs                  12G     0   12G   0% /dev</span><br><span class="line">tmpfs                     12G     0   12G   0% /dev/shm</span><br><span class="line">tmpfs                     12G   33M   12G   1% /run</span><br><span class="line">tmpfs                     12G     0   12G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdc2                497M  155M  343M  32% /boot</span><br><span class="line">/dev/sdc1                 50M   12M   39M  23% /boot/efi</span><br><span class="line">/dev/mapper/centos-var   875G  254G  621G  30% /var        # 大小 375G + 500G = 875G</span><br><span class="line">tmpfs                    2.4G     0  2.4G   0% /run/user/0</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown学习总结笔记</title>
    <url>/doc/Markdown%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF等多种格式的文档。<br>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>Typora 官网：<a href="https://typora.io/">https://typora.io/</a><br>吐槽点：换行会自动加入空行，难受…</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>标题使用<kbd>#</kbd>表示，可分为1-6级标题，几级标题使用几个<kbd>#</kbd>，并以空格分隔标题名，如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文本格式"><a href="#2-文本格式" class="headerlink" title="2. 文本格式"></a>2. 文本格式</h2><h3 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2.1  字体"></a>2.1  字体</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_粗斜体文本<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-分隔线"><a href="#2-2-分隔线" class="headerlink" title="2.2 分隔线"></a>2.2 分隔线</h3><p>使用三个及以上<kbd>*</kbd>、<kbd>-</kbd>可建立分隔线，字符间不许其他符号，格式如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span></span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h3><p>若要对文本内容添加删除线，如<del>删除线内容</del>，只需要在文字的两端加上两个波浪线 <kbd>~~</kbd> 即可格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线内容~~</span><br></pre></td></tr></table></figure>

<h3 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h3><p>下划线通过HTML标签<kbd>&lt;u&gt;</kbd>实现，如下</p>
<p><u>下划线文本</u></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-脚注"><a href="#2-5-脚注" class="headerlink" title="2.5 脚注"></a>2.5 脚注</h3><p>脚注是对文本内容的补充说明，样式如下：<br>文本内容文本内容[^Markdown]。<br>[^Markdown]: Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">文本内容文本内容[^Markdown]。</span><br><span class="line">[<span class="symbol">^Markdown</span>]: <span class="link">Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-列表格式"><a href="#3-列表格式" class="headerlink" title="3. 列表格式"></a>3. 列表格式</h2><p>Markdown中列表可分为无序列表和有序列表。<br><strong>无序列表</strong>：使用<kbd>* </kbd>、<kbd>+ </kbd> 、<kbd>- </kbd>作为标记符。样式如下：</p>
<ul>
<li>*第一项</li>
<li>*第二项</li>
</ul>
<ul>
<li>-第一项</li>
<li>-第二项</li>
</ul>
<ul>
<li>+第一项</li>
<li>+第二项</li>
</ul>
<p>markdown书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> <span class="emphasis">*第一项</span></span><br><span class="line"><span class="emphasis">*</span> <span class="emphasis">*第二项</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- -第一项</span></span><br><span class="line"><span class="emphasis">- -第二项</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">+ +第一项</span></span><br><span class="line"><span class="emphasis">+ +第二项</span></span><br></pre></td></tr></table></figure>

<p><strong>有序列表</strong>：有序列表使用数字并加上<kbd>. </kbd>来表示，样式如下：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<p>书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure>

<p><strong>列表嵌套</strong>：多层列表嵌套，子列表添加一个<kbd>tab</kbd>或者四个空格缩进即可，样式如下：</p>
<ol>
<li>第一项<ul>
<li>第一项嵌套（可有序）</li>
<li>第二项嵌套（可有序）</li>
</ul>
</li>
<li>第二项</li>
</ol>
<p>书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">   *</span> 第一项嵌套（可有序）</span><br><span class="line"><span class="bullet">   *</span> 第二项嵌套（可有序）</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure>

<h2 id="4-区块"><a href="#4-区块" class="headerlink" title="4. 区块"></a>4. 区块</h2><p>Markdown 区块引用是在段落开头使用 <kbd>></kbd> 符号 ，然后后面紧跟一个<strong>空格</strong>符号。样式如下：</p>
<blockquote>
<p>Markdown区块演示<br>Markdown区块演示</p>
</blockquote>
<p>书写格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Markdown区块演示</span><br><span class="line">&gt; Markdown区块演示</span><br></pre></td></tr></table></figure>

<p>区块可嵌套使用，如下：</p>
<blockquote>
<p>外层区块</p>
<blockquote>
<p>内层区块</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 外层区块</span><br><span class="line">&gt; &gt; 内层区块</span><br></pre></td></tr></table></figure>

<h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h2><p>段落上的函数或代码片段可用反引号<kbd>`</kbd>包起来，如：</p>
<p><code>cout</code><br><code>cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;cout&#96;</span><br><span class="line">&#96;cout &lt;&lt; &quot;ans &#x3D; &quot; &lt;&lt; ans &lt;&lt; endl;&#96;</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong>使用<kbd>```</kbd><strong>独占一行</strong>包起来，代码高亮设置可加上语言标记前如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```markdown</span></span><br><span class="line"><span class="code">Markdown代码块</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6. 链接"></a>6. 链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]() 格式:</span><br><span class="line">[Google](www.google.com)</span><br><span class="line"></span><br><span class="line">&lt;&gt; 格式:</span><br><span class="line">&lt;www.google.com&gt;</span><br><span class="line"></span><br><span class="line">变量替代格式：</span><br><span class="line">[Google][google-link]</span><br><span class="line">[google-link]:www.google.com</span><br></pre></td></tr></table></figure>
<p><a href=""></a> 格式:<br><a href="www.google.com">Google</a></p>
<p>&lt;&gt; 格式:<br>&lt;<a href="http://www.google.com&gt;/">www.google.com&gt;</a></p>
<p>变量替代格式：<br>[Google][google-link]<br>[google-link]:<a href="http://www.google.com/">www.google.com</a></p>
<h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7. 图片"></a>7. 图片</h2><p>Markdown中图片以<kbd>![图片标签 属性](图片地址)</kbd>格式或以<kbd>&lt;img src="图片地址" 属性&gt;</kbd>书写。图片地址可分为：</p>
<ol>
<li><p>绝对地址，即一个完整的链接，可以是本地文件目录绝对地址，也可以是网络图片链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>](<span class="link">绝对地址</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;绝对地址&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相对地址，相对地址建议使用Linux地址格式，Windows格式的地址是以<kbd>\</kbd>分隔文件目录，使用这种地址格式在<strong>git上无法显示</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>](<span class="link">相对地址</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;相对地址&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>地址变量，不在图片出直接填写图片地址，通过变量，在文档结尾统一给出变量值。如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>][<span class="symbol">picture-link</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">picture-link</span>]:<span class="link">图片地址</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h2><p>Markdown使用<kbd>|</kbd>分隔不同的单元格，使用<kbd>-</kbd>分隔表头，该两种符号两侧至少一个空格（最左或最右除外）。<br>对齐方式：</p>
<ul>
<li><kbd>:-</kbd>代表左对齐</li>
<li><kbd>:-:</kbd>代表居中对齐</li>
<li><kbd>-:</kbd>代表右对齐</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中对齐 | 右对齐 |</span><br><span class="line">| :--- | :----: | ----: |</span><br><span class="line">| aaaa | bbbbbb | ccccc |</span><br><span class="line">| a    | b      | c     |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aaaa</td>
<td align="center">bbbbbb</td>
<td align="right">ccccc</td>
</tr>
<tr>
<td align="left">a</td>
<td align="center">b</td>
<td align="right">c</td>
</tr>
</tbody></table>
<h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h2><p>支持HTML元素，不在Markdown 涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。<br>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p>
<p>此外，Markdown还支持数学公式，画流程图、时序图、甘特图等。</p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx服务器安装配置</title>
    <url>/doc/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>环境：</strong></p>
<blockquote>
<p>Linux CentOS 7</p>
<p>3.10.0-1062.9.1.el7.x86_64</p>
</blockquote>
<p><font color=red><strong><em>强调：server{} 包含在http{}内部，每一个server{}都是一个虚拟主机（站点）！！！</em></strong></font></p>
<h2 id="Nginx服务器安装配置"><a href="#Nginx服务器安装配置" class="headerlink" title="Nginx服务器安装配置"></a>Nginx服务器安装配置</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install pcre* -y</span><br><span class="line">yum install openssl* -y</span><br></pre></td></tr></table></figure>

<h3 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h3><ol>
<li><p>Nginx下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf nginx-1.19.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查配置文件是否生效</p>
<p>进入解压目录，根据提示安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Nginx服务器配置"><a href="#Nginx服务器配置" class="headerlink" title="Nginx服务器配置"></a>Nginx服务器配置</h2><h3 id="nginx命令添加"><a href="#nginx命令添加" class="headerlink" title="nginx命令添加"></a>nginx命令添加</h3><p>创建软连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;bin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<h3 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h3><p>启动nginx服务器，查看进程状态，通过ip访问测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx # 启动nginx服务器</span><br><span class="line"></span><br><span class="line">ps -aux|grep nginx # 查看nginx进程</span><br></pre></td></tr></table></figure>

<h3 id="配置服务器主配置文件"><a href="#配置服务器主配置文件" class="headerlink" title="配置服务器主配置文件"></a>配置服务器主配置文件</h3><blockquote>
<p>vi /usr/local/nginx/conf/nginx.conf</p>
</blockquote>
<ol>
<li><p>文件第一行添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user    root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除<strong>server部分</strong></p>
</li>
<li><p>在http括号内添加一行</p>
<p><strong>这是自定义nginx sever配置文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">include /root/nginx/*.conf;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自定义服务器配置"><a href="#自定义服务器配置" class="headerlink" title="自定义服务器配置"></a>自定义服务器配置</h3><p>编辑自定义nginx sever配置文件</p>
<blockquote>
<p>vim /root/nginx/nginx-server.conf</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; <span class="comment">#监听IP端口 </span></span><br><span class="line">    server_name localhost; <span class="comment">#主机名</span></span><br><span class="line">    location /&#123;</span><br><span class="line">        root /root/nginx/html;</span><br><span class="line">        index  index.html index.htm; <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查配置文件"><a href="#检查配置文件" class="headerlink" title="检查配置文件"></a>检查配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>提示如下：成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master nginx]# nginx -t</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<h3 id="重启服务器"><a href="#重启服务器" class="headerlink" title="重启服务器"></a>重启服务器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload </span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在配置文件中的根目录创建 index.html，随便输几个字母（eg: Nginx test…），保存退出。浏览器访问测试。</p>
<blockquote>
<p>vim /root/nginx/html/index.html</p>
</blockquote>
<h2 id="Nginx配置文件注释"><a href="#Nginx配置文件注释" class="headerlink" title="Nginx配置文件注释"></a>Nginx配置文件注释</h2><h3 id="Nginx主配置"><a href="#Nginx主配置" class="headerlink" title="Nginx主配置"></a>Nginx主配置</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-Nginx主配置文件</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody; </span></span><br><span class="line">user    root</span><br><span class="line"><span class="comment">#开启进程数 &lt;=CPU数 </span></span><br><span class="line">worker_processes 1; </span><br><span class="line">  </span><br><span class="line"><span class="comment">#错误日志保存位置 </span></span><br><span class="line"><span class="comment">#error_log logs/error.log; </span></span><br><span class="line"><span class="comment">#error_log logs/error.log notice; </span></span><br><span class="line"><span class="comment">#error_log logs/error.log info; </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#进程号保存文件 </span></span><br><span class="line"><span class="comment">#pid logs/nginx.pid; </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#等待事件 </span></span><br><span class="line">events &#123; </span><br><span class="line">  <span class="comment">#每个进程最大连接数（最大连接=连接数x进程数）  </span></span><br><span class="line">  worker_connections 1024; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http &#123; </span><br><span class="line">  <span class="comment">#文件扩展名与文件类型映射表 </span></span><br><span class="line">  include mime.types;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">#默认文件类型 </span></span><br><span class="line">  default_type application/octet-stream; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#日志文件输出格式 这个位置相于全局设置 </span></span><br><span class="line">  <span class="comment">#log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; </span></span><br><span class="line">  <span class="comment"># &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; </span></span><br><span class="line">  <span class="comment"># &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#请求日志保存位置 </span></span><br><span class="line">  <span class="comment">#access_log logs/access.log main; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#打开发送文件 </span></span><br><span class="line">  sendfile on; </span><br><span class="line">  <span class="comment">#tcp_nopush on; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#连接超时时间 </span></span><br><span class="line">  <span class="comment">#keepalive_timeout 0; </span></span><br><span class="line">  keepalive_timeout 65; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#打开gzip压缩 </span></span><br><span class="line">  <span class="comment">#gzip on; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#设定请求缓冲 </span></span><br><span class="line">  client_header_buffer_size 1k; </span><br><span class="line">  large_client_header_buffers 4 4k; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#设定负载均衡的服务器列表 </span></span><br><span class="line">  upstream tomcat-servers &#123;</span><br><span class="line">    <span class="comment">#weigth参数表示权值，权值越高被分配到的几率越大 </span></span><br><span class="line">    <span class="comment">#max_fails 当有#max_fails个请求失败，就表示后端的服务器不可用，默认为1，将其设置为0可以关闭检查 </span></span><br><span class="line">    <span class="comment">#fail_timeout 在以后的#fail_timeout时间内nginx不会再把请求发往已检查出标记为不可用的服务器 </span></span><br><span class="line">    <span class="comment">#这里指定多个源服务器，ip:端口,80端口的话可写可不写 </span></span><br><span class="line">    server 127.0.0.1:8080 weight=5 max_fails=2 fail_timeout=600s; </span><br><span class="line">    <span class="comment">#server 127.0.0.2:8080 weight=3 max_fails=2 fail_timeout=600s;  </span></span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">    include /root/nginx/*conf;    <span class="comment"># 添加自定义的配置文件！！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="Nginx虚拟主机配置"><a href="#Nginx虚拟主机配置" class="headerlink" title="Nginx虚拟主机配置"></a>Nginx虚拟主机配置</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-Nginx自定义虚拟主机配置</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;  //监听端口为80，可以自定义其他端口，也可以加上IP地址，如，listen 127.0.0.1:8080;</span><br><span class="line">    server_name  localhost; //定义网站域名，可以写多个，用空格分隔</span><br><span class="line">    <span class="comment">#charset koi8-r; //定义网站的字符集，一般不设置，而是在网页代码中设置</span></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main; //定义访问日志，相当于局部变量 ,可以针对每一个server（即每一个站点）设置它们自己的访问日志</span></span><br><span class="line">    <span class="comment">##在server&#123;&#125;里有很多location配置段</span></span><br><span class="line">    <span class="comment">#对本server&quot;/&quot;启用负载均衡</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;  //定义网站根目录，目录可以是相对路径也可以是绝对路径</span><br><span class="line">        index  index.html index.htm; <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#以下是一些反向代理的配置可删除. </span></span><br><span class="line">        <span class="comment"># proxy_redirect off;  </span></span><br><span class="line">        <span class="comment"># proxy_set_header Host $host;  </span></span><br><span class="line">        <span class="comment"># proxy_set_header X-Real-IP $remote_addr;  </span></span><br><span class="line">        <span class="comment"># proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span></span><br><span class="line">        <span class="comment"># client_max_body_size 10m; #允许客户端请求的最大单文件字节数  </span></span><br><span class="line">        <span class="comment"># client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，  </span></span><br><span class="line">        <span class="comment"># proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)  </span></span><br><span class="line">        <span class="comment"># proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)  </span></span><br><span class="line">        <span class="comment"># proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)  </span></span><br><span class="line">        <span class="comment"># proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小  </span></span><br><span class="line">        <span class="comment"># proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置  </span></span><br><span class="line">        <span class="comment"># proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）  </span></span><br><span class="line">        <span class="comment"># proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设定查看Nginx状态的地址  </span></span><br><span class="line">    location /NginxStatus &#123;  </span><br><span class="line">        stub_status on;  </span><br><span class="line">        access_log off;  </span><br><span class="line">        <span class="comment">#allow 192.168.1.88; </span></span><br><span class="line">        <span class="comment">#deny all; </span></span><br><span class="line">        <span class="comment">#auth_basic &quot;NginxStatus&quot;;  </span></span><br><span class="line">        <span class="comment">#auth_basic_user_file conf/htpasswd;  </span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#error_page  404              /404.html;  //定义404页面</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;  //当状态码为500、502、503、504时，则访问50x.html</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;  //定义50x.html所在路径</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#定义访问php脚本时，将会执行本location&#123;&#125;部分指令</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;  //proxy_pass后面指定要访问的url链接，用proxy_pass实现代理。</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;  //定义FastCGI服务器监听端口与地址，支持两种形式，1 IP:Port， 2 unix:/path/to/sockt</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;  //定义SCRIPT_FILENAME变量，后面的路径/scripts为上面的root指定的目录</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params; //引用prefix/conf/fastcgi_params文件，该文件定义了fastcgi相关的变量</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;   //访问的url中，以/.ht开头的，如，www.example.com/.htaccess，会被拒绝，返回403状态码。</span></span><br><span class="line">    <span class="comment">#    deny  all;  //这里的all指的是所有的请求。</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="SSL配置"><a href="#SSL配置" class="headerlink" title="SSL配置"></a>SSL配置</h2><p>Nginx 默认安装的情况下<code>ssl模块</code>并未被安装，如果要使用该模块则需要在编译nginx时指定<code>with-http_ssl_module</code>参数。</p>
<ol>
<li><p>查看ngixn版本极其编译参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入nginx源码目录</p>
</li>
<li><p>重新编译模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>make</code>  <strong><em>全完别 make install 覆盖安装</em></strong></p>
</li>
<li><p>备份旧的nginx程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>将刚刚编译好的nginx覆盖掉原有的nginx（这个时候nginx要停止状态 — <code>kill 9</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看模块安装结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># or</span></span></span><br><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查配置&amp;启动nginx</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhoulifeng/p/10236116.html">nginx服务器搭建以及配置</a></p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Nginx</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Theme-Butterfly(一) 快速开始</title>
    <url>/hexo/Hexo-Theme-Butterfly(%E4%B8%80)-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<blockquote>
<p>感谢原作者 <a href="https://jerryc.me/">JerryC</a> 。</p>
<p>由于主题更新，此文件中部分配置可能失效。请参考作者博客或文档：<a href="https://demo.jerryc.me/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a> 。</p>
</blockquote>
<h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><p>在hexo博客根目录克隆Butterfly主题到 <code>themes</code> 文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>

<h1 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h1><p>修改博客更目录配置文件 <code>_config.yml</code> ，将主题改为 <code>butterfly</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>

<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pug 以及 stylus 的渲染器</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install cheerio@0.22.0 --save</span><br></pre></td></tr></table></figure>

<h1 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h1><p>为了减少升级主题后带来的不便，<code>Butterfly</code> 使用了 <a href="https://hexo.io/docs/data-files.html">data files</a> 特性。推荐把主题默认的配置文件 <code>_config.yml</code> 复製到 Hexo 根目录下的 <code>source/_data/</code> 目录下，然后将文件名改为 <code>butterfly.yml</code>（如果 <code>source/_data/</code> 的目录不存在就创建一个）。</p>
<blockquote>
<p>升级：在主题目录下 <code>git pull</code></p>
</blockquote>
<p><strong><em>注意</em></strong>：<em>由于主题在添加功能或者修復 Bugs 的情况下，可能会涉及到配置文件的修改。这时候，如果升级主题，需要把新增加的配置添加到 <code>butterfly.yml</code> 去，不然很大机会会出现报错。</em></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Theme-Butterfly(三) 主题配置</title>
    <url>/hexo/Hexo-Theme-Butterfly(%E4%B8%89)-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>感谢原作者 <a href="https://jerryc.me/">JerryC</a> </p>
<p>由于主题更新，此文件中部分配置可能失效。请参考作者博客或文档：<a href="https://demo.jerryc.me/posts/4aa8abbe/">Butterfly 安裝文档(三) 主题配置-1</a>  <a href="https://demo.jerryc.me/posts/ceeb73f/">Butterfly 安装文档(四) 主题配置-2</a></p>
</blockquote>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>修改配置文件 <code>_config.yml</code> ，主题支持三种语言</p>
<ul>
<li>default(en)</li>
<li>zh-CN (简体中文)</li>
<li>zh-TW (繁体中文)</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><p>修改配置文件 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">jakelin&#x27;s</span> <span class="string">blogs</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">jakelin&#x27;s</span> <span class="string">blogs</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">一个记录分享学习、生活的地方</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">jakelin</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">email:</span></span><br></pre></td></tr></table></figure>

<h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h2><p>配置 <code>butterfly.yml</code> ，必须是 <code>/xxx/</code> 后面 <code>||</code> 分开，然后为图标名。<strong>可自行定义！</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">清单||fa</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">音乐</span> <span class="string">||</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">照片</span> <span class="string">||</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-picture-o</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">电影</span> <span class="string">||</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-film</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/messageboard/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code Blocks (代码相关)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">pale</span> <span class="string">night</span> <span class="comment"># Butterfly 支持 6 种代码高亮样式：default / darker / pale night / light / ocean / mac</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 代码是否启用复制功能</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># show the code language</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true:代码框不展开，需点击 &#x27;&gt;&#x27; 打开 false:展开 none:不显示&#x27;&gt;&#x27;按钮，代码块展开</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span> <span class="comment"># 代码自动换行</span></span><br></pre></td></tr></table></figure>

<h2 id="社交图片"><a href="#社交图片" class="headerlink" title="社交图片"></a>社交图片</h2><p>Butterfly 支持 <a href="https://fontawesome.com/icons?from=io"><strong>font-awesome v5</strong></a> 图标。书写格式 图标名： <code>url || 描述性文字</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># social settings (社交图标设置)</span></span><br><span class="line"><span class="comment"># formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/username</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:emailname@email.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure>

<h2 id="主页文章节选-自动节选和文章页-description"><a href="#主页文章节选-自动节选和文章页-description" class="headerlink" title="主页文章节选 (自动节选和文章页 description)"></a>主页文章节选 (自动节选和文章页 description)</h2><p>在 butterfly 里，有三种可供选择:</p>
<ol>
<li>description  只显示 description</li>
<li>both  优先选择 description，如果没有配置 description，则显示自动节选的内容</li>
<li>auto_excerpt  只显示自动节选</li>
</ol>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">300</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure>

<h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p>顶部图有 2 种配置：具体 url 和（留空，true 和 false，三个效果一样）#</p>
<h3 id="Page页"><a href="#Page页" class="headerlink" title="Page页"></a>Page页</h3><ul>
<li><p>当具体 <strong>url</strong> 时</p>
<p>主页的顶部图可以在 <code>Butterfly.yml</code> 设置 <code>index_img</code></p>
<p>archives 页的顶部图可以在 <code>Butterfly.yml</code> 设置 <code>archive_img</code></p>
<p>其他 <code>page</code> 页的顶部图可以在各自的 md 页面设置 <code>front-matter</code> 中的 <code>top_img</code></p>
<blockquote>
<p>页面如果没有设置各自的 top_img，则会显示 default_top_img 图片</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>当顶部图留空，<code>true</code> 和 <code>false</code></p>
<p>主页会显示纯颜色的顶部图</p>
<p>其他 page 的顶部图没有设置时，也会显示纯颜色的顶部图</p>
</li>
</ul>
<h3 id="Post页"><a href="#Post页" class="headerlink" title="Post页"></a>Post页</h3><p>post 页的顶部图会优先显示各自 front-matter 中的 <code>top_img</code>, </p>
<p>如果没有设置，则会缩略图（即各自 front-matter 中的 <code>cover</code>)，</p>
<p>如果没有则会显示 <code>default_top_img</code> 图片</p>
<h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>要为文章置顶，需要安装插件 (<a href="https://github.com/netcan/hexo-generator-index-pin-top"><strong>hexo-generator-index-pin-top</strong></a> 或者 <a href="https://github.com/hexo-next/hexo-generator-indexed"><strong>hexo-generator-indexed</strong></a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-indexed --save # 实测成功</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">npm install hexo-generator-index-pin-top  --save # 未成功</span><br></pre></td></tr></table></figure>



<p>如果使用 <code>hexo-generator-index-pin-top</code>, 需要先卸载掉 <code>hexo-generator-index</code>，然后在文章的 <code>front-matter</code> 区域里添加 <code>top: true</code> 属性来把这篇文章置顶</p>
<p>如果使用 <code>hexo-generator-indexed</code>, 需要先卸载掉 <code>hexo-generator-index</code>，然后在文章的 <code>front-matter</code> 区域里添加 <code>sticky: 1</code> 属性来把这篇文章置顶。数值越大，置顶的优先级越大</p>
<h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h2><p>文章的 markdown 文档上，在 <code>Front-matter</code> 添加 <code>cover</code>, 并填上要显示的图片地址</p>
<p>如果不配置 cover, 可以设置显示默认的 cover</p>
<p>如果不想在首页显示 cover, 可以设置为 <code>false</code></p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br></pre></td></tr></table></figure>

<p>当配置多张图片时，会随机选择一张作为 cover。此时写法应为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png</span></span><br></pre></td></tr></table></figure>

<h2 id="文章页相关配置"><a href="#文章页相关配置" class="headerlink" title="文章页相关配置"></a>文章页相关配置</h2><h3 id="文章meta显示"><a href="#文章meta显示" class="headerlink" title="文章meta显示"></a>文章meta显示</h3><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span>  <span class="comment"># created or updated or both 主页文章日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示标签</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 文章页日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示标签</span></span><br></pre></td></tr></table></figure>

<h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><p>为你的博客文章展示文章版权和许可协议。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure>

<p>由于 Hexo 4.1 开始，默认对网址进行解码，以至于如果是中文网址，会被解码，可设置 <code>decode: true</code> 来显示中文网址。</p>
<p>如果有文章（例如：转载文章）不需要显示版权，可以在文章 <code>Front-matter</code> 单独设置 <code>copyright: false</code></p>
<h3 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h3><p>在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置。</p>
<p>对于没有提供二维码的，可配置一张软件的 icon 图片，然后在 link 上添加相应的打赏链接。用户点击图片就会跳转到链接去。</p>
<p>link 可以不写，会默认为图片的链接。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sponsor/reward (打赏)</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/wechat.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">wechat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">alipay</span></span><br></pre></td></tr></table></figure>

<h3 id="文章隐藏"><a href="#文章隐藏" class="headerlink" title="文章隐藏"></a>文章隐藏</h3><p>如需要文章隐藏功能，请装插件 <a href="https://github.com/hexo-next/hexo-generator-indexed"><strong>hexo-generator-indexed</strong></a> 或者 <a href="https://github.com/printempw/hexo-hide-posts"><strong>hexo-hide-posts</strong></a></p>
<h3 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h3><p>在文章页，会有一个目录，用于显示 TOC。配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># toc (目录)</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># 是否显示TOC</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>   <span class="comment"># 是否显示章节数(自动给章节编号)</span></span><br><span class="line">  <span class="attr">auto_open:</span> <span class="literal">true</span> <span class="comment"># 进入文章页面时，是否自动打开 sidebar 显示TOC</span></span><br></pre></td></tr></table></figure>

<p>为特定的文章配置：</p>
<blockquote>
<p>在你的文章 md 文件的头部，加入 <code>toc_number</code>、<code>toc</code> 和 <code>auto_open</code>，并配置 true 或者 false 即可</p>
</blockquote>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>相关文章推荐的原理是根据文章 tags 的比重来推荐</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Related Articles</span></span><br><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">3</span> <span class="comment"># Number of posts displayed</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期显示创建日期或更新日期</span></span><br></pre></td></tr></table></figure>

<h3 id="文章锚点"><a href="#文章锚点" class="headerlink" title="文章锚点"></a>文章锚点</h3><p>开启文章锚点后，当你在文章页进行滚动时，文章链接会根据标题 ID 进行替换<br>(注意：每替换一次，会留下一个歷史记录。所以如果一篇文章有很多锚点的话，网页的歷史记录会很多。)</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="comment"># when you scroll in post, the URL will update according to header id.</span></span><br><span class="line"><span class="attr">anchor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Avatar (头像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span>  <span class="comment"># 头像是否一直转圈</span></span><br></pre></td></tr></table></figure>

<h2 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h2><p>可开启图片 Figcaption 描述文字显示</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># figcaption (是否开启图片描述)</span></span><br><span class="line"><span class="attr">photofigcaption:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Footer设置"><a href="#Footer设置" class="headerlink" title="Footer设置"></a>Footer设置</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Footer Settings (页脚设置)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># 博客起始时间</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2020</span>  </span><br><span class="line"><span class="comment"># 自定义页脚文本 支持HTML</span></span><br><span class="line"><span class="attr">footer_custom_text:</span>  <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">&lt;a</span> <span class="string">href=&quot;https://xxxxxxx.cn/&quot;&gt;blog&lt;/a&gt;!</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer_copyright:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ICP:</span> <span class="comment">#备案信息</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">/img/icp.png</span></span><br></pre></td></tr></table></figure>

<h2 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a>右下角按钮</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bottom right button (右下角按钮)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (簡繁轉換)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The text of a button</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">简</span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Time delay</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Simplified Chinese</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">&#x27;繁&#x27;</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Traditional Chinese</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">&#x27;简&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read Mode (阅读模式)</span></span><br><span class="line"><span class="attr">readmode:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dark mode (夜间模式)</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="侧边栏排版"><a href="#侧边栏排版" class="headerlink" title="侧边栏排版"></a>侧边栏排版</h2><p>配置 <code>butterfly.yml</code></p>
<p>可自行决定哪个项目需要显示，可决定位置，也可以设置不显示侧边栏。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aside (侧边栏)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># left or right 侧边栏位置</span></span><br><span class="line">  <span class="attr">card_author:</span> <span class="comment">## 作者卡片</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">  <span class="attr">card_announcement:</span> <span class="comment">## 公告</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">Welcome!</span></span><br><span class="line">  <span class="attr">card_categories:</span>  <span class="comment">## 分类</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">2</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">  <span class="attr">card_tags:</span>      <span class="comment">## 标签</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">card_recent_post:</span>  <span class="comment">## 最新文章</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">  <span class="attr">card_archives:</span>  <span class="comment">## 归档</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">  <span class="attr">card_webinfo:</span> <span class="literal">true</span> <span class="comment">## 网站信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># busuanzi count for PV / UV in site</span></span><br><span class="line"><span class="comment"># 不算子统计</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time difference between publish date and now (网站运行时间)</span></span><br><span class="line"><span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">publish_date:</span> <span class="number">7</span><span class="string">/28/2020</span> <span class="number">00</span><span class="string">:00:00</span></span><br></pre></td></tr></table></figure>

<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>选用<a href="https://github.com/xCss/Valine"><strong>Valine</strong></a>，参考<a href="https://valine.js.org/quickstart.html"><strong>快速开始</strong></a> 配置 LeanCloud 应用，以及查看相应的配置说明。。</p>
<p>并配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># valine</span></span><br><span class="line"><span class="comment"># https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appId:</span>   <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span> <span class="comment"># i18n: zh-CN/zh-TW/en/ja</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">留下你的昵称和邮箱...可快速收到回复</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info (nick/mail/link)</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Record reviewer IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">emojiCDN:</span> <span class="comment"># emoji CDN</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">true</span> <span class="comment"># enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span></span><br><span class="line">  <span class="attr">requiredFields:</span> <span class="string">nick,mail</span> <span class="comment"># required fields (nick/mail)</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># dispaly comment count in top_img</span></span><br></pre></td></tr></table></figure>

<p><strong>邮件提醒</strong>使用配置，参考：<a href="https://github.com/zhaojun1998/Valine-Admin"><strong>Valine Admin</strong></a> 。</p>
<h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>选择 <a href="https://github.com/overtrue/share.js/"><strong>sharejs</strong></a> 就好</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Share.js</span></span><br><span class="line"><span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span></span><br></pre></td></tr></table></figure>

<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><h3 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h3><p>你需要安装 <a href="https://github.com/oncletom/hexo-algolia"><strong>hexo-algolia</strong></a> 或 <a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch"><strong>hexo-algoliasearch</strong></a>. 根据它们的说明文档去做相应的配置。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Algolia search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># if there are no result</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">&#x27;$&#123;hits&#125; results found in $&#123;time&#125; ms&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="本地搜索系统"><a href="#本地搜索系统" class="headerlink" title="本地搜索系统"></a>本地搜索系统</h3><p>你需要安装 <a href="https://github.com/PaicHyperionDev/hexo-generator-search"><strong>hexo-generator-search</strong></a>. 根据它的文档去做相应配置。注意格式只支持 xml。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># if there are no result</span></span><br></pre></td></tr></table></figure>

<h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wordcount (字数统计)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="图片查看模式"><a href="#图片查看模式" class="headerlink" title="图片查看模式"></a>图片查看模式</h2><p>选择 <code>fancybox</code></p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lightbox (图片大图查看模式)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># You can only choose one, or neither</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># medium-zoom</span></span><br><span class="line"><span class="comment"># https://github.com/francoischalifour/medium-zoom</span></span><br><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fancybox</span></span><br><span class="line"><span class="comment"># http://fancyapps.com/fancybox/3/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Snacker弹窗"><a href="#Snacker弹窗" class="headerlink" title="Snacker弹窗"></a>Snacker弹窗</h2><p>开启 <code>Snacker</code> ，配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Snackbar (Toast Notification 弹窗)</span></span><br><span class="line"><span class="comment"># https://github.com/polonel/SnackBar</span></span><br><span class="line"><span class="comment"># position 弹窗位置</span></span><br><span class="line"><span class="comment"># 可选 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right</span></span><br><span class="line"><span class="attr">snackbar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">bottom-left</span></span><br><span class="line">  <span class="attr">bg_light:</span> <span class="string">&#x27;#49b1f5&#x27;</span> <span class="comment"># The background color of Toast Notification in light mode</span></span><br><span class="line">  <span class="attr">bg_dark:</span> <span class="string">&#x27;#121212&#x27;</span> <span class="comment"># The background color of Toast Notification in dark mode</span></span><br></pre></td></tr></table></figure>

<h2 id="美化-特效"><a href="#美化-特效" class="headerlink" title="美化/特效"></a>美化/特效</h2><p>完整设置参考：<a href="https://demo.jerryc.me/posts/ceeb73f/#%E7%BE%8E%E5%8C%96-%E7%89%B9%E6%95%88">https://demo.jerryc.me/posts/ceeb73f/#美化-特效</a></p>
<h3 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mouse click effects: words (鼠標點擊效果: 文字)</span></span><br><span class="line"><span class="attr">ClickShowText:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">富强</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">民主</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">文明</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">和谐</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自由</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">平等</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">公正</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">法治</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">爱国</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">敬业</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">诚信</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">友善</span></span><br><span class="line">  <span class="attr">fontSize:</span> <span class="string">25px</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Theme-Butterfly(二) 主题页面</title>
    <url>/hexo/Hexo-Theme-Butterfly(%E4%BA%8C)-%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<blockquote>
<p>感谢原作者 <a href="https://jerryc.me/">JerryC</a> </p>
<p>由于主题更新，此文件中部分配置可能失效。请参考作者博客或文档：<a href="https://demo.jerryc.me/posts/dc584b87/">Butterfly 安装文档(二) 主题页面</a> </p>
</blockquote>
<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h2><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>title</strong></td>
<td>【必需】页面标题</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>【必需】页面创建日期</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>【必需】标签、分类和友情链接三个页面需要配置</td>
</tr>
<tr>
<td>description</td>
<td>页面描述（需要设置主页文章节选）</td>
</tr>
<tr>
<td>keywords</td>
<td>页面关键字</td>
</tr>
<tr>
<td>comments</td>
<td>是否要显示页面评论模块，默认true</td>
</tr>
<tr>
<td>top_img</td>
<td>页面顶部图片</td>
</tr>
</tbody></table>
<p>查看完整参数：<a href="https://demo.jerryc.me/posts/dc584b87/#Page-Front-matter">Page Front-matter</a></p>
<h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><table>
<thead>
<tr>
<th>标签</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>title</strong></td>
<td>【必需】文章标题</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>tags</td>
<td>文章标签</td>
</tr>
<tr>
<td>categories</td>
<td>文章分类</td>
</tr>
<tr>
<td>description</td>
<td>文章描述（没看到哪儿显示……）</td>
</tr>
<tr>
<td></td>
<td>文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td>
</tr>
<tr>
<td>keywords</td>
<td>文章关键字</td>
</tr>
<tr>
<td>comments</td>
<td>显示文章评论模块，默认true</td>
</tr>
<tr>
<td>top_img</td>
<td>页面顶部图片</td>
</tr>
</tbody></table>
<p>查看完整参数：<a href="https://demo.jerryc.me/posts/dc584b87/#Post-Front-matter">Post Front-matter</a></p>
<h1 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h1><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page tags</code></li>
<li>你会找到 <code>source/tags/index.md</code> 这个文件</li>
<li>根据 <a href="#Page-Front-matter"><strong>Page Front-matter</strong></a> 修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签页</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: tags</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: /img/page-tags-top.png</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>

<h1 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h1><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page categories</code></li>
<li>你会找到 <code>source/categories/index.md</code> 这个文件</li>
<li>根据 <a href="#Page-Front-matter"><strong>Page Front-matter</strong></a> 修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: /img/page-categories-top.jpg</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>

<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><h2 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建友情链接页面</h2><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page link</code></li>
<li>你会找到 <code>source/link/index.md</code> 这个文件</li>
<li>根据 <a href="#Page-Front-matter"><strong>Page Front-matter</strong></a> 修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: link</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: /img/page-link-top.jpg</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>

<h2 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a>友情链接添加</h2><p>在 Hexo 博客目录中的 <code>source/_data</code>，创建一个文件 <code>link.yml</code>，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- class_name: 友情链接簇</span><br><span class="line">  class_desc: 友情链接簇描述</span><br><span class="line">  link_list:</span><br><span class="line">    1:</span><br><span class="line">      name: 链接名</span><br><span class="line">      link: 链接地址</span><br><span class="line">      avatar: 链接头像</span><br><span class="line">      descr: 链接描述</span><br><span class="line">    2:</span><br><span class="line">      name: 链接名</span><br><span class="line">      link: 链接地址</span><br><span class="line">      avatar: 链接头像</span><br><span class="line">      descr: 链接描述</span><br><span class="line"></span><br><span class="line">- class_name: 网站</span><br><span class="line">  class_desc: 值得推荐的网站</span><br><span class="line">  link_list:</span><br><span class="line">    - name: Youtube</span><br><span class="line">      link: https:&#x2F;&#x2F;www.youtube.com&#x2F;</span><br><span class="line">      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;9ZkGg8v3azHJfM1.png</span><br><span class="line">      descr: 视频网站</span><br><span class="line">    - name: Weibo</span><br><span class="line">      link: https:&#x2F;&#x2F;www.weibo.com&#x2F;</span><br><span class="line">      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;TLJBum386vcnI1P.png</span><br><span class="line">      descr: 中国最大社交分享平台</span><br><span class="line">    - name: Twitter</span><br><span class="line">      link: https:&#x2F;&#x2F;twitter.com&#x2F;</span><br><span class="line">      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;5VyHPQqR6LWF39a.png</span><br><span class="line">      descr: 社交分享平台</span><br></pre></td></tr></table></figure>

<p><code>class_name</code> 和 <code>class_desc</code> 支持 <code>html</code> 格式书写，如不需要，也可以留空。</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><p>音乐界面使用了插件  。使用方法参考 <a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md"><strong>插件文档</strong></a> 。</p>
<p>首先在 Hexo 根目录 <code>_config</code> 里配置 <code>asset_inject</code> 为 <code>false</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>然后在你需要使用 <code>aplayer</code> 的页面 <code>Front-matter</code> 添加</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">aplayer: true</span><br></pre></td></tr></table></figure>

<p>这样只会在需要 aplayer 的页面插入 js 和 css。</p>
<h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><p>电影界面使用了插件 <a href="https://github.com/mythsman/hexo-douban"><strong>hexo-douban</strong></a> ，使用方法参考插件文档。</p>
<h1 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h1><p>主题内置了一个简单的 404 页面，可在设置中开启，<code>butterfly.yml</code> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;Page not found&#x27;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">/img/page-404.jpg</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本地浏览： <a href="http://localhost:4000/404.html">http://localhost:4000/404.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Hexo+GitHub搭建个人博客</title>
    <url>/hexo/Linux%E4%B8%8Bgithub+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# uname -a</span><br><span class="line">Linux iZwz9c74ta983j746ynevpZ 3.10.0-1127.10.1.el7.x86_64 #1 SMP Wed Jun 3 14:28:03 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="更新源（可略过）"><a href="#更新源（可略过）" class="headerlink" title="更新源（可略过）"></a>更新源（可略过）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 备份原 源文件</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# mv /etc/yum.repos.d /etc/yum.repos.d.bak</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZr ~]# mkdir /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 阿里云</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo --no-check-certificate</span><br><span class="line"></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum clean all</span><br><span class="line"></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum makecache</span><br><span class="line"></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum update -y</span><br></pre></td></tr></table></figure>

<h2 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum install -y git</span><br></pre></td></tr></table></figure>

<h3 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h3><h4 id="node-js安装包下载"><a href="#node-js安装包下载" class="headerlink" title="node.js安装包下载"></a>node.js安装包下载</h4><p><strong>网址：</strong> <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<p><strong>阿里云镜像：</strong> <a href="https://npm.taobao.org/mirrors/node">https://npm.taobao.org/mirrors/node</a></p>
<p>下载对应二进制安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# wget https://npm.taobao.org/mirrors/node/v14.6.0/node-v14.6.0-linux-x64.tar.gz --no-check-certificate</span><br></pre></td></tr></table></figure>

<h4 id="node-js安装部署"><a href="#node-js安装部署" class="headerlink" title="node.js安装部署"></a>node.js安装部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# tar -zxf node-v14.6.0-linux-x64.tar.gz </span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# mv node-v14.6.0-linux-x64 /opt/nodejs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软连接</span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# ln -s /opt/nodejs/bin/node /usr/local/bin/node </span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# ln -s /opt/nodejs/bin/npm /usr/local/bin/npm </span><br></pre></td></tr></table></figure>

<h3 id="Hexo安装部署"><a href="#Hexo安装部署" class="headerlink" title="Hexo安装部署"></a>Hexo安装部署</h3><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm install hexo-cli -g</span><br><span class="line">/opt/nodejs/bin/hexo -&gt; /opt/nodejs/lib/node_modules/hexo-cli/bin/hexo</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.1.2 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">+ hexo-cli@4.0.0</span><br><span class="line">added 61 packages from 315 contributors in 46.255s</span><br></pre></td></tr></table></figure>

<p>若安装hexo报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm install hexo-cli -g</span><br><span class="line">npm ERR! code CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! errno CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: certificate is not yet valid</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2010-03-31T20_55_08_156Z-debug.log</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm install hexo-cli -g --no-check-certificate</span><br><span class="line">npm ERR! code CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! errno CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: certificate is not yet valid</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2010-03-31T20_55_35_518Z-debug.log</span><br></pre></td></tr></table></figure>

<p>原因是https的自签名失败，临时解决办法：关闭ssl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm config set strict-ssl false</span><br></pre></td></tr></table></figure>

<h4 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h4><p>将 hexo 命令添加到全局，采用软连接方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# ln -s /opt/nodejs/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure>

<h2 id="Hexo博客环境部署"><a href="#Hexo博客环境部署" class="headerlink" title="Hexo博客环境部署"></a>Hexo博客环境部署</h2><h3 id="初始化Hexo博客根目录"><a href="#初始化Hexo博客根目录" class="headerlink" title="初始化Hexo博客根目录"></a>初始化Hexo博客根目录</h3><p><strong><em>强烈建议先换npm源！！！见：<a href="#%E6%9B%B4%E6%8D%A2npm%E6%BA%90">更换npm源</a></em></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# mkdir /var/hexoblog</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# hexo init /var/hexoblog/</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">Submodule &#x27;themes/landscape&#x27; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#x27;themes/landscape&#x27;</span><br><span class="line">Cloning into &#x27;themes/landscape&#x27;...</span><br><span class="line">remote: Enumerating objects: 8, done.</span><br><span class="line">remote: Counting objects: 100% (8/8), done.</span><br><span class="line">remote: Compressing objects: 100% (6/6), done.</span><br><span class="line">remote: Total 1071 (delta 1), reused 5 (delta 1), pack-reused 1063</span><br><span class="line">Receiving objects: 100% (1071/1071), 3.22 MiB | 12.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (586/586), done.</span><br><span class="line">Submodule path &#x27;themes/landscape&#x27;: checked out &#x27;73a23c51f8487cfcd7c6deec96ccc7543960d350&#x27;</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>卡住在这……，猜测是npm源问题，更换国内源</p>
<h4 id="更换npm源"><a href="#更换npm源" class="headerlink" title="更换npm源"></a>更换npm源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看 默认源</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# npm config get registry</span><br><span class="line">https://registry.npmjs.org/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 更换阿里源</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# npm config set registry https://registry.npm.taobao.org</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# npm config get registry</span><br><span class="line">https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<p>若init失败，<strong>须清空文件夹下内容，ls -a 查看还有一个影藏文件</strong>，再次初始化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# rm ./* -rf</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# ls -a</span><br><span class="line">.  ..  .gitignore</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# rm .gitignore -f</span><br></pre></td></tr></table></figure>

<h3 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h3><p>生成静态文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# hexo g</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# ls -l </span><br><span class="line">total 132</span><br><span class="line">-rw-r--r--   1 root root  2367 Jul 28 15:54 _config.yml</span><br><span class="line">-rw-r--r--   1 root root 25111 Jul 28 15:59 db.json</span><br><span class="line">drwxr-xr-x 189 root root  4096 Jul 28 15:54 node_modules</span><br><span class="line">-rw-r--r--   1 root root   581 Jul 28 15:59 package.json</span><br><span class="line">-rw-r--r--   1 root root 74694 Jul 28 15:54 package-lock.json</span><br><span class="line">drwxr-xr-x   7 root root  4096 Jul 28 15:59 public        ## 存放生成的静态文件</span><br><span class="line">drwxr-xr-x   2 root root  4096 Jul 28 15:54 scaffolds</span><br><span class="line">drwxr-xr-x   3 root root  4096 Jul 28 15:54 source</span><br><span class="line">drwxr-xr-x   3 root root  4096 Jul 28 15:54 themes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<h3 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br><span class="line">或</span><br><span class="line">http:&#x2F;&#x2F;服务器IP地址:4000&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h2><h3 id="创建github-io仓储"><a href="#创建github-io仓储" class="headerlink" title="创建github.io仓储"></a>创建github.io仓储</h3><p>新建仓库，仓库名为：<code>your_github_user_name.github.io</code></p>
<h3 id="GitHub-Pages-默认已开启"><a href="#GitHub-Pages-默认已开启" class="headerlink" title="GitHub Pages(默认已开启)"></a>GitHub Pages(默认已开启)</h3><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><h3 id="浏览器访问-1"><a href="#浏览器访问-1" class="headerlink" title="浏览器访问"></a>浏览器访问</h3><blockquote>
<p><code>https://your_github_user_name.github.io</code></p>
</blockquote>
<h3 id="添加SSH-keys-已有忽略"><a href="#添加SSH-keys-已有忽略" class="headerlink" title="添加SSH keys(已有忽略)"></a>添加SSH keys(已有忽略)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成SSH Key，等待输入按下 Enter 回车键三次</span></span><br><span class="line">ssh-keygen -t rsa  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制公钥 添加到 github</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h3 id="测试GitHub连接"><a href="#测试GitHub连接" class="headerlink" title="测试GitHub连接"></a>测试GitHub连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27;github.com (52.74.223.119)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">RSA key fingerprint is MD5:16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Hi JakeLin0fly! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<h3 id="设置Github账户信息"><a href="#设置Github账户信息" class="headerlink" title="设置Github账户信息"></a>设置Github账户信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot; </span><br><span class="line">git config --global user.email &quot;GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Hexo部署到GitHub-Pages"><a href="#Hexo部署到GitHub-Pages" class="headerlink" title="Hexo部署到GitHub Pages"></a>Hexo部署到GitHub Pages</h2><h3 id="Hexo-config-yml修改"><a href="#Hexo-config-yml修改" class="headerlink" title="Hexo _config.yml修改"></a>Hexo _config.yml修改</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h3 id="同步到GitHub"><a href="#同步到GitHub" class="headerlink" title="同步到GitHub"></a>同步到GitHub</h3><p>需要安装插件 <code>hexo-deployer-git</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>Hexo命令，详细命令参考：<a href="https://hexo.io/docs/commands">https://hexo.io/docs/commands</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo cl    ## 删除 public/  db.json</span><br><span class="line">hexo g    ## 构建项目 主要是生成 public/  db.json</span><br><span class="line">hexo d    ## 部署到配置文件中设置的仓库</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-theme-next主题配置</title>
    <url>/hexo/hexo-theme-next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>2020-08-02 版本信息</p>
<blockquote>
<p>nodejs : v12.18.3</p>
<p>hexo: 5.0.0<br> hexo-cli: 4.1.0</p>
<p>NexT :  <a href="https://github.com/next-theme/hexo-theme-next/releases/tag/v8.0.0-rc.5">v8.0.0-rc.5</a></p>
</blockquote>
<h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p><img src="https://i.loli.net/2020/08/03/IFlo6fVkXJ8HpUv.png" alt="Next主题首页截图.png"></p>
<p><img src="https://i.loli.net/2020/08/03/X1WITxsLjgeuSpK.png" alt="Next主题博客界面截图.png"></p>
<h1 id="获取Next"><a href="#获取Next" class="headerlink" title="获取Next"></a>获取Next</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h1 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h1><p>根目录 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h1 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h1><h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p>将主题配置文件放在 <code>网站很目录</code> 下，命名为 <code>_config.next.yml</code> ，详情见：<a href="https://theme-next.js.org/docs/getting-started/configuration">Configuration</a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp themes/next/_config.yml ./_config.next.yml</span><br></pre></td></tr></table></figure>

<h2 id="选择主题风格"><a href="#选择主题风格" class="headerlink" title="选择主题风格"></a>选择主题风格</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse   #预览参考 https://theme-next.js.org/muse/</span></span><br><span class="line"><span class="comment">#scheme: Mist     #预览参考 https://theme-next.js.org/mist/</span></span><br><span class="line"><span class="comment">#scheme: Pisces #预览参考 https://theme-next.js.org/pisces/</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span>  <span class="comment">#预览参考 https://theme-next.js.org/</span></span><br></pre></td></tr></table></figure>

<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment"># 显示图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span> <span class="comment"># 显示统计信息</span></span><br></pre></td></tr></table></figure>

<h3 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h3><p>生成编辑<code>Hexo/source/tags/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: tags</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h3><p>生成编辑<code>Hexo/source/categories/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>      <span class="comment"># 显示社交图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">true</span>  <span class="comment"># 只显示图标，不显示文字</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="首页显示的文章属性"><a href="#首页显示的文章属性" class="headerlink" title="首页显示的文章属性"></a>首页显示的文章属性</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span> <span class="comment"># 设为true 可以一行显示，文章的所有属性</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># 显示修改的时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">false</span> <span class="comment"># 设true时，如果创建时间和修改时间一样则显示一个时间</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>  <span class="comment"># 显示分类信息</span></span><br></pre></td></tr></table></figure>

<h2 id="footer信息"><a href="#footer信息" class="headerlink" title="footer信息"></a>footer信息</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2019</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Powered by Hexo &amp; NexT</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="目录设置"><a href="#目录设置" class="headerlink" title="目录设置"></a>目录设置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果为true，则所有标题将在标题宽度长于边栏宽度的情况下放在下一行。</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果为true，则将显示帖子中所有级别的TOC，而不是帖子中已激活的部分。</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span>  <span class="comment"># 字体转动 鬼畜。。。。</span></span><br><span class="line">  <span class="comment">#comment: Donate comment here.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span> <span class="comment"># 打赏二维码链接</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">https://i.loli.net/2020/08/01/na8BbXF1ow63OIJ.png</span> </span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">https://i.loli.net/2020/08/01/NALchOTe3vM8aYy.jpg</span></span><br></pre></td></tr></table></figure>

<h2 id="文章版权声明"><a href="#文章版权声明" class="headerlink" title="文章版权声明"></a>文章版权声明</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line"><span class="comment">#    light: default</span></span><br><span class="line"><span class="comment">#    dark: tomorrow-night</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">atom-one-dark-reasonable</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">atom-one-dark-reasonable</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="comment"># light: prism</span></span><br><span class="line">    <span class="comment"># dark: prism-dark</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism-vsc-dark-plus</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-vsc-dark-plus</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 复制按钮的开关</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>

<h2 id="GitHub-Banner"><a href="#GitHub-Banner" class="headerlink" title="GitHub_Banner"></a>GitHub_Banner</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="comment"># 你的GitHub地址</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>

<h2 id="配置本地搜索"><a href="#配置本地搜索" class="headerlink" title="配置本地搜索"></a>配置本地搜索</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="busuanzi统计"><a href="#busuanzi统计" class="headerlink" title="busuanzi统计"></a>busuanzi统计</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                     <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>             <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                 <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                  <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>

<h2 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-word-counter --save</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-word-counter</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span> <span class="comment"># false会显示一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span> <span class="comment"># 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 底部footer是否显示字数统计属性文字</span></span><br></pre></td></tr></table></figure>

<h1 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h1><p>首先在 NexT 的配置文件 <code>_config.next.yml</code> 中取消下列对应样式文件的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source&#x2F;_data&#x2F;head.swig</span><br><span class="line">  #header: source&#x2F;_data&#x2F;header.swig</span><br><span class="line">  #sidebar: source&#x2F;_data&#x2F;sidebar.swig</span><br><span class="line">  #postMeta: source&#x2F;_data&#x2F;post-meta.swig</span><br><span class="line">  #postBodyEnd: source&#x2F;_data&#x2F;post-body-end.swig</span><br><span class="line">  #footer: source&#x2F;_data&#x2F;footer.swig</span><br><span class="line">  #bodyEnd: source&#x2F;_data&#x2F;body-end.swig</span><br><span class="line">  #variable: source&#x2F;_data&#x2F;variables.styl</span><br><span class="line">  #mixin: source&#x2F;_data&#x2F;mixins.styl</span><br><span class="line">  #style: source&#x2F;_data&#x2F;styles.styl</span><br></pre></td></tr></table></figure>

<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p>取消 <code>_config.next.yml</code> 中 <code>style: source/_data/styles.styl</code> 注释。</p>
<p>创建 <code>source/_data/styles.styl</code> ：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置背景图片</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    # 图片地址</span><br><span class="line">    background:url(https://i.loli.net/2020/08/02/pjAgE9dIcTZSCoB.jpg); </span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; <span class="comment">//不重复</span></span><br><span class="line">    <span class="attribute">background-size</span>: cover;      <span class="comment">//填充</span></span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h2><p><code>source/_data/styles.styl</code> 中增加样式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sidebar css </span></span><br><span class="line">.sidebar&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="圆角设置"><a href="#圆角设置" class="headerlink" title="圆角设置"></a>圆角设置</h2><p>取消 <code>_config.next.yml</code> 中 <code>style: source/_data/variables.styl</code> 注释。</p>
<p>创建 <code>source/_data/variables.styl</code> ：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 15px 15px 15px 15px;</span><br><span class="line"><span class="variable">$border</span>-radius       </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-theme-next提交给搜索引擎</title>
    <url>/hexo/hexo-theme-next%E6%8F%90%E4%BA%A4%E7%BB%99%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="站点地图生成"><a href="#站点地图生成" class="headerlink" title="站点地图生成"></a>站点地图生成</h1><ol>
<li><p>插件安装</p>
<ul>
<li><p>Google站点地图插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>百度站点地图插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修改站点配置文件</p>
</li>
</ol>
<p><code>_config.yml</code> 中加入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span> <span class="comment"># 提交给Google</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span> <span class="comment"># 提交给百度</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>重新构建项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="提交站点地图"><a href="#提交站点地图" class="headerlink" title="提交站点地图"></a>提交站点地图</h1><p>直接参考：<a href="https://fanandjiu.com/Hexo%E9%97%AE%E9%A2%98-%E6%8F%90%E4%BA%A4%E7%AB%99%E7%82%B9%E7%BB%99%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BB%A5%E5%8F%8ASEO/">Hexo问题-提交站点给搜索引擎以及SEO</a> </p>
<p><strong><em>注意：在Google进行DNS记录验证域名所有权时，因为阿里云域名解析的记录值不允许两个 <code>@</code> ，但将域名记录值 <code>@</code> 用以验证，验证完后再更改记录值是可行的。验证后需要一定的时间才能google搜索到！</em></strong> </p>
<p><img src="https://i.loli.net/2020/08/06/SBGhud2oF7V4ZKj.png" alt="DNS验证域名所有权-Google.png"></p>
<h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>参考：<a href="https://theme-next.js.org/docs/third-party-services/statistics-and-analytics.html">Statistics and Analytics</a> </p>
<h2 id="Google-分析"><a href="#Google-分析" class="headerlink" title="Google 分析"></a>Google 分析</h2><ol>
<li><p>创建一个 <a href="https://analytics.google.com/">Google Analytics</a> 账号</p>
</li>
<li><p>得到一个 <code>跟踪ID</code> ：UA-xxxxxx</p>
</li>
<li><p>修改Next配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span> <span class="string">你的跟踪ID</span> <span class="comment"># &lt;app_id&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="百度分析"><a href="#百度分析" class="headerlink" title="百度分析"></a>百度分析</h2><ol>
<li><p>去<a href="https://tongji.baidu.com/web/welcome/login">百度统计</a>，新增一个网站</p>
</li>
<li><p>复制统计代码中的 <code>hm.src = &quot;https://hm.baidu.com/hm.js?[这里的脚本ID]&quot;</code></p>
</li>
<li><p>修改Next配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Baidu Analytics</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">脚本ID</span> <span class="comment"># &lt;app_id&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>valine评论</title>
    <url>/hexo/valine%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>站点配置文件 <code>url</code> 地加 <code>http</code> 头，否则文章末尾【本文链接】地址为：<strong>域名/域名/xxxxxxx</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://jakelin.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>记录类型：CNAME</p>
<ol start="2">
<li>主机记录：@</li>
<li>记录值：Github Pages项目域名</li>
</ol>
</li>
</ol>
<h2 id="注册LeanClound，获取APP-ID-和-APP-Key"><a href="#注册LeanClound，获取APP-ID-和-APP-Key" class="headerlink" title="注册LeanClound，获取APP ID 和 APP Key"></a>注册LeanClound，获取APP ID 和 APP Key</h2><p>注册链接： <a href="https://leancloud.cn/dashboard/login.html#/signup">LeanClound注册</a> </p>
<p>【创建应用】-&gt;【随便起个名】-&gt;【开发版】-&gt;[创建]</p>
<p><img src="https://i.loli.net/2020/08/03/kNErsH8PezWO1uj.png" alt="LeanClound创建应用.png"></p>
<p><img src="https://i.loli.net/2020/08/03/uxdiBNf6g4MKwOs.png" alt="获取key.png"></p>
<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">这里填</span> <span class="string">AppID</span>  <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">这里填</span> <span class="string">AppKey</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&#x27;ヾﾉ≧∀≦)o来啊，快活啊!&#x27;</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">false</span> <span class="comment"># Whether to enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [] <span class="comment"># Set required fields: [&#x27;nick&#x27;] | [&#x27;nick&#x27;,&#x27;mail&#x27;]</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>

<h2 id="添加邮件提醒"><a href="#添加邮件提醒" class="headerlink" title="添加邮件提醒"></a>添加邮件提醒</h2><p>见： <a href="https://tding.top/archives/ed8b904f.html">小丁的个人博客–Hexo-NexT 配置 Valine</a> </p>
<h2 id="云引擎绑定域名"><a href="#云引擎绑定域名" class="headerlink" title="云引擎绑定域名"></a>云引擎绑定域名</h2><p><font color=red><strong>强调：需要先备案！！！</strong></font></p>
<ol>
<li><p>环境变量设置</p>
<p>【云引擎】–&gt;【设置】–&gt;【添加环境变量】</p>
<blockquote>
<p>变量名：<code>ADMIN_URL</code></p>
<p>变量值：<code>http://你的leancloud域名主机记录.主域名</code>    如：<a href="http://leancloud.jakelin.cn/">http://leancloud.jakelin.cn</a></p>
</blockquote>
</li>
<li><p>云引擎域名绑定</p>
<p>【设置】–&gt;【域名绑定】–&gt;【云引擎、ClientEngine 域名】–&gt;【绑定新域名】</p>
<p>就上面环境变量的值，即是你需要绑定的域名</p>
<blockquote>
<p><code>http://你的leancloud域名主机记录.主域名</code></p>
</blockquote>
</li>
<li><p>域名解析</p>
<p>到域名所在提供商添加域名解析</p>
<blockquote>
<p>主机记录：<code>你的leancloud域名主机记录</code>（注：和上面的一致）</p>
<p>记录类型：<code>CNAME</code></p>
<p>记录值：上一步绑定新域名产生的记录值</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/15/cqtrpWxbSQRDkgG.png" alt="leancloud-域名解析记录值.png"></p>
</li>
<li><p>添加用户</p>
<p>添加leancloud评论管理用户。</p>
<p>【存储】–&gt;【结构化数据】–&gt;【_User】–&gt;【添加行】</p>
<p><strong><em>注：没有使用用户名成功登录，仅添加了邮箱后通过邮箱成功登录</em></strong></p>
</li>
<li><p>重新部署</p>
<p>修改了环境变量，须重新部署才能生效。</p>
<p>【云引擎】–&gt;【部署】–&gt;[重启]</p>
</li>
<li><p>登录评论管理</p>
<p>地址：<code>http://你的leancloud域名主机记录.主域名</code></p>
</li>
</ol>
<h2 id="休眠策略"><a href="#休眠策略" class="headerlink" title="休眠策略"></a>休眠策略</h2><p><strong>【写前面】</strong><font color=red><strong><em>定时任务每天早上不能唤醒，然后一天都在休眠。也就是早上唤醒一次后，定时任务才能正常执行！！！</em></strong></font>通过浏览器访问评论管理系统，会唤醒leanCloud。因此，我直接使用<strong>linux定时任务</strong>每天第一次唤醒leanCloud，然后<strong>leanCloud的定时任务</strong>负责一天的间隔时间唤醒。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试 curl</span></span><br><span class="line">/usr/bin/curl 你的leancloud评论管理地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入 每天7:59执行 访问网址</span></span><br><span class="line">59 7 * * * /usr/bin/curl 你的leancloud评论管理地址</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意</strong></font>：评论地址注意是 <strong>http</strong> 不是 https（因为我没有SSL，使用https无法唤醒）。</p>
<p><strong>免费版</strong>的 LeanCloud 容器，是有<strong>强制性休眠策略</strong>的，不能 24 小时运行：</p>
<ul>
<li>每天必须休眠 6 个小时</li>
<li>30 分钟内没有外部请求，则休眠。</li>
<li>休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。</li>
</ul>
<p>我设置的是定时任务，一个<strong>定时唤醒</strong>，一个<strong>定时检测</strong>过去24小时是否有漏发邮件。</p>
<p><strong><em>注意：还是可能出现问题，遇到了定时唤醒失败的情况，参考过GitHub Action，但是貌似就运行了一下就没了。。。</em></strong></p>
<p><img src="https://i.loli.net/2020/08/15/ZlauFhVYMsoykgE.png" alt="leancloud-定时任务.png"></p>
<p><img src="https://i.loli.net/2020/08/15/rF6YfotjdZgXxSm.png" alt="leancloud-定时任务resend-mails__.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://valine.js.org/quickstart.html">Valine-快速开始</a></p>
<p><a href="https://www.cnblogs.com/huanhao/p/emailvaline.html">Valine评论系统邮件提醒</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题记录</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43. 1～n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">43. 1～n整数中1出现的次数</a></h3><blockquote>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>暴力解法：对于区间内的每<strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p> <strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt; 2^31</code></li>
</ul>
<p>个数的每一位进行判断。显然不太友好。</p>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p><strong>有意思的解法</strong>（<a href="https://blog.csdn.net/yi_Afly/article/details/52012593">参考链接</a>）：</p>
<p>考虑将n的十进制的每一位单独拿出讨论，给定一个n，其最后一位（个位）记为<code>last_bit</code>。<code>last_bit</code>从0到9记为一个周期。一个周期中1出现的次数为1次。</p>
<p>从1到n，总共有<strong>round = n/10</strong>个完整的周期。再看<code>last_bit</code>值，当值大于0时，1又出现了一次。</p>
<p> [1, n]中个位出现1的次数 = round + (last_bit &gt; 0)?1 : 0</p>
<blockquote>
<p>将n的各个位分为两类：个位与其它位。</p>
<p>对个位来说：</p>
<ul>
<li>若个位大于0，1出现的次数为<code>round*1+1</code></li>
<li>若个位等于0，1出现的次数为<code>round*1</code></li>
</ul>
<p>对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，则：</p>
<ul>
<li>若weight为0，则1出现次数为<code>round*base</code></li>
<li>若weight为1，则1出现次数为<code>round*base+former+1</code></li>
<li>若weight大于1，则1出现次数为<code>rount*base+base</code></li>
</ul>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last_bit, round;</span><br><span class="line">    <span class="keyword">long</span> base; <span class="comment">// 防止溢出</span></span><br><span class="line">    round = n;</span><br><span class="line">    base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(round)&#123;</span><br><span class="line">        last_bit = round % <span class="number">10</span>; <span class="comment">//round 最后数值</span></span><br><span class="line">        round = round / <span class="number">10</span>;  <span class="comment">// round 最后数值从 0~9 有多少个完整的周期</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == last_bit)</span><br><span class="line">            count += round * base;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == last_bit)</span><br><span class="line">            count += round * base + n % base + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count += round * base + base;</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">49. 丑数</a></h3><blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p><strong>判断丑数的方法</strong>：首先除2，直到不能整除为止，然后除5到不能整除为止，然后除3直到不能整除为止。最终判断剩余的数字是否为1，如果是1则为丑数，否则不是丑数。</p>
<p><strong>查找第N大的丑数</strong>：根据丑数的性质，仅含有2、3、5质因子，除1以外，后面的某个丑数一定是前面某个丑数乘以2或3或5的结果。因此可以以空间换时间，维护一个从小到大的丑数列表。</p>
<p><strong><em>疑问：使用空间存储备选的三个丑数，感觉是减少了计算次数，但是LeetCode上提交的时间效率居然更低？？？</em></strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ugly_number_list;</span><br><span class="line">        <span class="keyword">int</span> mult_2_index, mult_3_index, mult_5_index; <span class="comment">// 当前乘2、3、5的丑数列表中值的下标</span></span><br><span class="line">        ugly_number_list.push_back(<span class="number">1</span>);</span><br><span class="line">        mult_2_index = mult_3_index = mult_5_index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">            <span class="keyword">int</span> min_num = min(ugly_number_list[mult_2_index]*<span class="number">2</span>,</span><br><span class="line">                 min(ugly_number_list[mult_3_index]*<span class="number">3</span>, ugly_number_list[mult_5_index]*<span class="number">5</span>));</span><br><span class="line">            ugly_number_list.push_back(min_num); <span class="comment">// 第 k 大丑数</span></span><br><span class="line">            <span class="keyword">if</span>(min_num == ugly_number_list[mult_2_index]*<span class="number">2</span>)&#123;</span><br><span class="line">                ++mult_2_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min_num == ugly_number_list[mult_3_index]*<span class="number">3</span>)&#123;</span><br><span class="line">                ++mult_3_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min_num == ugly_number_list[mult_5_index]*<span class="number">5</span>)&#123;</span><br><span class="line">                ++mult_5_index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ugly_number_list.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">51. 数组中的逆序对</a></h3><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

</blockquote>
<p><strong>【解题思路】</strong> </p>
<p>首先暴力解法，利用冒泡排序，交换次数即是逆序对数量，时间复杂度 <code>O(n^2)</code> 。</p>
<p>再有，利用<strong>归并排序</strong>思想，先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。时间复杂度 <code>O(nlogn)</code> 。递归算法空间复杂度 <code>O(n+logn)</code> ，非递归算法空间复杂度 <code>O(n)</code> </p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 交换次数 = 逆序对数 O(n*n) </span></span><br><span class="line"><span class="comment">//归并排序 将数组分为两个子数组，先统计子数组逆序对数目，在合并子数组统计相邻子数组之间的逆序对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 存储过程中的数据</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// mergeSort(nums, 0, nums.size()-1, tmp, sum);</span></span><br><span class="line">    mergeSort_2(nums, tmp, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归 归并排序 [begin, end] 时间复杂度O(nlogn) 空间复杂的O(n+logn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (begin &gt;&gt; <span class="number">1</span>) + (end &gt;&gt; <span class="number">1</span>);  <span class="comment">// (begin + end) &gt;&gt; 1 担心溢出</span></span><br><span class="line">    mergeSort(nums, begin, mid, tmp, sum);</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, end, tmp, sum);</span><br><span class="line">    merge(nums, begin, mid, end, tmp, sum); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 归并排序 时间复杂度O(nlogn) 空间复杂的O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort_2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin, mid, end, length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(length &lt; nums.size())&#123;</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin + length &lt; nums.size())&#123;</span><br><span class="line">            mid = begin + length - <span class="number">1</span>;</span><br><span class="line">            end = mid + length;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= nums.size())</span><br><span class="line">                end = nums.size() - <span class="number">1</span>;</span><br><span class="line">            merge(nums, begin, mid, end, tmp, sum);</span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并相邻有序两子数组 [begin, mid] [mid+1, end]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = begin, right = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp_index = begin;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid &amp;&amp; right &lt;= end)&#123; <span class="comment">// 归并到 tmp 数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt;= nums[right])</span><br><span class="line">            tmp[tmp_index++] = nums[left++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum += mid - left + <span class="number">1</span>; <span class="comment">// 左边子数组有比左边子数组当前所指值大的数组数目（即逆序对数目）</span></span><br><span class="line">            tmp[tmp_index++] = nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid) <span class="comment">// 左边数组还有数未排序 (有序)</span></span><br><span class="line">        tmp[tmp_index++] = nums[left++];</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= end) <span class="comment">// 右边数组还有数未排序 (有序)</span></span><br><span class="line">        tmp[tmp_index++] = nums[right++];</span><br><span class="line">    <span class="comment">// 将排序结果 更新到原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; ++i)&#123;</span><br><span class="line">        nums[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52. 两个链表的第一个公共节点</a></h3><blockquote>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom: 50%;" /></a></p>
<p>在节点 c1 开始相交。</p>
</blockquote>
<p>【<strong>解题思路</strong>】 </p>
<p>假设A链长度：<strong>a+n</strong>  B链长度：<strong>b+n</strong>，且 <strong>a&lt;b</strong>。</p>
<p>pA 从头走到尾走了 <strong>a+n</strong> 个位置，pB 也走了 <strong>a+n</strong> 个位置，且 pB 距离尾部还有 <strong>(b+n)-(a+n) = b-a</strong> 个位置。此时 pA 指向B链，当 pB 达到链尾时，pA 从B链移动了 b-a 个位置，距离第一个公共结点还需 <strong>a</strong> 步，此时让 pB 指向A链，那么 pB 距离第一个公共结点也是 <strong>a</strong> 步。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">            <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != pA)</span><br><span class="line">                    pA = pA-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pA = headB;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != pB)</span><br><span class="line">                    pB = pB-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pB = headA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span></span><br><span class="line"><span class="comment">        if(NULL == headA || NULL == headB)</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        // 先计算每条链表长度</span></span><br><span class="line"><span class="comment">        int len_A = 0, len_B = 0;</span></span><br><span class="line"><span class="comment">        ListNode *pNodeA = headA, *pNodeB = headB;</span></span><br><span class="line"><span class="comment">        while(pNodeA)&#123;</span></span><br><span class="line"><span class="comment">            ++len_A;</span></span><br><span class="line"><span class="comment">            pNodeA = pNodeA-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while(pNodeB)&#123;</span></span><br><span class="line"><span class="comment">            ++len_B;</span></span><br><span class="line"><span class="comment">            pNodeB = pNodeB-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 较长的链表 先移动指针 假设 pNodeA 指向较长的链表</span></span><br><span class="line"><span class="comment">        if(len_A &gt; len_B)&#123;</span></span><br><span class="line"><span class="comment">            pNodeA = headA;</span></span><br><span class="line"><span class="comment">            pNodeB = headB;</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            pNodeA = headB;</span></span><br><span class="line"><span class="comment">            pNodeB = headA;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int k = abs(len_A - len_B);</span></span><br><span class="line"><span class="comment">        while(k--)&#123;</span></span><br><span class="line"><span class="comment">            pNodeA = pNodeA-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 现在指针所指链表后续是一样长 同步移动</span></span><br><span class="line"><span class="comment">        while(pNodeA &amp;&amp; pNodeB)&#123;</span></span><br><span class="line"><span class="comment">            if(pNodeA == pNodeB)</span></span><br><span class="line"><span class="comment">                return pNodeA;</span></span><br><span class="line"><span class="comment">            pNodeA = pNodeA-&gt;next;</span></span><br><span class="line"><span class="comment">            pNodeB = pNodeB-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-五层模型</title>
    <url>/net/%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<img src="https://i.loli.net/2020/10/25/oMO4v7KFi2n9Psh.png" alt="TCP/IP协议族族中不同层次的协议.png" style="zoom: 67%;" />

<img src="https://i.loli.net/2020/10/25/3PAhBF6RnzjJGO7.png" alt="协议封装过程.png" style="zoom:67%;" />

<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul>
<li><strong>频分复用</strong>：所有用户在同样的时间占用不同的带宽资源</li>
<li><strong>时分复用</strong>：所有用户是在不同的时间占用相同的频带宽度</li>
<li>波分复用：光的频分复用</li>
</ul>
<p><strong>集线器</strong>：工作在物理层，<strong>简单的转发比特，不进行碰撞检测</strong>。不同鹏颛臾使用不同的速率则不能使用集线器互连。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>主要信道：<strong>点对点信道</strong> 、<strong>广播信道</strong> </p>
<p>三个基本问题：<strong>封装成帧</strong>、<strong>透明传输</strong>、<strong>差错检测（循环冗余检验CRC）</strong> </p>
<p>以太网帧不能小于<strong>64B</strong>，以太网的端到端往返时间称为<strong>争用期</strong>（碰撞窗口），凡是长度小于64字节的帧都是由于冲突而异常终止的无效帧。</p>
<p>数据链路层设备：</p>
<ul>
<li><p><strong>适配器</strong>：即”网卡“。串并转换、数据转存、安装设备驱动、实现以太网协。议。</p>
</li>
<li><p><strong>网桥</strong></p>
<ul>
<li>学习源地址</li>
<li>过滤同网端帧</li>
<li>转发异网端帧</li>
<li>扩散未知帧</li>
</ul>
</li>
<li><p>以太网交换机：实质就是多借口的<strong>网桥</strong>，能<strong>隔离碰撞域</strong>。</p>
<p><strong>广播风暴</strong>：一个数据帧或包被传输到本地网段 (由广播域定义)上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪。</p>
<p>生成树协议STP：阻塞一个或多个冗余端口。</p>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层向上只提供更<strong>简单灵活的、无连接的、尽最大努力交付</strong>的数据报服务。网络层不提供服务质量的承诺。</p>
<ul>
<li><p><strong>IP协议</strong></p>
<img src="https://i.loli.net/2020/10/25/mngxjNyYv74If6z.png" alt="IP数据报格式.png" style="zoom: 67%;" />
</li>
<li><p><strong>地址解析协议 ARP</strong></p>
</li>
<li><p><strong>逆地址解析协议 RARP</strong></p>
</li>
<li><p><strong>网际控制报文协议 ICMP</strong></p>
</li>
<li><p><strong>网际组管理协议 IGMP</strong></p>
</li>
<li><p>划分子网</p>
</li>
<li><p>路由选择协议</p>
<ul>
<li><strong>内部网关协议 RIP</strong></li>
<li><strong>内部网关协议 OSPF</strong></li>
<li>外部网关协议 BGP</li>
</ul>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>运输层向它上面的应用层提供<strong>通信服务</strong>。<strong>通信的真正端点并不是主机而是主机中的进程</strong>。</p>
<p>两种运输协议：<strong>面向连接的TCP</strong> 和 <strong>无连接的UDP</strong>。</p>
<ul>
<li><p><strong>用户数据报协议 UDP</strong>：无连接、尽最大努力交付、面向报文</p>
<ul>
<li><p>报文数据格式</p>
<img src="https://i.loli.net/2020/10/25/t8jmJIhCkTABOzu.png" alt="UDP用户数据报的首部和伪首部.png" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p><strong>传输控制协议 TCP</strong>：面向连接、只能点到点、全双工通信、面向字节流</p>
<ul>
<li><p>报文数据格式</p>
<img src="https://i.loli.net/2020/10/25/MP8xVwous3nap7j.png" alt="TCP报文段的首部格式.png" style="zoom:67%;" />
</li>
<li><p>TCP可靠传输的实现：以字节为单位的滑动窗口、超时重传</p>
</li>
<li><p>TCP流量控制：流量控制就是让发送方发送速率不要太快，要让接收方来得及接收，发送窗口不超过接收窗口。</p>
<ul>
<li>滑动窗口</li>
</ul>
</li>
<li><p>TCP拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不至于过载。判断网络拥塞的依据就是出现了超时。</p>
<blockquote>
<p><a href="https://blog.csdn.net/sicofield/article/details/9708383">TCP的拥塞控制</a> </p>
</blockquote>
<ul>
<li><p><strong>慢开始</strong>：有小到大逐渐增大发送窗口。需设置慢开始门限。</p>
</li>
<li><p><strong>拥塞避免</strong>：让拥塞窗口 cwnd 缓慢地增大，按线性规律增长，使得网络比较不容易出现拥塞。</p>
</li>
<li><p><strong>快重传</strong>：要求接收方立即发送确认，即使收到失序的报文要立即发出对已收到报文段的重复确认。</p>
<p>eg：假定没有收到M3，但却收到了M4，必须理解发送对M2的重复确认</p>
</li>
<li><p><strong>快恢复</strong>：发送方知道只是丢失了个别报文，将调整慢开始门限为 cwnd/2 ，并开始执行拥塞避免算法。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可靠传输原理</strong></p>
<ul>
<li>停止等待协议：每发送完一个分组就停止发送，等到对方确认，收到确认再发下一个分组。确认和重传机制，可以在不可靠的传输网络上实现可靠通信。</li>
<li>连续ARP协议：发送方收到一个确认，发送窗口就向前滑动一个分组的位置；接收方不必对每个分组发送确认，对按序到达的最后一个分组发送确认。</li>
</ul>
</li>
<li><p><strong>TCP连接管理</strong></p>
<ul>
<li><p><strong>“三次握手”</strong>：TCP的连接建立</p>
<img src="https://i.loli.net/2020/10/25/BUtYroWNihSe6V7.png" alt="TCP三次握手.png" style="zoom:50%;" />
</li>
<li><p><strong>“四次握手”</strong>：TCP的连接释放</p>
<img src="https://i.loli.net/2020/10/25/A7n6OUMl8YfCpjg.png" alt="TCP四次握手.png" style="zoom:50%;" />
</li>
<li><p><strong>TCP的有限状态机</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>域名系统 DNS</li>
<li>动态主机配置协议 DHCP</li>
<li>超文本传送协议 HTTP</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>“三次握手”与“四次挥手”</title>
    <url>/net/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E2%80%9D%E4%B8%8E%E2%80%9C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D/</url>
    <content><![CDATA[<p>TCP是面向连接的协议。运输连接是用来传送TCP报文的。运输链接就有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>、<strong>连接释放</strong>。</p>
<h2 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h2><p>TCP建立连接过程中的三个重要问题：</p>
<ol>
<li>要使每一方能够确知对方的存在；</li>
<li>要允许双方协商一些参数（eg：最大窗口值）；</li>
<li>能够对运输实体资源（eg：缓存大小、连接表中的项目等）进行分配。</li>
</ol>
<p>TCP连接采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户端</strong>。被动等待连接建立的应用程序叫做<strong>服务器</strong>。</p>
<img src="https://i.loli.net/2020/10/25/BUtYroWNihSe6V7.png" alt="TCP三次握手.png" style="zoom: 67%;" />

<p>一开始，服务器进程创建<strong>传输控制块 TCB</strong>，准备接受客户进程的连接请求。然后服务器进程处于 <font color=red><strong>LISTEN</strong></font> 状态，等待客户的连接请求。</p>
<ol>
<li><p>客户进程创建<strong>传输控制块 TCB</strong>。向服务器进程发送连接请求报文段（同步位 <code>SYN=1</code> ，同时选择一个随机的初始序号值 <code>seq=x</code> ），客户进程进入  <font color=blue><strong>SYN_SENT</strong></font> 状态；</p>
<blockquote>
<p><strong>序号值</strong>是用来标记TCP数据流中的每一个字节的。<strong>同步报文段</strong>，不携带数据，但仍要<strong>消耗掉一个序号</strong>。</p>
</blockquote>
</li>
<li><p>服务器进程接收到连接请求报文段，如果同意建立连接，则向客户进程发送确认（同步位 <code>SYN=1</code>，确认位 <code>ACK=1</code>，确认号 <code>ack=x+1</code>，同时也为自己选择一个初始序号 <code>seq=y</code>），服务器进程进入  <font color=red><strong>SYN_RCVD</strong></font> 状态；</p>
<blockquote>
<p>同步报文段，不携带数据，但仍要<strong>消耗掉一个序号</strong>。报文段的数据可理解为：<strong>我已收到 x，期待收到 x+1</strong>。</p>
</blockquote>
</li>
<li><p>客户进程收到确认后，还要向服务器进程发送确认，客户进程进入  <font color=blue><strong>ESTABLISED</strong></font> 状态。</p>
<blockquote>
<p> 如果不携带数据则不消耗序号，即不带序号。</p>
</blockquote>
</li>
<li><p>服务器进程收到确认后，也进入  <font color=red><strong>ESTABLISED</strong></font> 状态。TCP连接建立，接下来进行数据传送。</p>
</li>
</ol>
<p>TCP建立连接的过程，有三个报文段，故该过程叫做<strong>三报文握手</strong>，即<strong>“三次握手”</strong>。如果将服务器进程确认报文段拆分成两个报文段：1、确认报文段（<code>ACK=1, ack=x+1</code>），2、同步报文（<code>SYN=1, seq=1</code>）。这样的过程就变成了<strong>四报文握手</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo tcpdump -i eth0 -nt <span class="string">&#x27;(src 172.20.12.30 and dst 172.20.12.27) or (src 172.20.12.27 and dst 172.20.12.30)&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、同步报文段：SYN=1, seq=3411381857 </span></span><br><span class="line">IP 172.20.12.27.38012 &gt; 172.20.12.30.80: Flags [S], seq 3411381857, win 29200, options [mss 1460,sackOK,TS val 3763862309 ecr 0,nop,wscale 7], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、同步报文段：SYN=1, seq=3063678231, ack=3411381858</span></span><br><span class="line">IP 172.20.12.30.80 &gt; 172.20.12.27.38012: Flags [S.], seq 3063678231, ack 3411381858, win 28960, options [mss 1460,sackOK,TS val 2338707997 ecr 3763862309,nop,wscale 7], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、确认报文段：ACK=1, ack=1   没有携带数据不消耗序号，没-S参数，ack值是相对偏移值</span></span><br><span class="line">IP 172.20.12.27.38012 &gt; 172.20.12.30.80: Flags [.], ack 1, win 229, options [nop,nop,TS val 3763862310 ecr 2338707997], length 0</span><br></pre></td></tr></table></figure>

<h2 id="TCP释放连接"><a href="#TCP释放连接" class="headerlink" title="TCP释放连接"></a>TCP释放连接</h2><p><strong>释放连接时中断端可以是客户端，也可以是服务器端</strong>。假设是客户进程发起中断连接请求。</p>
<img src="https://i.loli.net/2020/10/25/A7n6OUMl8YfCpjg.png" alt="TCP四次挥手.png" style="zoom:67%;" />

<p>一开始，客户进程和服务器进程均处于 <font color=green><strong>ESTABLISED</strong></font> 状态。</p>
<ol>
<li><p>客户进程向服务器进程发出TCP连接释放报文段（终止控制位 <code>FIN=1</code>，序号 <code>seq=u</code>），并停止再发送数据。客户进程进入 <font color=blue><strong>FIN-WAIT-1</strong></font> 状态。</p>
<blockquote>
<p>不携带数据，但也要消耗掉一个序号。</p>
</blockquote>
</li>
<li><p>服务器进程收到连接释放报文段后，向客户进程发送确认（<code>ACK=1, ack=u+1, seq=v</code>）。服务器进程进入 <font color=red><strong>CLOSE-WAIT</strong></font> 状态，**<em>半关闭**</em>状态。此时，服务器进程向客户进程发送还未传输完的数据。</p>
<blockquote>
<p>客户进程没有数据要发送，但若服务器进程发送数据，客户进程仍要接收。</p>
<p>实际抓包的数据：<code>ACK=1, ack=u</code>。</p>
</blockquote>
</li>
<li><p>客户进程收到确认后，进入 <font color=blue><strong>FIN-WAIT-2</strong></font> 状态，等待服务器进程发出释放连接请求报文段。</p>
</li>
<li><p>若服务器进程已经没有要向客户进程发送的数据，其通知TCP释放连接。向客户进程发送释放连接请求（<code>FIN=1, ACK=1, ack=u+1, seq=w</code>）。服务器进程进入 <font color=red><strong>LAST-ACK</strong></font> 状态，等待客户进程的确认。</p>
</li>
<li><p>客户进程收到服务器进程的释放连接请求报文，对其进行确认（<code>ACK=1, ack=w+1, seq=u+1</code>）。进入 <font color=blue><strong>TIME-WAIT</strong></font> 状态，等待 **<code>2MSL</code>**，客户进程TCP连接最终关闭。</p>
</li>
<li><p>服务器进程收到客户进程的确认，进入 <font color=red><strong>CLOSED</strong></font> 状态。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、结束报文段：FIN=1, ACK=1, seq=484, ack=5</span></span><br><span class="line">IP 172.20.12.30.80 &gt; 172.20.12.27.38728: Flags [F.], seq 484, ack 5, win 227, options [nop,nop,TS val 2340566655 ecr 3765720984], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、确认报文段：ACK=1, ack=484  注意：此处ack值没有+1 </span></span><br><span class="line">IP 172.20.12.27.38728 &gt; 172.20.12.30.80: Flags [.], ack 484, win 237, options [nop,nop,TS val 3765720984 ecr 2340566655], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、结束报文段：FIN=1, ACK=1, seq=5, ack=485  此处ack值+1了</span></span><br><span class="line">IP 172.20.12.27.38728 &gt; 172.20.12.30.80: Flags [F.], seq 5, ack 485, win 237, options [nop,nop,TS val 3765720984 ecr 2340566655], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、确认报文段：ACK=1, ack=5</span></span><br><span class="line">IP 172.20.12.30.80 &gt; 172.20.12.27.38728: Flags [.], ack 6, win 227, options [nop,nop,TS val 2340566656 ecr 3765720984], length 0</span><br></pre></td></tr></table></figure>

<h2 id="问题注意"><a href="#问题注意" class="headerlink" title="问题注意"></a>问题注意</h2><p><strong>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>
<p>因为当服务进程收到客户进程的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，<strong>当服务进程收到FIN报文时，很可能并不会立即关闭SOCKET</strong>，所以只能先回复一个ACK报文，告诉客户进程，”你发的FIN报文我收到了”。只有等到我服务进程所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。</p>
<p><strong>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p>
<ol>
<li><p>保证客户进程发送的最后一个 ACK 报文能够到达服务进程。</p>
</li>
<li><p>防止“已失效的连接请求报文段”出现在本连接中。</p>
<blockquote>
<p>客户端发送最后一个ACK报文后，再经过2MSL，本连接的的时间内所产生的所有报文段都从网络中消失。这样下一个新的连接中不会出现就连接的请求报文段。</p>
</blockquote>
</li>
</ol>
<p><strong>【问题3】建立连接为什么需要第三个确认报文（为什么客户进程还要发送一次确认）？</strong></p>
<p>为了防止已失效的连接请求报文段突然又传到服务器进程（被动连接端），因而产生错误。</p>
<blockquote>
<p>客户进程发出的连接请求，未收到回复确认，于是<strong>重传请求报文段</strong>。后来建立连接，数据传输完毕后释放了连接，此时延迟的失效报文段到达服务器进程，<strong>被误以为一次新的连接请求</strong>。于是服务器进程发出确认报文段，同一建立连接。假定没有第三个报文段进行确认，新的连接就建立了。白白浪费资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s Weave Scope 部署配置</title>
    <url>/other/k8s%20weave%20scope%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-Weave-Scope-安装"><a href="#1-Weave-Scope-安装" class="headerlink" title="1. Weave Scope 安装"></a>1. Weave Scope 安装</h2><p>在 master 上通过以下命令安装Weave Scope：<br>kubectl apply -f “<a href="https://cloud.weave.works/k8s/scope.yaml?k8s-version=$">https://cloud.weave.works/k8s/scope.yaml?k8s-version=$</a>(kubectl version | base64 | tr -d ‘\n’)”<br>运行后会发现已经起来几个pod:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f &quot;https://cloud.weave.works/k8s/scope.yaml?k8s-version=$(kubectl version | base64 | tr -d &#x27;\n&#x27;)&quot;</span><br><span class="line">namespace/weave created</span><br><span class="line">serviceaccount/weave-scope created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/weave-scope created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/weave-scope created</span><br><span class="line">deployment.apps/weave-scope-app created</span><br><span class="line">service/weave-scope-app created</span><br><span class="line">deployment.apps/weave-scope-cluster-agent created</span><br><span class="line">daemonset.apps/weave-scope-agent created</span><br><span class="line">[root@k8s-master ~]# kubectl get pod -n weave  -o wide</span><br><span class="line">NAME                                        READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">weave-scope-agent-8zzq5                     1/1     Running   0          11s   192.168.1.92    k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-agent-jhcff                     1/1     Running   0          11s   192.168.1.85    k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-agent-qs45b                     1/1     Running   0          11s   192.168.1.133   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-app-848cd4d8b5-4rlnd            1/1     Running   0          11s   10.244.1.4      k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-cluster-agent-b4f45797c-7srs9   1/1     Running   0          11s   10.244.2.4      k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@k8s-master ~]# kubectl get service -n weave -o wide</span><br><span class="line">NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">weave-scope-app   ClusterIP   10.1.31.163   &lt;none&gt;        80/TCP    57s   app=weave-scope,name=weave-scope-app,weave-cloud-component=scope,weave-scope-component=app</span><br></pre></td></tr></table></figure>

<h2 id="2-访问配置"><a href="#2-访问配置" class="headerlink" title="2. 访问配置"></a>2. 访问配置</h2><p><code>k8s-service-type</code>-Kubernetes服务类型（用于以独立模式运行Scope），可以是 <code>LoadBalancer</code>或<code>NodePort</code>，默认情况下未指定（仅内部访问）<br>使用<kbd>kubectl edit</kbd> 方式修改 nodeport 的端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 首先 get svc 查看服务</span></span></span><br><span class="line">[root@k8s-master ~]# kubectl get svc --all-namespaces</span><br><span class="line">NAMESPACE     NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default       kubernetes        ClusterIP   10.1.0.1      &lt;none&gt;        443/TCP                  28h</span><br><span class="line">kube-system   kube-dns          ClusterIP   10.1.0.10     &lt;none&gt;        53/UDP,53/TCP,9153/TCP   28h</span><br><span class="line">weave         weave-scope-app   ClusterIP   10.1.31.163   &lt;none&gt;        80/TCP                   4m4s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 weave 服务</span></span></span><br><span class="line">[root@k8s-master ~]# kubectl edit svc/weave-scope-app -n weave</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 以下修改标记</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">spec:</span></span><br><span class="line"> clusterIP: 10.1.31.163</span><br><span class="line"> ports:</span><br><span class="line"> - name: app</span><br><span class="line">   nodePort: 30001        ## 新增 映射外网访问端口 30000-327627</span><br><span class="line">   port: 80        ## 默认 80 不能修改，修改后无法获取节点信息</span><br><span class="line">   protocol: TCP</span><br><span class="line">   targetPort: 4040</span><br><span class="line"> selector:</span><br><span class="line">   app: weave-scope</span><br><span class="line">   name: weave-scope-app</span><br><span class="line">   weave-cloud-component: scope</span><br><span class="line">   weave-scope-component: app</span><br><span class="line"> sessionAffinity: None</span><br><span class="line"> type: NodePort        ## 修改为 NodePort</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">status:</span></span><br><span class="line"> loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-web-浏览"><a href="#3-web-浏览" class="headerlink" title="3. web 浏览"></a>3. web 浏览</h2><p>在能访问 master 主机网络的主机上浏览器访问 <font color=red>master ip:nodePort</font>，如：<a href="http://192.168.1.86:30001/">http://192.168.1.86:30001/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>centos-k8s1.16.2集群安装部署</title>
    <url>/other/centos7-k8s1.16.2%20%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-centos-7-配置"><a href="#1-centos-7-配置" class="headerlink" title="1. centos 7 配置"></a>1. centos 7 配置</h2><p>关闭防火墙、关闭selinux、更新源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">防火墙</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭Selinux</span></span><br><span class="line">    sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或者</span></span></span><br><span class="line">    /etc/selinux/config</span><br><span class="line">    #将其中的 SELINUX=*处修改为如下</span><br><span class="line">    SELINUX=disabled</span><br><span class="line"><span class="meta">#</span><span class="bash">重启服务器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">运行命令getenforce 确保 selinux 为<span class="built_in">disable</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装wget</span></span><br><span class="line">yum install -y wget</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"><span class="meta">#</span><span class="bash">更新 源</span></span><br><span class="line">yum upgrade</span><br></pre></td></tr></table></figure>

<h2 id="2-host配置"><a href="#2-host配置" class="headerlink" title="2. host配置"></a>2. host配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash">k8s nodes</span></span><br><span class="line">192.169.1.86    k8s-master</span><br><span class="line">192.168.1.87    k8s-node1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/hostname</span></span><br><span class="line">结点名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建-etc-sysctl-d-k8s-conf文件"><a href="#3-创建-etc-sysctl-d-k8s-conf文件" class="headerlink" title="3. 创建/etc/sysctl.d/k8s.conf文件"></a>3. 创建/etc/sysctl.d/k8s.conf文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改内核参数</span></span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">执行sysctl -p /etc/sysctl.d/k8s.conf生效（sysctl --system）</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果有如下报错:</span></span><br><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</span><br><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory</span><br><span class="line"><span class="meta">#</span><span class="bash">解决方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装bridge-util软件，加载bridge模块，加载br_netfilter模块</span></span><br><span class="line">yum install -y bridge-utils.x86_64</span><br><span class="line">modprobe bridge</span><br><span class="line">modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭swap</span></span><br><span class="line">swapoff -a</span><br><span class="line">echo &quot;vm.swappiness=0&quot; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">使生效</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>

<h2 id="4-安装软件源配置"><a href="#4-安装软件源配置" class="headerlink" title="4. 安装软件源配置"></a>4. 安装软件源配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置k8s软件源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo </span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="5-安装docker"><a href="#5-安装docker" class="headerlink" title="5. 安装docker"></a>5. 安装docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#先校正时间 否则 无法运行docker！！！！</span></span></span><br><span class="line">    # 1.安装ntpdate工具</span><br><span class="line">    sudo yum -y install ntp ntpdate</span><br><span class="line">    # 2.设置系统时间与网络时间同步</span><br><span class="line">    sudo ntpdate cn.pool.ntp.org</span><br><span class="line">    # 3.将系统时间写入硬件时间</span><br><span class="line">    sudo hwclock --systohc</span><br><span class="line">    # 4.查看系统时间</span><br><span class="line">    timedatectl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装docker</span></span><br><span class="line">yum install -y docker-io</span><br><span class="line"><span class="meta">#</span><span class="bash">启动docker并设置开机启动</span></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="6-安装kubernetes—-指定版本（1-16-2）"><a href="#6-安装kubernetes—-指定版本（1-16-2）" class="headerlink" title="6. 安装kubernetes—-指定版本（1.16.2）"></a>6. 安装kubernetes—-指定版本（1.16.2）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">查看软件包版本</span></span><br><span class="line">yum list --showduplicates | grep &#x27;kubeadm\|kubectl\|kubelet&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装软件 指定版本</span></span><br><span class="line">yum install -y kubelet-1.16.2 kubeadm-1.16.2 kubectl-1.16.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动服务并设置开机自启</span></span><br><span class="line">systemctl start kubelet &amp;&amp; systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<h2 id="7-修改配置"><a href="#7-修改配置" class="headerlink" title="7. 修改配置"></a>7. 修改配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">kubernetes 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/usr/bin 目录下 执行以下操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># kubelet  kubeadm  kubectl更新权限</span></span></span><br><span class="line">cd /usr/bin &amp;&amp; chmod a+x kubelet  kubeadm  kubectl</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">docker 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#编辑 /lib/systemd/system/docker.service 在[Service] 下添加下面一行</span></span></span><br><span class="line">ExecStartPost=/sbin/iptables -P FORWARD ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重启docker</span></span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="8-拉取镜像并tag"><a href="#8-拉取镜像并tag" class="headerlink" title="8. 拉取镜像并tag"></a>8. 拉取镜像并tag</h2><p>由于镜像默认从国外网站拉取，被墙，故自行从国内云拉取。<br>运行 <kbd>kubeadm config   images  list</kbd> 查看所需要的镜像以及版本号，再从阿里云拉取这些镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master bin]# kubeadm config   images  list</span><br><span class="line">W0108 19:53:17.464386   10103 version.go:101] could not fetch a Kubernetes version from the internet: unable to get URL &quot;https://dl.k8s.io/release/stable-1.txt&quot;: Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br><span class="line">W0108 19:53:17.464460   10103 version.go:102] falling back to the local client version: v1.16.2</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<p>拉取对应镜像<kbd>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/镜像名:版本号</kbd></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 对应上面版本号</span></span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.3.15-0</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<p>tag镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.16.2 k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.16.2 k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.16.2 k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.16.2 k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.3.15-0 k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.2 k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<h2 id="9-使用kubeadm-init初始化集群（仅master）"><a href="#9-使用kubeadm-init初始化集群（仅master）" class="headerlink" title="9. 使用kubeadm init初始化集群（仅master）"></a>9. 使用kubeadm init初始化集群（仅master）</h2><p><strong><em>详细参数查询地址：</em></strong> <a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--apiserver-advertise-address string</span><br><span class="line">API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。</span><br><span class="line">--image-repository string     默认值：&quot;k8s.gcr.io&quot;</span><br><span class="line">选择用于拉取控制平面镜像的容器仓库</span><br><span class="line">--kubernetes-version string     默认值：&quot;stable-1&quot;</span><br><span class="line">为控制平面选择一个特定的 Kubernetes 版本。</span><br><span class="line">--service-cidr string     默认值：&quot;10.96.0.0/12&quot;</span><br><span class="line">为服务的虚拟 IP 地址另外指定 IP 地址段</span><br><span class="line">--pod-network-cidr string</span><br><span class="line">指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#部署Kubernetes Master</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#在192.168.1.86（Master）执行</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</span></span></span><br><span class="line"></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.1.86 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.16.2 \</span><br><span class="line">--service-cidr=10.1.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化成功，显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.86:6443 --token pwwmps.9cds2s34wlpiyznv \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a3220f1d2384fe5230cad2302a4ac1f233b03ea24c19c165adb5824f9c358336</span><br></pre></td></tr></table></figure>

<p>然后在master执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 等待命令执行完毕后执行如下命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在master上执行以下命令  </span></span></span><br><span class="line">mkdir -p $HOME/.kube  </span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  </span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#安装flannel网络组件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在master上执行以下命令</span></span></span><br><span class="line">kubectl apply -f  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 若出现无法下载安装flannel组件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看结点</span></span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看集群状态</span></span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能会出现node notready的情况 在master执行</span></span><br><span class="line">kubectl get pod --all-namespaces -o wide</span><br></pre></td></tr></table></figure>
<p><strong><em>Master结点初始化成功，状态可能是NotReady，要等一段时间</em></strong><br>如果初始化不成功，可以参考博文：<a href="https://www.jianshu.com/p/f53650a85131">https://www.jianshu.com/p/f53650a85131</a> 进行修复</p>
<h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><ol>
<li>由于没安装 <strong>flannel</strong> 组件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   coredns-58cc8c89f4-dwg8r             0/1     Pending   0          24m   &lt;none&gt;         &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-58cc8c89f4-jx7cw             0/1     Pending   0          24m   &lt;none&gt;         &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>无法直接从官网下载 flannel 组件安装 yml 文件</p>
<p>参考：<a href="https://blog.csdn.net/fuck487/article/details/102783300">https://blog.csdn.net/fuck487/article/details/102783300</a></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解决方法：自行创建 或 ftp 传输本地 kube-flannel.yml</span></span></span><br><span class="line">vi $HOME/kube-flannel.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># </span></span></span><br><span class="line"><span class="meta">    #</span><span class="bash"><span class="comment"># 粘贴内容 kube-flannel.yml </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装 </span></span></span><br><span class="line">[root@k8s-master ~]# kubectl apply -f ./kube-flannel.yml</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm created</span><br><span class="line">daemonset.apps/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.apps/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure>



<h2 id="10-补充命令"><a href="#10-补充命令" class="headerlink" title="10. 补充命令"></a>10. 补充命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 然后在 master 和 node 上都执行此命令</span></span></span><br><span class="line">[root@k8s-master bin]# modprobe ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh</span><br><span class="line">modprobe: ERROR: could not insert &#x27;ip_vs&#x27;: Unknown symbol in module, or unknown parameter (see dmesg)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 删去 ip_vs</span></span></span><br><span class="line">[root@k8s-master bin]# modprobe ip_vs_rr ip_vs_wrr ip_vs_sh</span><br><span class="line">modprobe: ERROR: could not insert &#x27;ip_vs_rr&#x27;: Unknown symbol in module, or unknown parameter (see dmesg)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在执行</span></span></span><br><span class="line">[root@k8s-master bin]# modprobe ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看确保内核开启了ipvs模块</span></span></span><br><span class="line">[root@k8s-master bin]# lsmod|grep ip_vs</span><br><span class="line">ip_vs                 145497  0 </span><br><span class="line">nf_conntrack          139224  7 ip_vs,nf_nat,nf_nat_ipv4,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  4 xfs,ip_vs,nf_nat,nf_conntrack</span><br></pre></td></tr></table></figure>

<h2 id="11-添加节点"><a href="#11-添加节点" class="headerlink" title="11. 添加节点"></a>11. 添加节点</h2><h3 id="获取-kubeadm-join-命令"><a href="#获取-kubeadm-join-命令" class="headerlink" title="获取 kubeadm join 命令"></a>获取 kubeadm join 命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获得添加结点命令 master上执行  kubeadm token create --<span class="built_in">print</span>-join-command</span></span><br><span class="line">[root@k8s-master ~]# kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.1.86:6443 --token a1qmdh.d79exiuqbzdr616o     --discovery-token-ca-cert-hash sha256:a3220f1d2384fe5230cad2302a4ac1f233b03ea24c19c165adb5824f9c358336</span><br></pre></td></tr></table></figure>

<h3 id="node节点上执行-join-添加结点"><a href="#node节点上执行-join-添加结点" class="headerlink" title="node节点上执行 join 添加结点"></a>node节点上执行 join 添加结点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 bin]# kubeadm join 192.168.1.86:6443 --token otjfah.zta4yo0bexibbj52     --discovery-token-ca-cert-hash sha256:60535ebe96b6a4cceab70d551f2b2b507a3641c3dc421469320b915e01377e5c</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;</span><br><span class="line">[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.16&quot; ConfigMap in the kube-system namespace</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>

<h2 id="12-删除节点"><a href="#12-删除节点" class="headerlink" title="12. 删除节点"></a>12. 删除节点</h2><p>master节点上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-master   Ready    master   3h9m   v1.16.2</span><br><span class="line">k8s-node1    Ready    &lt;none&gt;   116s   v1.16.2</span><br><span class="line">[root@k8s-master ~]# kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">node/k8s-node1 cordoned</span><br><span class="line">WARNING: ignoring DaemonSet-managed Pods: kube-system/kube-flannel-ds-amd64-gmq2b, kube-system/kube-proxy-q9ppx</span><br><span class="line">node/k8s-node1 drained</span><br><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS                     ROLES    AGE     VERSION</span><br><span class="line">k8s-master   Ready                      master   3h10m   v1.16.2</span><br><span class="line">k8s-node1    Ready,SchedulingDisabled   &lt;none&gt;   2m43s   v1.16.2</span><br><span class="line">[root@k8s-master ~]# kubectl delete node k8s-node1</span><br><span class="line">node &quot;k8s-node1&quot; deleted</span><br><span class="line">[root@k8s-master ~]# </span><br></pre></td></tr></table></figure>

<p>删除结点(k8s-node1)上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubeadm reset</span><br><span class="line">[reset] WARNING: Changes made to this host by &#x27;kubeadm init&#x27; or &#x27;kubeadm join&#x27; will be reverted.</span><br><span class="line">[reset] Are you sure you want to proceed? [y/N]: y    ## y 确认</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">W0109 13:39:15.848313   79539 removeetcdmember.go:79] [reset] No kubeadm config, using etcd pod spec to get data directory</span><br><span class="line">[reset] No etcd config found. Assuming external etcd</span><br><span class="line">[reset] Please, manually reset etcd to prevent further issues</span><br><span class="line">[reset] Stopping the kubelet service</span><br><span class="line">[reset] Unmounting mounted directories in &quot;/var/lib/kubelet&quot;</span><br><span class="line">[reset] Deleting contents of config directories: [/etc/kubernetes/manifests /etc/kubernetes/pki]</span><br><span class="line">[reset] Deleting files: [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf]</span><br><span class="line">[reset] Deleting contents of stateful directories: [/var/lib/kubelet /etc/cni/net.d /var/lib/dockershim /var/run/kubernetes /var/lib/cni]</span><br><span class="line"></span><br><span class="line">The reset process does not reset or clean up iptables rules or IPVS tables.</span><br><span class="line">If you wish to reset iptables, you must do so manually by using the &quot;iptables&quot; command.</span><br><span class="line"></span><br><span class="line">If your cluster was setup to utilize IPVS, run ipvsadm --clear (or similar)</span><br><span class="line">to reset your system&#x27;s IPVS tables.</span><br><span class="line"></span><br><span class="line">The reset process does not clean your kubeconfig files and you must remove them manually.</span><br><span class="line">Please, check the contents of the $HOME/.kube/config file.</span><br></pre></td></tr></table></figure>



<h2 id="附录：查询命令"><a href="#附录：查询命令" class="headerlink" title="附录：查询命令"></a>附录：查询命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看结点 在master执行</span></span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看集群状态 在master执行</span></span></span><br><span class="line">kubectl get cs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能会出现node notready的情况 在master执行</span></span><br><span class="line">kubectl get pod --all-namespaces -o wide</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix同步方式</title>
    <url>/UNP/Unix%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>【<strong>重要的一句话</strong>】<font color=red>进程终止时系统<strong>不会自动释放</strong>所持有的锁，<strong>互斥锁</strong>、<strong>读写锁</strong>和<strong>Posix信号量</strong>。进程终止时内核总是<strong>自动清理的唯一同步锁类型是fcntl记录锁</strong> </font>。进程终止时（无论自愿与否），内核会对其上仍然打开着的所有 <strong>有名信号量</strong> <strong>自动执行</strong> <code>sem_close</code> 信号量关闭操作（<strong>不是释放</strong>）。</p>
<p>System V信号量，应用程序可以选择进程终止时内核是否自动清理某个信号量。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p><strong>同步</strong>（英语：synchronization），指在一个系统中所发生的事件（event）之间进行协调，在时间上出现一致性与统一化的现象。</p>
<p>为允许在线程或进程间共享数据，同步通常是必需的。本文涉及到的同步方式有：</p>
<ul>
<li>互斥锁</li>
<li>互斥锁与条件变量</li>
<li>读写锁</li>
<li>记录锁</li>
<li>Posix 信号量</li>
</ul>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁指代相互排斥，是最基本的同步形式。互斥锁用于保护 <em>临界区</em> ，以确保任何时刻只有一个线程（或进程）在执行其中的代码。伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lock_mutex(mutex);        <span class="comment">// 1.获取互斥锁</span></span><br><span class="line">do_something();            <span class="comment">// 2.访问临界区</span></span><br><span class="line">unlock_mutex(mutex);    <span class="comment">// 3.释放互斥锁</span></span><br></pre></td></tr></table></figure>

<p>尽管我们说互斥锁保护的是临界区，实际上保护的是在临界区中的被操作的数据，也就是共享数据。</p>
<p>互斥锁是 <font color=red><strong>协作性锁</strong></font> 。也就是说操作流程应该是在实际操作前获取互斥锁，但是没有办法防止某个线程（或进程）不先获取该互斥锁就操作数据。</p>
<h3 id="初始化互斥锁"><a href="#初始化互斥锁" class="headerlink" title="初始化互斥锁"></a>初始化互斥锁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态分配的，或者分配在共享内存区中的互斥锁必须使用 pthread_mutex_init 初始化。静态分配的可以初始化为常量 <code>PTHREAD_MUTEX_INITIALIZER</code> 。</li>
<li><code>attr = NULL</code> ，则使用默认属性。</li>
</ul>
<h3 id="销毁互斥锁"><a href="#销毁互斥锁" class="headerlink" title="销毁互斥锁"></a>销毁互斥锁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞，直到互斥锁解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 非阻塞，立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>阻塞方式，若已有另外进程对互斥锁上锁，将阻塞到该互斥锁解锁</li>
<li>非阻塞方式，立即返回，若已有另外进程对互斥锁上锁，返回 EBUSY 错误</li>
</ul>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁属性"><a href="#互斥锁属性" class="headerlink" title="互斥锁属性"></a>互斥锁属性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 获取共享属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="comment">// 设置共享属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PTHREAD_PROCESS_SHARED</code> ，指定互斥锁在不同进程间共享</li>
<li><code>PTHREAD_PROCESS_PRIVATE</code>，指定互斥锁只能在单个进程内不同线程间共享（默认）</li>
</ul>
<h2 id="互斥锁与条件变量"><a href="#互斥锁与条件变量" class="headerlink" title="互斥锁与条件变量"></a>互斥锁与条件变量</h2><p>当期待的条目未准备好时，消某线程持有锁阻塞等待，锁住整个临界区。这样的情况还可能造成死锁，这不是我们想要的。我们的期望是在线程等待其他条件的时候，释放已获得的互斥锁。这时条件变量就完美符合我们的要求。</p>
<p><strong>互斥锁用于上锁，条件变量则用户等待</strong>。伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lock_mutex(mutex);        <span class="comment">// 1.获取互斥锁</span></span><br><span class="line">wait(cond, mutex);        <span class="comment">// 2.等待条件</span></span><br><span class="line">do_something();            <span class="comment">// 3.访问临界区</span></span><br><span class="line">unlock_mutex(mutex);    <span class="comment">// 4.释放互斥锁</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化条件变量"><a href="#初始化条件变量" class="headerlink" title="初始化条件变量"></a>初始化条件变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态分配的，或者分配在共享内存区中的互斥锁必须使用 pthread_cond_init 初始化。静态分配的可以初始化为常量 <code>PTHREAD_COND_INITIALIZER</code> </li>
</ul>
<h3 id="销毁条件变量"><a href="#销毁条件变量" class="headerlink" title="销毁条件变量"></a>销毁条件变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若有线程等待，则返回 EBUSY 错误。</p>
<h3 id="等待条件成立"><a href="#等待条件成立" class="headerlink" title="等待条件成立"></a>等待条件成立</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">// 定时等待 允许设置阻塞时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span>    tv_sec;     <span class="comment">// 秒</span></span><br><span class="line">    <span class="keyword">long</span>    tv_nsec;    <span class="comment">// 纳秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个条件变量总是与一个互斥锁关联，当条件不满足时，阻塞等待条件变量满足，并释放已获得的该互斥锁（原子操作）</li>
<li>当被唤醒，函数返回时，解除阻塞并重新申请获取互斥锁</li>
<li><code>pthread_cond_timedwait</code> ，允许线程就阻塞设置一个时间限制，该限制为 <strong>绝对时间</strong> ，超时返回 ETIMEDOUT 错误</li>
<li>使用绝对时间的好处：如果函数过早返回，那么同一函数无须改变其时间参数的内容就能再次被调用。</li>
</ul>
<h3 id="告知条件满足"><a href="#告知条件满足" class="headerlink" title="告知条件满足"></a>告知条件满足</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 至少唤醒一个等待该条件的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒等待该条件的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pthread_cond_signal</code> 至少唤醒一个等待该条件的线程</li>
<li><code>pthread_cond_broadcast</code> 唤醒等待该条件的所有线程，会造成 ”<strong>惊群</strong>“。</li>
</ul>
<h3 id="条件变量属性设置"><a href="#条件变量属性设置" class="headerlink" title="条件变量属性设置"></a>条件变量属性设置</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 获取共享属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="comment">// 设置共享属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PTHREAD_PROCESS_SHARED</code> ，指定条件变量在不同进程间共享</li>
<li><code>PTHREAD_PROCESS_PRIVATE</code>，指定条件变量只能在单个进程内不同线程间共享（默认）</li>
</ul>
<h3 id="条件满足信号丢失问题"><a href="#条件满足信号丢失问题" class="headerlink" title="条件满足信号丢失问题"></a>条件满足信号丢失问题</h3><p>当条件满足，向一个条件变量发送信号时，若没有线程（或进程）等待该条件，则<strong>信号将会丢失</strong>。丢失和不再告知条件满足。</p>
<p>测试代码：<a href="https://github.com/JakeLin0fly/unp-code/blob/master/sync/cond_signal_ignore.cpp">cond_signal_ignore.cpp</a> </p>
<p>测试结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost sync]# ./signal_ignore </span><br><span class="line">主线程：子线程创建完毕</span><br><span class="line">主线程：获取到互斥锁</span><br><span class="line">主线程：发出 signal... </span><br><span class="line">主线程：释放掉互斥锁</span><br><span class="line">子线程：获取到互斥锁</span><br><span class="line">子线程：尝试获取条件变量...</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：<strong>读时共享，写时独占</strong>（写优先级高）</p>
<p>【读写锁】分配规则：<strong>共享-独占</strong> 上锁（读锁–共享锁，写锁–独占锁）</p>
<ol>
<li>若无线程持有给定的读写锁 <strong>写</strong> ，那么任意数目的线程可持有该读写锁 <strong>读</strong> ；</li>
<li>当且仅当无线程持有读写锁 <strong>读写</strong> 时，才分配读写锁用于 <strong>写</strong> 。</li>
</ol>
<p>基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态分配赋值常量 PTHREAD_RWLOCK_INITIALIZER</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>属性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PTHREAD_PROCESS_SHARED</code> ，在不同进程间共享</li>
<li><code>PTHREAD_PROCESS_PRIVATE</code>，只能在单个进程内不同线程间共享（默认）</li>
</ul>
<h2 id="fcntl记录上锁"><a href="#fcntl记录上锁" class="headerlink" title="fcntl记录上锁"></a>fcntl记录上锁</h2><p>假设我们现在要设置某个锁，以实现对文件访问的同步。上面谈到的锁作用于整个文件，粒度较大，我们期望这个锁只作用与文件的 <em>记录（即字节范围）</em> 上。</p>
<blockquote>
<p>Unix内核没有文件内的记录这一概念，但内核提供的上锁特性却用 记录上锁（record locking）这一术语来描述。</p>
<p>粒度：用于标记能够锁住的对象的大小。通常情况下粒度越小，允许同时使用的用户数就越多。Posix 记录上锁的粒度为单字节。</p>
</blockquote>
<h3 id="Posix-fcntl记录上锁"><a href="#Posix-fcntl记录上锁" class="headerlink" title="Posix fcntl记录上锁"></a>Posix fcntl记录上锁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *arg */</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> l_type;    <span class="comment">/* 锁类型: F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line">    <span class="keyword">short</span> l_whence;  <span class="comment">/* 偏移基准: SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_start;   <span class="comment">/* 相对偏移起始位置 */</span></span><br><span class="line">    <span class="keyword">off_t</span> l_len;     <span class="comment">/* 字节数  0--表示直到文件末尾*/</span></span><br><span class="line">    <span class="keyword">pid_t</span> l_pid;     <span class="comment">/* 进程ID（仅 F_GETLK） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>cmd 参数</strong>:</p>
<ul>
<li><p><code>F_SETLK</code> ：</p>
<ul>
<li><strong>获取</strong>（ <code>l_type = F_RDLCK</code> 或 <code>l_type = F_WRLCK</code> ）或<strong>释放</strong>（<code>l_type = F_UNLCK</code>）由 arg 指向的 flock 结构所描述的锁。</li>
<li><strong>不阻塞</strong>，若无法将该锁授予调用进程，则立即返回 EACCESS 或 EAGAIN 错误。</li>
</ul>
</li>
<li><p><code>F_SETLKW</code> ：<strong>阻塞</strong>，作用同 F_SETLK</p>
</li>
<li><p><code>F_GETLK</code> ：</p>
<ul>
<li>检查有 arg 指向的锁以确定是否有某个已存在的锁会妨碍将新锁授予调用进程<ul>
<li>当前没有锁，返回 l_type = F_UNLCK</li>
<li>已存在锁，返回锁信息，包括持有该锁的进程ID</li>
</ul>
</li>
<li>提供该命令的原因：当指向 F_SETLK 命令返回错误时，获取导致错误文档某个锁信息（当然，连续使用两个命令不是原子操作，两个命令之间可能被解锁）</li>
</ul>
</li>
</ul>
<h3 id="记录锁几个注意点"><a href="#记录锁几个注意点" class="headerlink" title="记录锁几个注意点"></a>记录锁几个注意点</h3><ol>
<li>进程对文件上锁的类型受文件打开方式影响。</li>
<li>一个进程可以对某个文件的特定字节范围<strong>多次</strong>发出 F_SETLK 或 F_SETLKW 命令。每次成功与否取决于 <strong>其他进程</strong> 当时是否锁住该字节范围以及锁的类型，与本进程先前是否锁住该字节范围无关。</li>
<li>对于一个文件的任意字节，<strong>最多只能存在一种类型的记录锁</strong>（读锁或写锁）。一个给定字节可以有多个读锁，但只能有一个写锁。</li>
<li><strong>进程终止内核自动清理 fcntl 记录锁</strong>，对于一个打开着某个文件的进程来说，当关闭文件的所有描述符或进程本身终止时，与该文件关联的所有记录锁都被删除。</li>
<li><strong>不能继承</strong>，记录锁不能通过 fork 由子进程继承，记录锁跟进程ID紧密关联。</li>
<li>记录上锁<strong>不应该同标准I/O一块使用</strong>，因为标准I/O函数库会执行<strong>内部缓冲</strong>。应使用 read 和 write 系统调用。</li>
</ol>
<h3 id="劝告性上锁"><a href="#劝告性上锁" class="headerlink" title="劝告性上锁"></a>劝告性上锁</h3><p>Posix 记录上锁称为 <strong>劝告性上锁</strong> （advisory locking）。其含义是内核维护着由各个进程上锁的所有文件的正确信息，但是它不能防止一个进程写一个读锁定文件，或者读一个写锁定文件。（类似互斥锁的协作性）</p>
<h3 id="强制性上锁"><a href="#强制性上锁" class="headerlink" title="强制性上锁"></a>强制性上锁</h3><p>有些系统提供另一种类型文档记录上锁，称为 <strong>强制性上锁</strong> （mandatory locking）。使用强制性锁后，内核检查每个 read 和 write 请求，已验证起草组不会干扰由某个进程持有的某个锁。</p>
<p>若有干扰，对于阻塞式，冲突的 read 或 write 将把进程投入睡眠，直到锁释放。对于非阻塞式，返回 EAGAIN 错误。</p>
<p><strong>强制性上锁也会导致不一致的数据</strong>，若下图：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E8%AE%B0%E5%BD%95%E9%94%81-%E5%BC%BA%E5%88%B6%E6%80%A7%E4%B8%8A%E9%94%81-%E9%94%99%E8%AF%AF.png"></p>
<h2 id="Posix信号量"><a href="#Posix信号量" class="headerlink" title="Posix信号量"></a>Posix信号量</h2><p>信号量是一种用于提供进程（或线程）间同步手段的原语。</p>
<ul>
<li><strong>Posix有名信号量</strong>：由与文件系统中的路径名对应的名字来标识（并不要求它们真正的存放在文件系统内的某个文件）。</li>
<li><strong>Posix基于内存的信号量</strong>：即无名信号量，</li>
</ul>
<h3 id="信号量、互斥锁和条件变量间的差异"><a href="#信号量、互斥锁和条件变量间的差异" class="headerlink" title="信号量、互斥锁和条件变量间的差异"></a>信号量、互斥锁和条件变量间的差异</h3><ol>
<li>互斥锁总是由给它上锁的线程（或进程）解锁，信号量的挂出却不必由执行过它的等待操作的同一线程（或进程）执行。</li>
<li>互斥锁要么被锁在，要么被解开（二值状态，类似于 <strong>二值信号量</strong> ，其值或为0或为1）。</li>
<li>信号量有一个与之关联的状态（计数值），信号量的挂出操作总是被记住。当条件满足，向一个条件变量发送信号时，若没有线程（或进程）等待该条件，则<strong>信号将会丢失</strong>。</li>
<li>在同步技巧（互斥锁、条件变量、读写锁、信号量）中，能够从信号处理程序中安全调用的唯一函数是 <code>sem_post</code> 。</li>
</ol>
<h3 id="Posix信号量函数调用"><a href="#Posix信号量函数调用" class="headerlink" title="Posix信号量函数调用"></a>Posix信号量函数调用</h3><p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E7%94%A8%E4%BA%8EPosix%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png"></p>
<h4 id="sem-open、sem-close和sem-unlink"><a href="#sem-open、sem-close和sem-unlink" class="headerlink" title="sem_open、sem_close和sem_unlink"></a>sem_open、sem_close和sem_unlink</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的有名信号量，或打开一个已存在的有名信号量</span></span><br><span class="line"><span class="function"><span class="keyword">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag <span class="comment">/* , mode_t mode, unsigned int value */</span>)</span></span>;</span><br><span class="line"><span class="comment">// 关闭 sem_open 打开的有名信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 从系统中删除指定的有名信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>进程终止</strong>时（无论自愿与否），内核会对其上仍然打开着的所有 <strong>有名信号量</strong> <strong>自动执行</strong> <code>sem_close</code> 信号量关闭操作（<strong>不是释放</strong>）。</li>
<li>关闭一个信号量斌没有将它从系统中删除，即，<strong>Posix有名信号量</strong> 至少是 <strong>随内核持续</strong> 的：即使当前没有进程打开着某个信号量，它的值仍然保持。</li>
<li><code>sem_unlink</code> 类似于文件I/O的 unlink 函数，当引用计数还大于0时， <code>name</code> 就能从文件系统中删除，但是<strong>信号量的析构</strong>（不同于将它名字从文件系统中删除）要等到最后一个 <code>sem_close</code> 发生时为止。</li>
</ul>
<h4 id="sem-wait和sem-trywait"><a href="#sem-wait和sem-trywait" class="headerlink" title="sem_wait和sem_trywait"></a>sem_wait和sem_trywait</h4><p>若信号量值大于0，将它减1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;    <span class="comment">// 睡眠等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sem-post和sem-getvalue"><a href="#sem-post和sem-getvalue" class="headerlink" title="sem_post和sem_getvalue"></a>sem_post和sem_getvalue</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sem_post</code>：信号量值加1，若信号量值因此大于0，唤醒一个等待的进程（或线程）</p>
<blockquote>
<p>If the semaphore’s value consequently becomes greater than  zero,  then  another  process  or  thread  blocked  in  a sem_wait(3) call will be woken up and proceed to lock the semaphore.</p>
</blockquote>
</li>
<li><p><code>sem_getvalue</code>：获取指定信号量的当前值。</p>
<p>若有不少于一个进程（或线程）等待，返回 valp 值：</p>
<ul>
<li>= 0；</li>
<li>&lt; 0，绝对值为等待的进程（或线程）数量。</li>
</ul>
</li>
</ul>
<h4 id="sem-init和sem-destroy"><a href="#sem-init和sem-destroy" class="headerlink" title="sem_init和sem_destroy"></a>sem_init和sem_destroy</h4><p><strong>Posix基于内存的信号量</strong> 操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个基于内存的信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>shared = 0</code> ：进程内各线程共享。</li>
<li><code>shared != 0</code> ：进程间共享。此时该信号量必须存放在某种类型的 <strong>共享内存区中</strong> ，使用它的进程都要能访问该共享内存区。</li>
<li>对于一个已初始化的信号量调用 <code>sem_init</code> ，其结果时未定义的。</li>
<li><strong>基于内存的信号量</strong> 具有 <strong>随进程</strong> 的持续性，其真正的持续性<strong>取决于存放信号量的内存区的类型</strong>。<ul>
<li>单个进程内线程共享，持续性随进程；</li>
<li>进程间共享，只要该共享内存区仍然存在，该信号量就继续存在。</li>
</ul>
</li>
</ul>
<h3 id="信号量限制"><a href="#信号量限制" class="headerlink" title="信号量限制"></a>信号量限制</h3><p>Posix定义了两个信号量限制：</p>
<ul>
<li><code>SEM_NSEMS_MAX</code>：一个进程可同时打开着的最大信号量数；</li>
<li><code>SEM_VALUE_MAX</code>：一个信号量的最大值。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>unp</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>select函数-linux内核源码剖析</title>
    <url>/UNP/select%E5%87%BD%E6%95%B0-linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="用户态下select系统调用"><a href="#用户态下select系统调用" class="headerlink" title="用户态下select系统调用"></a>用户态下select系统调用</h1><p>select多路I/O转接服务器demo：<a href="https://github.com/JakeLin0fly/unp-code/blob/master/select_concurrent/select_server.c">select_server.c</a> </p>
<h2 id="select函数原型"><a href="#select函数原型" class="headerlink" title="select函数原型"></a>select函数原型</h2><blockquote>
<p>/usr/include/sys/select.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">        fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;        <span class="comment">//从fdset中删除fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;        <span class="comment">//判断fd是否已存在fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;        <span class="comment">//将fd添加到fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;                <span class="comment">//fdset所有位清0</span></span><br></pre></td></tr></table></figure>

<p><strong>select参数：</strong></p>
<blockquote>
<ol>
<li><p><strong>nfds</strong>：监控的文件描述符集中，待测试的<strong>最大描述符+1</strong></p>
</li>
<li><p><strong>readfds</strong>：监控有读数据到达文件描述符集合，传入传出参数</p>
</li>
<li><p><strong>writefds</strong>：监控有写数据到达文件描述符集合，传入传出参数</p>
</li>
<li><p><strong>exceptfds</strong>：监控异常发生达文件描述符集合，传入传出参数</p>
<p>a）带外数据到达</p>
<p>b）某个已置为分组模式的伪终端存在可从其主机端读取的控制状态信息</p>
</li>
<li><p><strong>timeout</strong>：定时阻塞监控时间，3种情况：</p>
<p>1）NULL，永远等下去</p>
<p>2）设置 timeval ，等待固定时间</p>
<p>3）设置 timeval 里时间均为0，检查描述字后立即返回，轮询</p>
</li>
</ol>
</blockquote>
<p><em>注意：<code>FD_</code>为前缀的函数并非系统调用，而是几个对<code>fd_set</code>进行相关位操作的<strong>宏</strong></em></p>
<p><code>fd_set</code>结构体的定义实际包含的是<code>fds_bits</code>位<strong>数组</strong>，其大小固定，由<code>FD_SETSIZE</code>指定，因此<font color=red><strong>每次select系统调用可监听处理的文件描述符最大数量为<code>FD_SETSIZE</code></strong></font>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure>



<h2 id="select函数作用"><a href="#select函数作用" class="headerlink" title="select函数作用"></a>select函数作用</h2><p><strong>select函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</strong></p>
<p><code>readfds</code>、<code>writefds</code>、<code>exceptfds</code>三个参数中，若不关注某个参数，可将其设为<code>NULL</code>。三个参数均为<code>NULL</code>相当于一个定时器。</p>
<h2 id="select函数局限"><a href="#select函数局限" class="headerlink" title="select函数局限"></a>select函数局限</h2><ol>
<li><p>select能监听的文件描述符个数受限于<code>FD_SETSIZE</code>，一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。</p>
<blockquote>
<p>/usr/include/sys/select.h</p>
<p>/usr/include/bits/typesizes.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of file descriptors in `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE              __FD_SETSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of descriptors that can fit in an `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE            1024</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>描述符集内任何与<strong>未就绪描述符</strong>对应的位返回时<strong>均清成0</strong>。为此，每次<strong>重新调用</strong>select函数时，我们都得<strong>再次</strong>把所有描述符集内所关心的位<strong>均置为1</strong>。</p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是<strong>轮询模型</strong>，会大大降低服务器响应效率，不应在select上投入更多精力。</p>
</li>
</ol>
<h2 id="套接字就绪条件"><a href="#套接字就绪条件" class="headerlink" title="套接字就绪条件"></a>套接字就绪条件</h2><img src="https://i.loli.net/2020/08/07/WdJIKFkZlCmUpoO.png" alt="select返回某个套接字就绪条件.png" style="zoom:67%;" />

<h1 id="select源码剖析"><a href="#select源码剖析" class="headerlink" title="select源码剖析"></a>select源码剖析</h1><blockquote>
<p>内核源码：linux-3.10</p>
<p>seelct源码：fs/select.c</p>
<p>内核源码链接：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v3.0/linux-3.10.tar.gz">https://mirrors.edge.kernel.org/pub/linux/kernel/v3.0/linux-3.10.tar.gz</a></p>
</blockquote>
<h2 id="select系统调用入口"><a href="#select系统调用入口" class="headerlink" title="select系统调用入口"></a>select系统调用入口</h2><ol>
<li>若设置超时时间，用户空间（微秒量级）拷贝到内核空间（纳秒量级）</li>
<li><code>core_sys_select</code> 真正执行入口</li>
<li>传出剩余时间差，返回给用户空间</li>
<li>正常结束，返回满足条件的描述符个数</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏select系统调用</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 永久等待      tvp == NULL</span></span><br><span class="line"><span class="comment">     * 2. 不等待         tvp-&gt;tv_sec == 0 &amp;&amp; tvp-&gt;tc_nsec == 0</span></span><br><span class="line"><span class="comment">     * 3. 等待指定时间   tvp-&gt;tv_sec != 0 || tvp-&gt;tc_nsec != 0  */</span></span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">        <span class="comment">/** 在设置超时情况下，拷贝用户空间下的相对超时时间（微秒量级）到内核 **/</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv))) </span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="comment">/** poll_select_set_timeout 设定成绝对的超时时间（纳秒量级） **/</span></span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** select 真正执行入口 **/</span></span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</span><br><span class="line">    <span class="comment">/* 将此次调用完成剩余的时间差值通过 tvp 指向的 timeval 结构返回给用户空间 */</span></span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="core-sys-select"><a href="#core-sys-select" class="headerlink" title="core_sys_select"></a>core_sys_select</h2><ol>
<li>先创建一个默认大小栈缓冲区（加快访问，但缓冲区大小可能不够）。</li>
<li>检查最大fd是否超出进程文件描述符位图所容量的最大值（默认1024），超过部分不监听（修正）。</li>
<li>计算前面创建的栈缓冲区是否足够存储输入、输出6个集合，若缓冲区大小不足则使用<code>kmalloc</code>分配内核空间。</li>
<li>将缓冲区分成6段，从用户空间拷贝输入集到内核空间，并将内核空间结果集清0。</li>
<li>执行主线 <strong>do_select</strong> 。</li>
<li>若无错误，拷贝内核结果集到用户空间</li>
<li>正常结束，返回满足条件的描述符数</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏core_sys_select</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set_bits fds;</span><br><span class="line">    <span class="keyword">void</span> *bits;</span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 需要将用户空间传进来的inset、outset、exset拷贝到内核空间，并且</span></span><br><span class="line"><span class="comment">     * 需要等容量的空间来存储结果集，之后会将结果集的内容写回到用户空间。</span></span><br><span class="line"><span class="comment">     * 定义一个SELECT_STACK_ALLOC(256字节)大小的栈上缓冲区，用于缓存输入输出结果集。</span></span><br><span class="line"><span class="comment">     * 如果缓存的空间大小不够，那么再使用kmalloc()动态分配，</span></span><br><span class="line"><span class="comment">     * 优先使用栈缓存而不用动态内存可以加快访问 */</span></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* rdlock加锁：保护struct files的访问 */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    fdt = files_fdtable(current-&gt;files);</span><br><span class="line">    max_fds = fdt-&gt;max_fds;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">/* 基于current宏，检查传入的最大fd对应参数n是否超出当前进程打开的</span></span><br><span class="line"><span class="comment">    * 文件描述符表内所示位图容量的最大数值，超出修正*/</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">        n = max_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * n个bits至少需要size个long才能装下（long表示bits段），</span></span><br><span class="line"><span class="comment">     * 为了存储输入输出集，我们需要6*size个long的存储空间</span></span><br><span class="line"><span class="comment">     * 栈上数组空间不足以存放本次select要处理的fd集合所需总计内存，</span></span><br><span class="line"><span class="comment">     * 则使用kmalloc从内核空间分配所需的连续物理内存 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = FDS_BYTES(n);</span><br><span class="line">    bits = stack_fds;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!bits)</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将数组分成6段 */</span></span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   size;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line">    <span class="comment">/* 依次从用户空间拷贝输入集数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">        (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">        (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* 将输出集清0 */</span></span><br><span class="line">    zero_fd_set(n, fds.res_in);</span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line">    <span class="comment">/* 主线 核心 */</span></span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 最后 将结果集返回用户空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">        set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">        set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="do-select（最核心）"><a href="#do-select（最核心）" class="headerlink" title="do_select（最核心）"></a>do_select（最核心）</h2><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><h4 id="poll-table-entry"><a href="#poll-table-entry" class="headerlink" title="poll_table_entry"></a>poll_table_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;                  <span class="comment">//wait等待队列项</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *wait_address;     <span class="comment">//wait的等待队列头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="poll-table-page"><a href="#poll-table-page" class="headerlink" title="poll_table_page"></a>poll_table_page</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="poll-table"><a href="#poll-table" class="headerlink" title="poll_table"></a>poll_table</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _key;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure>

<h4 id="poll-wqueues"><a href="#poll-wqueues" class="headerlink" title="poll_wqueues"></a>poll_wqueues</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span></span><br><span class="line">    poll_table pt;                      <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span>      <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span>   <span class="comment">//正在轮询的进程</span></span><br><span class="line">    <span class="keyword">int</span> triggered;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> inline_index;</span><br><span class="line">    <span class="comment">//记录poll信息的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="do-select源码剖析"><a href="#do-select源码剖析" class="headerlink" title="do_select源码剖析"></a>do_select源码剖析</h3><ol>
<li>初始化内核数据，再次检查并修正最大文件描述符</li>
<li>等待队列构建，并初始化等待队列</li>
<li>无穷循环开始轮询事件监测，核心调用转poll</li>
<li>结果写入内核空间的结果集</li>
<li>释放内核相应数据结构空间</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏do_select</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>; <span class="comment">/* timed_out指示是否已经超时，超时1，未超时0 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/* 借助当前进程已打开的文件描述符表检查传入且合法的已打开最大fd，并修正传入的n */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line">    <span class="comment">/* poll_initwait初始化poll_wqueues结构体table，这一结构体用于本次select调用</span></span><br><span class="line"><span class="comment">     * 对所有传入的待监听fd进行【轮询工作】，每个fd对应一个poll_table_entry。</span></span><br><span class="line"><span class="comment">     * 初始化poll_wqueues：</span></span><br><span class="line"><span class="comment">     * 1. 初始化poll_wqueues中的poll_table：</span></span><br><span class="line"><span class="comment">     *      * 设置监听注册函数为 __pollwait</span></span><br><span class="line"><span class="comment">     * 2. 设置polling_task指向当前进程PCB。*/</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">/* 根本不等待情况处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>; <span class="comment">/* 注意：设为NULL了！！！ */</span></span><br><span class="line">        timed_out = <span class="number">1</span>;  <span class="comment">/* 还没开始就已经超时，这样就实现了根本不等待... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 重新估算相对超时时间... */</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">/* 无穷循环开始轮询事件监测 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;</span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;  <span class="comment">/* 跳过我们不关心的bits段 */</span></span><br><span class="line">                i += BITS_PER_LONG;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 以BITS_PER_LONG个为一组依次挂载到等待队列，并对事件进行检测，</span></span><br><span class="line"><span class="comment">             * 如果没有事件到来，仅有第一次循环完成挂载，后续循环只监测事件。*/</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n)  <span class="comment">/* 超出了关心的文件描述符范围[0, n)，那么跳出... */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(bit &amp; all_bits)) <span class="comment">/* 跳过我们不关心的bit */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                f = fdget(i);</span><br><span class="line">                <span class="comment">/* 因为没有rdlock加锁，因此当前进程中描述符i对应的文件可能已经</span></span><br><span class="line"><span class="comment">                 * 被异步关闭。这就是为什么需要判断file是否为空的原因 */</span></span><br><span class="line">                <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">                    f_op = f.file-&gt;f_op;</span><br><span class="line">                    <span class="comment">/* 注意：mask = POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM; */</span></span><br><span class="line">                    mask = DEFAULT_POLLMASK; </span><br><span class="line">                    <span class="comment">/* 如果这个文件支持poll()，那么我们就向这个文件注册监听函数；</span></span><br><span class="line"><span class="comment">                     * 如果不支持，那么我们就忽略掉这个文件描述符 */</span></span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">                        wait_key_set(wait, in, out, bit); <span class="comment">/* 设置poll_table中想要监听的事件 */</span></span><br><span class="line"><span class="comment">/* #核心调用#</span></span><br><span class="line"><span class="comment">* 在这里会根据fd的不同创建类别调用真正的poll函数，</span></span><br><span class="line"><span class="comment">* socket下对应是sock_poll，如ipv4/tcp下会继续调用tcp_poll，</span></span><br><span class="line"><span class="comment">* 在这里完成调用poll_table注册的函数指针__poll_wait挂载等待队列操作（实际借助poll_wait封装调用）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(f.file, wait); <span class="comment">/* 对文件注册监听函数，并返回资源的当前状态 */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fdput(f);</span><br><span class="line">                    <span class="comment">/* 完成检测操作获取事件mask结果。events验证，其中retval表示就绪的资源数 */</span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">                        res_in |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        <span class="comment">/* 保证仅在第一次循环时，完成本次fd对应挂载等待队列，</span></span><br><span class="line"><span class="comment">                         * 不论是否收到设备事件通知，本次调用仅挂载一次，因此置空poll_table注册的poll */</span></span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;  <span class="comment">//</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">                        res_out |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">                        res_ex |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 结果写入内核空间的结果集 */</span></span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">            cond_resched();</span><br><span class="line">        &#125;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>;  <span class="comment">/* 将wait-&gt;_qproc设为NULL，表示我们不希望再进行监听注册 */</span></span><br><span class="line">        <span class="comment">/* 事件发生、超时、中断，跳出死循环 */</span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;  <span class="comment">/* 发生了错误，我们也跳出死循环 */</span></span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 能够到达这一步就说明没有发生就绪、中断以及超时 */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 判断poll_wqueues是否已触发，如果还没有触发，那就</span></span><br><span class="line"><span class="comment">           设置当前运行状态为可中断阻塞并进行睡眠，等待被唤醒。</span></span><br><span class="line"><span class="comment">         * 被唤醒之后重新进行迭代，获取资源就绪情况。</span></span><br><span class="line"><span class="comment">         * 在向资源注册监听与判断poll_wqueues是否已触发在这段时间内，可能资源异步就绪了，</span></span><br><span class="line"><span class="comment">           如果没有触发标志，那么可能就会丢失资源就绪这个事件，可能导致select()永久沉睡。</span></span><br><span class="line"><span class="comment">         * 这就是为什么需要poll_wqueues.triggered字段的原因。  */</span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                       to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 1. 卸载安装到资源监听队列上的poll_table_entry</span></span><br><span class="line"><span class="comment">     * 2. 释放poll_wqueues占用的资源  */</span></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>select负责将超时时间从用户空间（微秒级）拷贝到内核空间（纳秒级），接着转真正入口<code>core_sys_select</code>。</p>
<p><code>core_sys_select</code>函数调用树如下（图片来源网络）：</p>
<img src="https://i.loli.net/2020/08/07/hzjyYkINFRbuqaH.png" alt="core_sys_select调用树.png" style="zoom:67%;" />

<h2 id="select注意点"><a href="#select注意点" class="headerlink" title="select注意点"></a>select注意点</h2><ol>
<li>select函数第一个参数<code>nfds</code>为监控的文件描述符集中，待测试的<strong>最大描述符+1</strong>。</li>
<li>每次调用select均需要将用户空间数据拷贝到内核空间</li>
<li>select能监听的文件描述符个数受限于<code>FD_SETSIZE</code>，一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。修改后需重新编译内核。</li>
<li>每次select调用都要轮询完成将所有<code>fd</code>的挂载到等待队列，以及对事件进行检测。</li>
<li>内核轮询检测监听集合中每一个描述符是否有事件发生，有事件到来时，不知道是哪些文件描述符有数据可以读写，需要把所有的文件描述符都轮询一遍才能知道。</li>
<li>有事件发生，轮询完一遍，将内核空间中的整个结果集 <code>bitmap</code> 拷贝到用户空间。</li>
<li>用户进程仅知道有多少满足条件的描述符，需要遍历监听集合去查询。</li>
<li>select函数<code>readfds</code>、<code>writefds</code>、<code>exceptfds</code>三个集合参数均为<strong>传入传出参数</strong>，在每次调用select时需要对三个参数进行赋值。</li>
<li>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select 采用的是轮询模型，会大大降低服务器响应效率。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《UNIX网络编程 卷一：套接字联网API》</p>
<p><a href="http://www.pandademo.com/2016/11/linux-kernel-select-source-dissect/">Linux内核select源码剖析</a></p>
<p><a href="https://www.jianshu.com/p/da6642369ef0">https://www.jianshu.com/p/da6642369ef0</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>unp</tag>
        <tag>I/O复用</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-84.柱状图中最大的矩形</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h2><blockquote>
<p>给定 n 个非负整数，用来表示柱状图中各个柱体的高度。每个柱体彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png"></p>
<p>以上是柱状图的示例，其中每个柱体的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></p>
</blockquote>
<h2 id="方法一：暴力（超时）"><a href="#方法一：暴力（超时）" class="headerlink" title="方法一：暴力（超时）"></a>方法一：暴力（超时）</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n^2)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>计算以一根柱体 i 的高度为高的矩形。向左右两侧查找高度小于柱体 i 的最近柱体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i])</span><br><span class="line">                --left;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; heights[right] &gt;= heights[i])</span><br><span class="line">                ++right;</span><br><span class="line">            maxSize = max(maxSize, heights[i] * (right - left - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong>  </p>
<p>【<strong>空间复杂度</strong>】<strong>O(n)</strong> </p>
</blockquote>
<p>假设我们以每根柱体为矩形的高，那么我们使用暴力算法向两边查找的目标是高度小于某根柱体的最右两侧最近的柱体位置。使用暴力算法需要 O(N) 的时间复杂度进行查找。如何我们使用<strong>单调栈</strong>，栈内记录是第几根柱体，且柱体高度单调递增，那么我们便能很快找到更小的柱体。</p>
<ul>
<li>若栈顶 &lt; 当前柱体，当前柱体左侧最近的更小柱体找到。</li>
<li>若栈顶 &gt; 当前柱体，当前柱体右侧最近的更小柱体找到。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; greaterStack;  <span class="comment">// 数组充当栈</span></span><br><span class="line">        vector&lt;int&gt; left(n, -1), right(n, n); // 左边（或右边）第一个小于自身的柱体</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；</span></span><br><span class="line">            <span class="comment">// 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。</span></span><br><span class="line">            <span class="comment">// 因此以栈顶柱体为高的矩形的左右宽度边界就确定了</span></span><br><span class="line">            <span class="keyword">while</span> (!greaterStack.empty() &amp;&amp; heights[greaterStack.back()] &gt; heights[i])  &#123;</span><br><span class="line">                right[greaterStack.back()] = i; <span class="comment">// 右边第一个小于栈顶柱体的柱体</span></span><br><span class="line">                greaterStack.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!greaterStack.empty()) <span class="comment">// 左边第一个小于栈顶柱体的柱体</span></span><br><span class="line">                left[i] = greaterStack.back();</span><br><span class="line">            greaterStack.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxSize = max(maxSize, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="降低空间"><a href="#降低空间" class="headerlink" title="降低空间"></a>降低空间</h3><p>使用辅助空间存放左右最近的更小的柱子，使得程序可读性更好，但是我们可以不使用辅助数组完成计算。只是程序的可读性不太好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【单调栈】 </span></span><br><span class="line"><span class="comment">时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">空间复杂度：O(N)  栈</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; greaterStack;  <span class="comment">// 数组充当栈</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; left(n, -1), right(n, n); // 左边（或右边）第一个小于自身的柱体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；</span></span><br><span class="line">            <span class="comment">// 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。</span></span><br><span class="line">            <span class="comment">// 因此以栈顶柱体为高的矩形的左右宽度边界就确定了</span></span><br><span class="line">            <span class="keyword">while</span> (!greaterStack.empty() &amp;&amp; heights[greaterStack.back()] &gt;= heights[i])  &#123;</span><br><span class="line">                <span class="keyword">int</span> curInex = greaterStack.back();  <span class="comment">// 栈顶柱体，现在已知其左右两侧更小的柱体</span></span><br><span class="line">                greaterStack.pop_back();</span><br><span class="line">                <span class="comment">// 左侧没有更小的柱体，默认值：-1</span></span><br><span class="line">                <span class="keyword">if</span> (greaterStack.empty()) &#123; </span><br><span class="line">                    maxSize = max(maxSize, heights[curInex] * i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxSize = max(maxSize, heights[curInex] * (i - greaterStack.back() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            greaterStack.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> stackNums = greaterStack.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅栈顶元素，即最小柱体</span></span><br><span class="line">        <span class="keyword">if</span> (stackNums == <span class="number">1</span>) &#123;</span><br><span class="line">            maxSize = max(maxSize, heights[greaterStack.back()] * n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 栈顶</span></span><br><span class="line">            maxSize = max(maxSize, heights[greaterStack.back()] * (n - greaterStack[stackNums - <span class="number">2</span>] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = stackNums - <span class="number">2</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                maxSize = max(maxSize, heights[greaterStack[i]] * (n - greaterStack[i - <span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (heights[greaterStack[i - <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈底</span></span><br><span class="line">            maxSize = max(maxSize, heights[greaterStack[<span class="number">0</span>]] * n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-85.最大矩形</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h2><blockquote>
<p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/maximal-rectangle">https://leetcode-cn.com/problems/maximal-rectangle</a></p>
</blockquote>
<h2 id="方法一：暴力-优化"><a href="#方法一：暴力-优化" class="headerlink" title="方法一：暴力+优化"></a>方法一：暴力+优化</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(m^2 *  n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(mn)</strong> </p>
</blockquote>
<p>当 <code>matrix[i][j] = &#39;1&#39;</code>  时，我们计算以 (i, j) 为右下角的全1矩形最大面积。矩形的面积 = 宽度(w) x 高度(h)，所以我们需要知道这个符合要求的矩形的宽度和高度。<code>height</code> 数组记录 “高度”（也就是当前位置上次包括当前位置有多少个连续的1），当 <code>i</code> 固定时，可以看做是一个柱状图。我们的目标就是计算出 <code>i = m</code> 时，柱状图中最大矩形面积。</p>
<ul>
<li>首先使用二维数组 <code>height[i][j]</code> ，记录位置 (i, j) 上侧（包括当前位置）有多少了连续的 ‘1’。</li>
<li>从仅一行（即，i=0）开始，计算当前行为底边时，柱状图中的最大矩形面积。其中有几点优化意见：<ol>
<li>向左增大矩形宽度，此时，柱形最小高度可能减小；</li>
<li>若以 (i, j) 为右下角，并且可能产生的最大矩形面积 <strong>不大于</strong> 已知的最大矩形面积，则可以终止此处计算。</li>
</ol>
</li>
</ul>
<p>【<strong>代码示例</strong>】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= rows, cols &lt;= 200</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows, cols;</span><br><span class="line">        <span class="keyword">if</span> ((rows = matrix.size()) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【柱状图-柱形高度】 height[i][j] 该位置上侧（包括当前位置）有多少了连续的 &#x27;1&#x27;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">height</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>))</span></span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    height[i][j] = (i == <span class="number">0</span>)? <span class="number">1</span> : height[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【柱状图-最大矩形面积】计算由 [i][j] 为右下角的的最大矩形面积 （暴力）</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>; <span class="comment">// 最大矩形面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (height[i][j] &gt; <span class="number">0</span>) &#123; <span class="comment">// 当前柱高度大于0</span></span><br><span class="line">                    <span class="comment">// 以 [i][j] 为右下角最大可能的矩形面积</span></span><br><span class="line">                    <span class="keyword">int</span> curMaxSize = height[i][j] * (j + <span class="number">1</span>); </span><br><span class="line">                    <span class="comment">// 当前可确认的以 [i][j] 为右下角的矩形面积</span></span><br><span class="line">                    <span class="keyword">int</span> curSize = height[i][j];</span><br><span class="line">                    <span class="comment">// 向左增大矩形宽度，此时，柱形最小高度可能减小</span></span><br><span class="line">                    <span class="comment">// 当可能组成的最大矩形不大于已知的最大矩形面积时便可终止</span></span><br><span class="line">                    <span class="keyword">int</span> minHeight = height[i][j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; curMaxSize &gt; maxSize &amp;&amp; k &gt;= <span class="number">0</span>; --k) &#123; <span class="comment">//  &amp;&amp; height[i][k] &gt; 0</span></span><br><span class="line">                        <span class="keyword">if</span> (minHeight &gt; height[i][k]) &#123; <span class="comment">// 高度减小</span></span><br><span class="line">                            minHeight = height[i][k];</span><br><span class="line">                            curMaxSize = minHeight * (j + <span class="number">1</span>); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 当前可确认的以 [i][j] 为右下角的最大矩形面积</span></span><br><span class="line">                        curSize = max(curSize, minHeight * (j - k + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    maxSize = max(maxSize, curSize);</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(mn)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(n)</strong> </p>
</blockquote>
<p>在计算柱形图中，最大矩形面积时，可以优化，可参考 <strong><a href="../%E5%8A%9B%E6%89%A3-84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88">力扣-84. 柱状图中最大的矩形</a></strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【单调栈】</span></span><br><span class="line"><span class="comment">参考：84. 柱状图中最大的矩形 https://leetcode-cn.com/problems/largest-rectangle-in-histogram</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 0 &lt;= rows, cols &lt;= 200</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows, cols;</span><br><span class="line">        <span class="keyword">if</span> ((rows = matrix.size()) &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(cols, <span class="number">0</span>)</span></span>; <span class="comment">// 辅助数组，记录【柱状图】高度</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    ++height[j];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSize = max(maxSize, largestRectangleArea(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** 【单调栈】计算柱状图最大矩形面积 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; greaterStack;  <span class="comment">// 数组充当栈</span></span><br><span class="line">        vector&lt;int&gt; left(n, -1), right(n, n); // 左边（或右边）第一个小于自身的柱体</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；</span></span><br><span class="line">            <span class="comment">// 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。</span></span><br><span class="line">            <span class="comment">// 因此以栈顶柱体为高的矩形的左右宽度边界就确定了</span></span><br><span class="line">            <span class="keyword">while</span> (!greaterStack.empty() &amp;&amp; heights[greaterStack.back()] &gt; heights[i])  &#123;</span><br><span class="line">                right[greaterStack.back()] = i; <span class="comment">// 右边第一个小于栈顶柱体的柱体</span></span><br><span class="line">                greaterStack.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!greaterStack.empty()) <span class="comment">// 左边第一个小于栈顶柱体的柱体</span></span><br><span class="line">                left[i] = greaterStack.back();</span><br><span class="line">            greaterStack.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxSize = max(maxSize, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-面试题10.11.峰与谷</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-%E9%9D%A2%E8%AF%95%E9%A2%9810.11.%E5%B3%B0%E4%B8%8E%E8%B0%B7/</url>
    <content><![CDATA[<h2 id="面试题10-11-峰与谷"><a href="#面试题10-11-峰与谷" class="headerlink" title="面试题10.11.峰与谷"></a>面试题10.11.峰与谷</h2><blockquote>
<p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5, 3, 1, 2, 3]</span><br><span class="line">输出: [5, 1, 3, 2, 3]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>nums.length &lt;= 10000</li>
</ul>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/peaks-and-valleys-lcci">https://leetcode-cn.com/problems/peaks-and-valleys-lcci</a></p>
</blockquote>
<p>一开始没看明白，以为结果唯一，是将原数组中的峰谷交替存放（疑问点就是 ”山腰“ 部分怎么办）。<strong>大意了</strong>，没看到是将数组排序，其结果不具有唯一性。</p>
<h2 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(NlogN)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>若是得到数组有序（假设递增），那么我们通过数组前后值的交换排列不就得到满足要求的数组了吗。但很明显，这样时间复杂度较高。</p>
<ul>
<li>第一步：排序，O(NlogN)</li>
<li>第二步：依次交换待排子数组两端的值，使得数组满足要求，O(N) </li>
</ul>
<h2 id="方法二：直接交换"><a href="#方法二：直接交换" class="headerlink" title="方法二：直接交换"></a>方法二：直接交换</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>方法一先排序，再交换待排子数组两端的值，使得数组满足 <strong>峰-谷-峰</strong> 交替的关系。那我们直接交换呢？假设前面已经是满足要求的数组，往有序数组末尾插入新元素，根据当前有序数组元素个数（即末尾元素是峰还是谷），以及末尾元素与新入元素的大小关系，便可通过至多一次交换完成插入操作。</p>
<ul>
<li>末尾为 <strong>峰</strong> ：<ul>
<li>新元素 <strong>&lt;=</strong> 末尾元素，满足关系要求。</li>
<li>新元素 <strong>&gt;</strong> 末尾元素，交换两元素后满足关系要求。</li>
</ul>
</li>
<li>末尾为 <strong>谷</strong> :<ul>
<li>新元素 <strong>&gt;=</strong> 末尾元素，满足关系要求。</li>
<li>新元素 <strong>&lt;</strong> 末尾元素，交换两元素后满足关系要求。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 末尾为 峰 ：</span></span><br><span class="line"><span class="comment">  * 新元素 &lt;= 末尾元素，满足关系要求。</span></span><br><span class="line"><span class="comment">  * 新元素 &gt; 末尾元素，交换两元素后满足关系要求。</span></span><br><span class="line"><span class="comment">* 末尾为 谷 :</span></span><br><span class="line"><span class="comment">  * 新元素 &gt;= 末尾元素，满足关系要求。</span></span><br><span class="line"><span class="comment">  * 新元素 &lt; 末尾元素，交换两元素后满足关系要求。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 末尾元素为 谷</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                    swap(nums[i], nums[i<span class="number">-1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 末尾为 峰</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                    swap(nums[i], nums[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-995.K连续位的最小翻转次数</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-995.K%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="995-K-连续位的最小翻转次数"><a href="#995-K-连续位的最小翻转次数" class="headerlink" title="995. K 连续位的最小翻转次数"></a>995. K 连续位的最小翻转次数</h2><blockquote>
<p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。</p>
<p>返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,1,0], K &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：先翻转 A[0]，然后翻转 A[2]。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,1,0], K &#x3D; 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips">https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips</a></p>
</blockquote>
<h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>看到 “<strong>K 连续位</strong>” 首先想到的就是 <strong>滑动窗口</strong>。根据题目意思，是要把所有的 0 包括中间过程产生的 0）翻转为 1。在此我们有几点注意：</p>
<ul>
<li>后面子区间的翻转，不会影响到前面已经全1的区间；</li>
<li>翻转<strong>偶数次</strong>的结果是最初始的值 <code>A[i]</code>，翻转<strong>奇数次</strong>的结果是 <code>A[i] ^ 1</code> 。</li>
</ul>
<h2 id="方法一：暴力模拟翻转"><a href="#方法一：暴力模拟翻转" class="headerlink" title="方法一：暴力模拟翻转"></a>方法一：暴力模拟翻转</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N*K)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>暴力方法很简单，就是从左往右移动滑动窗口，最左侧遇到 0 便翻转区间内的数。但是，很显然暴力算法会 <strong>计算超时</strong>。</p>
<h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(K)</strong> </p>
</blockquote>
<p>暴力模拟的问题在于，每次翻转都要对K个数赋值。上面我们提到了翻转<strong>奇数次</strong>和<strong>偶数次</strong>的值我们是知道的，那么如果我们记录下该值被翻转的次数，便知道滑动窗口移动到此处是否还需要翻转。<strong>每一次翻转的发生都是由某一个元素引起的，我们规定，引起翻转发生的元素为滑动窗口最左侧的元素</strong>。</p>
<p>当前元素<strong>已经翻转次数</strong> ，等价于被前面 <code>K - 1</code>个元素翻转的次数。</p>
<ol>
<li>若是<strong>偶数次</strong>，当前元素<strong>初值为 0</strong>，则需要再次翻转；</li>
<li>若是<strong>奇数次</strong>，当前元素<strong>初值为 1</strong>，则需要再次翻转。</li>
</ol>
<p>【补充】关于<strong>已翻转次数</strong>。给定一个大小为 K 的滑动窗口，若最左侧元素为 0 ，则翻转窗口，我们就可以看成，窗口内后 <code>K-1</code> 个元素被第一个元素翻转一次。因此某一元素的已翻转次数也就等于它前面 <code>K - 1</code> 个元素中导致发生翻转的元素个数。</p>
<p>【实际算法】</p>
<ol>
<li>使用队列记录当前元素的前 <code>K - 1</code> 个元素中导致发生翻转的元素索引。</li>
<li>队头元素不能与当前元素在同一窗口内，队头出队。</li>
<li>队列中元素个数即为当前元素已翻转次数。</li>
<li>当前元素导致发生翻转，则当前元素索引入队。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; indexQueue;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 超出窗口大小：队头元素不能与当前元素在同一窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (!indexQueue.empty() &amp;&amp; indexQueue.front() + K &lt;= i) &#123;</span><br><span class="line">                indexQueue.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已翻转偶数次 且 当前为 0 (indexQueue.size() &amp; 1) == 0 &amp;&amp; A[i] == 0</span></span><br><span class="line">            <span class="comment">// 已翻转奇数次 且 当前为 1 (indexQueue.size() &amp; 1) == 1 &amp;&amp; A[i] == 1</span></span><br><span class="line">            <span class="keyword">if</span> ((indexQueue.size() &amp; <span class="number">1</span>) == A[i]) &#123; </span><br><span class="line">                indexQueue.push(i);</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!indexQueue.empty() &amp;&amp; indexQueue.back() + K &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-1438.绝对差不超过限制的最长连续子数组</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-1438.%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438.绝对差不超过限制的最长连续子数组"></a>1438.绝对差不超过限制的最长连续子数组</h2><blockquote>
<p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p>
<p>如果不存在满足条件的子数组，则返回 0 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit">https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit</a></p>
</blockquote>
<h2 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h2><ol>
<li>标识子数组，可用双指针 ——【滑动窗口】</li>
<li>记录子数组中的最大值，最小值 </li>
</ol>
<p>关于记录子数组中的最大值与最小值，有多种方法：</p>
<p>  方法一：暴力查找（显然不是好方法）</p>
<p>  方法二：<strong>滑动窗口 + 堆 + 延迟删除</strong> （类似于 <a href="https://jakelin.cn/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0/#%E9%A2%98%E8%A7%A3">JakeLin’s Blog: 480-滑动窗口中位数-堆+延迟删除</a> ）</p>
<p>  方法三：<strong>滑动窗口 + 单调队列</strong> （使用<strong>双端队列</strong>是为方便删除队头、队尾） </p>
<h2 id="方法三：滑动窗口-单调队列"><a href="#方法三：滑动窗口-单调队列" class="headerlink" title="方法三：滑动窗口 + 单调队列"></a>方法三：滑动窗口 + 单调队列</h2><p>【<strong>滑动窗口</strong>】双指针实现</p>
<p>【<strong>单调队列</strong>】维护两个单调队列，以记录子数组中的 <strong>最大值</strong> 与 <strong>最小值</strong> 。（使用 <strong>双端队列</strong> 是为方便删除队头、队尾） </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 双指针 标识子数组</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQueue, minQueue; <span class="comment">// 单调队列 子数组中的最值</span></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            <span class="comment">// 最大值 单调队列</span></span><br><span class="line">            <span class="keyword">while</span> (!maxQueue.empty() &amp;&amp; maxQueue.back() &lt; nums[right]) &#123;</span><br><span class="line">                maxQueue.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            maxQueue.push_back(nums[right]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最小值 单调队列</span></span><br><span class="line">            <span class="keyword">while</span> (!minQueue.empty() &amp;&amp; minQueue.back() &gt; nums[right]) &#123;</span><br><span class="line">                minQueue.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            minQueue.push_back(nums[right]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 子数组不满足条件 滑动窗口左边界右移</span></span><br><span class="line">            <span class="keyword">while</span> (!maxQueue.empty() &amp;&amp; !minQueue.empty() &amp;&amp; (maxQueue.front() - minQueue.front()) &gt; limit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == maxQueue.front()) &#123;</span><br><span class="line">                    maxQueue.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == minQueue.front()) &#123;</span><br><span class="line">                    minQueue.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数合集</title>
    <url>/leetcode/%E4%B8%91%E6%95%B0%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="丑数的定义"><a href="#丑数的定义" class="headerlink" title="丑数的定义"></a>丑数的定义</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。</p>
<blockquote>
<p>1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
</blockquote>
<h3 id="丑数的判断"><a href="#丑数的判断" class="headerlink" title="丑数的判断"></a>丑数的判断</h3><p>依次循环除以2、3、5直到不能整除，最后值为1则为丑数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">7</span>)     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出第N大的丑数"><a href="#找出第N大的丑数" class="headerlink" title="找出第N大的丑数"></a>找出第N大的丑数</h3><p>【思路】 <strong>动态规划</strong></p>
<p>丑数可以看做是2、3、5的幂的积。</p>
<p>根据幂得到一个丑数容易，问题的难点在于如何使得数据有序。依次递增存储丑数，使用三指针记录当前乘以2、3、5待选的丑数索引，再记录待选中间结果减少计算次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">7</span>) <span class="keyword">return</span> n; <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uglyNums</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// n个丑数 第一个为1</span></span><br><span class="line">    <span class="keyword">int</span> index_2 = <span class="number">0</span>, index_3 = <span class="number">0</span>, index_5 = <span class="number">0</span>; <span class="comment">// 当前乘2、3、5的丑数列表中值的下标</span></span><br><span class="line">    <span class="keyword">int</span> tmp_2 = <span class="number">2</span>, tmp_3 = <span class="number">3</span>, tmp_5 = <span class="number">5</span>;        <span class="comment">// 乘2、3、5的待选丑数（减少计算次数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        uglyNums[i] = min(tmp_2, min(tmp_3, tmp_5)); <span class="comment">// 取最小值</span></span><br><span class="line">        <span class="comment">// 更新待选丑数</span></span><br><span class="line">        <span class="comment">// 存在待选值相等的情况</span></span><br><span class="line">        <span class="keyword">if</span>(uglyNums[i] == tmp_2)&#123;</span><br><span class="line">            tmp_2 = uglyNums[++index_2] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uglyNums[i] == tmp_3)&#123;</span><br><span class="line">            tmp_3 = uglyNums[++index_3] * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uglyNums[i] == tmp_5)&#123;</span><br><span class="line">            tmp_5 = uglyNums[++index_5] * <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uglyNums[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超级丑数"><a href="#超级丑数" class="headerlink" title="超级丑数"></a>超级丑数</h3><p>超级丑数是指其所有质因数都是长度为 <code>k</code> 的质数列表 <code>primes</code> 中的正整数。</p>
<p>【思路】 <strong>动态规划</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到最小待选结果索引集合</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinValueIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minValue = tmp[<span class="number">0</span>];  <span class="comment">// 待选最小值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minValueIndexs</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] &lt; minValue)&#123;</span><br><span class="line">            minValue = tmp[i]; <span class="comment">// 最小值</span></span><br><span class="line">            minValueIndexs.clear(); <span class="comment">// 擦除旧索引</span></span><br><span class="line">            minValueIndexs.push_back(i); <span class="comment">// 新索引</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == minValue)&#123;</span><br><span class="line">            minValueIndexs.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minValueIndexs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第N个超级丑数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uglyNums</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// n个丑数  第一个丑数是1</span></span><br><span class="line">    <span class="keyword">int</span> k = primes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(k, <span class="number">0</span>)</span></span>;    <span class="comment">// 索引</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(primes)</span></span>;    <span class="comment">// 待选数据缓冲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpIndex = findMinValueIndex(tmp, k); <span class="comment">// 最小待选值索引</span></span><br><span class="line">        uglyNums[i] = tmp[tmpIndex[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; val : tmpIndex)&#123;</span><br><span class="line">            ++index[val];</span><br><span class="line">            tmp[val] = uglyNums[index[val]] * primes[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uglyNums[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="丑数-III-—-二分"><a href="#丑数-III-—-二分" class="headerlink" title="丑数 III — 二分"></a>丑数 III — 二分</h3><blockquote>
<p>请你帮忙设计一个程序，用来找出第 <code>n</code> 个丑数。</p>
<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong>。（1不算丑数）</p>
<p>来源：力扣 <a href="https://leetcode-cn.com/problems/ugly-number-iii/">https://leetcode-cn.com/problems/ugly-number-iii/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/** 【二分法】</span></span><br><span class="line"><span class="comment">给定一个丑数 X :</span></span><br><span class="line"><span class="comment">    1. 该数只能被a整除 (该数一定是a 的整数倍)   &#123;X/a&#125; - &#123;情况4 + 情况5 + 情况7&#125;</span></span><br><span class="line"><span class="comment">    2. 该数只能被b整除 (该数一定是b 的整数倍)   &#123;X/b&#125; - &#123;情况4 + 情况6 + 情况7&#125;</span></span><br><span class="line"><span class="comment">    3. 该数只能被c整除 (该数一定是c 的整数倍)   &#123;X/c&#125; - &#123;情况5 + 情况6 + 情况7&#125;</span></span><br><span class="line"><span class="comment">    4. 该数只能被a和b同时整除 (该数一定是a、b最小公倍数的整数倍)        &#123;X/ab&#125; - &#123;情况7&#125;</span></span><br><span class="line"><span class="comment">    5. 该数只能被a和c同时整除 (该数一定是a、c最小公倍数的整数倍)        &#123;X/ac&#125; - &#123;情况7&#125;</span></span><br><span class="line"><span class="comment">    6. 该数只能被b和c同时整除 (该数一定是b、c最小公倍数的整数倍)        &#123;X/bc&#125; - &#123;情况7&#125;</span></span><br><span class="line"><span class="comment">    7. 该数只能被a和b和c同时整除 (该数一定是a、b、c的最小公倍数的整数倍) &#123;X/abc&#125;</span></span><br><span class="line"><span class="comment">(1, X] 有多少个丑数 :</span></span><br><span class="line"><span class="comment">    &#123;X/a&#125; + &#123;X/b&#125; + &#123;X/c&#125; - &#123;X/ab&#125; - &#123;X/ac&#125; - &#123;X/bc&#125; + &#123;X/abc&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ab, ac, bc, abc;  <span class="comment">// 最小公倍数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">二分查找第 n 个正整数丑数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>&amp; n, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span>&amp; c, <span class="keyword">long</span> <span class="keyword">long</span> left, <span class="keyword">long</span> <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算 (1, mid] 有多少个丑数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = mid/a + mid/b + mid/c - mid/ab - mid/ac - mid/bc + mid/abc; </span><br><span class="line">    <span class="keyword">if</span>(num == n)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; n)</span><br><span class="line">        <span class="keyword">return</span> binarySearch(n, a, b, c, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(n, a, b, c, left, mid<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两数最小公倍数</span></span><br><span class="line"><span class="comment">// 乘积 = 最小公倍数 * 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">leastCommonMultiple</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mult = (<span class="keyword">long</span> <span class="keyword">long</span>)a * b;</span><br><span class="line">    <span class="comment">// 辗转相除求最大公约数</span></span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mult / a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 计算最小公倍数</span></span><br><span class="line">        ab = leastCommonMultiple(a, b);</span><br><span class="line">        ac = leastCommonMultiple(a, c);</span><br><span class="line">        bc = leastCommonMultiple(b, c);</span><br><span class="line">        abc = leastCommonMultiple(ab, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = min(a, min(a, b));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> right = left * n;     <span class="comment">// 第 n 个丑数不超过第一个丑数的 n 倍</span></span><br><span class="line">        <span class="keyword">long</span> ans = binarySearch(n, a, b, c, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans - min(ans % a, min(ans % b, ans % c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>丑数</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-买卖股票问题合集</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="买卖股票的最佳时机（动态规划）"><a href="#买卖股票的最佳时机（动态规划）" class="headerlink" title="买卖股票的最佳时机（动态规划）"></a>买卖股票的最佳时机（动态规划）</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你<strong>最多只允许完成一笔交易</strong>（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">前i天的最大收益 = max&#123;前i-1天的最大收益, 第i天的价格 - 前i-1天中的最低价格&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre_min = prices[<span class="number">0</span>]; <span class="comment">// 前 i-1 天中的最低价格</span></span><br><span class="line">    <span class="keyword">int</span> max_earn = <span class="number">0</span>;        <span class="comment">// 前 i-1 天的最大收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        max_earn = max(max_earn, prices[i] - pre_min);</span><br><span class="line">        pre_min = min(pre_min, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_earn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-II（贪心）"><a href="#买卖股票的最佳时机-II（贪心）" class="headerlink" title="买卖股票的最佳时机 II（贪心）"></a>买卖股票的最佳时机 II（贪心）</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你<strong>可以尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 【贪心】</span></span><br><span class="line"><span class="comment">    // 遇到低价（比前后都低）便买入</span></span><br><span class="line"><span class="comment">    // 遇到高价比前后都高）就卖出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 持有时间必然是价格上升时间段 才有最大利益</span></span><br><span class="line"><span class="comment">    // \          /</span></span><br><span class="line"><span class="comment">    //  \  /\    /</span></span><br><span class="line"><span class="comment">    //   \/  \  /</span></span><br><span class="line"><span class="comment">    //        \/</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])</span><br><span class="line">                sum += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-III（动态规划）"><a href="#买卖股票的最佳时机-III（动态规划）" class="headerlink" title="买卖股票的最佳时机 III（动态规划）"></a>买卖股票的最佳时机 III（动态规划）</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你<strong>最多</strong>可以完成 <strong>两笔</strong> 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、无买卖操作            0</span></span><br><span class="line"><span class="comment">    2、第一次买入            buy_first</span></span><br><span class="line"><span class="comment">    3、第一次买卖交易完成     sell_first</span></span><br><span class="line"><span class="comment">    4、第二次买入            buy_second</span></span><br><span class="line"><span class="comment">    5、第二次交易完成        sell_second</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> buy_first = -prices[<span class="number">0</span>], sell_first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy_second = -prices[<span class="number">0</span>], sell_second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        sell_second = max(sell_second, prices[i] + buy_second);</span><br><span class="line">        buy_second = max(buy_second, sell_first - prices[i]);</span><br><span class="line">        sell_first = max(sell_first, buy_first + prices[i]);</span><br><span class="line">        buy_first = max(buy_first, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(sell_first, sell_second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-IV（动态规划）"><a href="#买卖股票的最佳时机-IV（动态规划）" class="headerlink" title="买卖股票的最佳时机 IV（动态规划）"></a>买卖股票的最佳时机 IV（动态规划）</h3><blockquote>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a> </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、无买卖操作               0</span></span><br><span class="line"><span class="comment">    2、第j次买入股票            buy[j]  0 &lt; j &lt;= k</span></span><br><span class="line"><span class="comment">    3、第j次卖出股票            sell[j]  0 &lt; j &lt;= k</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || days &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buy</span><span class="params">(k, -prices[<span class="number">0</span>])</span></span>;  <span class="comment">// buy[j] 第j次买入股票后的收益</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sell</span><span class="params">(k, <span class="number">0</span>)</span></span>;          <span class="comment">// sell[j] 第j次卖出股票后的收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = k - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">            sell[j] = max(sell[j], buy[j] + prices[i]);</span><br><span class="line">            buy[j] = max(buy[j], sell[j<span class="number">-1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sell[<span class="number">0</span>] = max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + prices[i]);</span><br><span class="line">        buy[<span class="number">0</span>] = max(buy[<span class="number">0</span>], -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_earn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; val : sell)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_earn &lt; val)</span><br><span class="line">            max_earn = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_earn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机含手续费（动态规划）"><a href="#买卖股票的最佳时机含手续费（动态规划）" class="headerlink" title="买卖股票的最佳时机含手续费（动态规划）"></a>买卖股票的最佳时机含手续费（动态规划）</h3><blockquote>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、持有股票     hold</span></span><br><span class="line"><span class="comment">    2、售出股票     sellout</span></span><br><span class="line"><span class="comment">* 最后一天不持有股票的利润肯定更大</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hold = -prices[<span class="number">0</span>]; <span class="comment">// 持有股票</span></span><br><span class="line">    <span class="keyword">int</span> sellout = <span class="number">0</span>;        <span class="comment">// 售出股票 不持有</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_hold = max(hold, sellout - prices[i]); </span><br><span class="line">        sellout = max(sellout, hold + prices[i] - fee);</span><br><span class="line">        hold = tmp_hold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sellout; <span class="comment">// 最后一天不持有股票利润肯定更大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最佳买卖股票时机含冷冻期（动态规划）"><a href="#最佳买卖股票时机含冷冻期（动态规划）" class="headerlink" title="最佳买卖股票时机含冷冻期（动态规划）"></a>最佳买卖股票时机含冷冻期（动态规划）</h3><blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、持有股票     hold</span></span><br><span class="line"><span class="comment">    2、售出股票     sell</span></span><br><span class="line"><span class="comment">    3、冷静期       cool</span></span><br><span class="line"><span class="comment">* 最后一天不持有股票的利润肯定更大</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hold = -prices[<span class="number">0</span>];  <span class="comment">// 持有</span></span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;           <span class="comment">// 售出</span></span><br><span class="line">    <span class="keyword">int</span> cool = <span class="number">0</span>;           <span class="comment">// 冷静期</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_sell = max(sell, hold + prices[i]);</span><br><span class="line">        <span class="keyword">int</span> tmp_hold = max(hold, cool -prices[i]);</span><br><span class="line">        cool = max(cool, sell);</span><br><span class="line">        sell = tmp_sell;</span><br><span class="line">        hold = tmp_hold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-47.全排列II</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-47.%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><blockquote>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,2],</span><br><span class="line">[1,2,1],</span><br><span class="line">[2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p>这个题和《剑指offer》的一个排列题一样，允许字符重复。（LJ牛客，测试用例没覆盖全）</p>
<p>首先想到解决字符有重复就是先排序。在传递数组值得时候，如果是值传递那问题就简单了些。<strong>连续有序的序列中，依序用后续序列中的不重复的值替换第一个值，每次替换后，后续序列都是连续有序的！（这里非常巧妙）</strong></p>
<p>但是换作引用传递，事情就复杂了，每次递归处理前需要排序一次，还要考虑替换后的复原，避免重复选择等问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="comment">//if(nums.size() &gt; 0)&#123;</span></span><br><span class="line">    sort(nums.begin(), nums.end()); <span class="comment">// 先排序</span></span><br><span class="line">    range(nums, <span class="number">0</span>, res);</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nums 通过值传递</span></span><br><span class="line"><span class="comment">// 每次交换后 后续序列还是连续有序序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start_index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start_index == nums.size()<span class="number">-1</span>)&#123;</span><br><span class="line">        res.push_back(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start_index; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != start_index &amp;&amp; nums[start_index] == nums[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        swap(nums[start_index], nums[i]);</span><br><span class="line">        range(nums, start_index+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-907.子数组的最小值之和</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-907.%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a>907. 子数组的最小值之和</h2><blockquote>
<p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p>
<p>由于答案可能很大，因此返回答案模 10^9 + 7。 </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 </span><br><span class="line">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A &lt;= 30000</code></li>
<li><code>1 &lt;= A[i] &lt;= 30000</code></li>
</ol>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/">https://leetcode-cn.com/problems/sum-of-subarray-minimums/</a></p>
</blockquote>
<p><strong>【解题】</strong></p>
<p>也就是计算数组 A 的所有连续子数组中最小值的总和。如果计算出每个位置的数为连续子数组中最小值的次数，那么也就得目标结果。</p>
<h3 id="方法一：暴力（超时）"><a href="#方法一：暴力（超时）" class="headerlink" title="方法一：暴力（超时）"></a>方法一：暴力（超时）</h3><p>首先想到的是，对于数组中的一个数，从当前位置开始，往左右查找，直到找到比它更小（在右侧，不大于当前值）的值或是到了数组边界。</p>
<p><strong>时间复杂度</strong> ：<strong>O(n^2)</strong> </p>
<p><strong>空间复杂度</strong> ：<strong>O(1)</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="keyword">int</span> left_small_index, right_small_index;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> current_index = <span class="number">0</span>; current_index &lt; A.size(); ++current_index)&#123;</span><br><span class="line">        <span class="comment">// 往左侧查找第一个不小于当前值的位置</span></span><br><span class="line">        left_small_index = current_index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left_small_index &gt;= <span class="number">0</span> &amp;&amp; A[left_small_index] &gt; A[current_index]) <span class="comment">// 此处不取等 </span></span><br><span class="line">            --left_small_index;</span><br><span class="line">        <span class="comment">// 往右侧查找小于当前值的位置</span></span><br><span class="line">        right_small_index = current_index + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 此处取等 当有重复数字时也满足</span></span><br><span class="line">        <span class="keyword">while</span>(right_small_index &lt; n &amp;&amp; A[right_small_index] &gt;= A[current_index]) </span><br><span class="line">            ++right_small_index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连续子数组中 A[current_index] 为最小值的 数组组合方式</span></span><br><span class="line">        <span class="comment">// 当前位置前有 current_index - left_small_index 种取法</span></span><br><span class="line">        <span class="comment">// 当前位置后有 right_small_index - current_index 种取法</span></span><br><span class="line">        sum += (current_index - left_small_index) * (right_small_index - current_index) * A[current_index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际我们每次向后查找时，可以更新部分位置元素左侧最后一个更小值的位置。减少一次查找，但是要多使用一个辅助数组。</p>
<p><strong>时间复杂度</strong> ：<strong>O(n^2)</strong> </p>
<p><strong>空间复杂度</strong> ：<strong>O(n)</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_small_index</span><span class="params">(n, <span class="number">-1</span>)</span></span>;  <span class="comment">// 左侧比当前位置更小的最后一个元素位置</span></span><br><span class="line">    <span class="keyword">int</span> right_small_index;   </span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> current_index = <span class="number">0</span>; current_index &lt; A.size(); ++current_index)&#123;</span><br><span class="line">        <span class="comment">// 往右侧查找小于当前值的位置</span></span><br><span class="line">        right_small_index = current_index + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 此处取等 当有重复数字时也满足</span></span><br><span class="line">        <span class="keyword">while</span>(right_small_index &lt; n &amp;&amp; A[right_small_index] &gt;= A[current_index]) &#123;</span><br><span class="line">            left_small_index[right_small_index] = current_index;</span><br><span class="line">            ++right_small_index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连续子数组中 A[current_index] 为最小值的 数组组合方式</span></span><br><span class="line">        <span class="comment">// 当前位置前有 current_index - left_small_index[current_index] 种取法</span></span><br><span class="line">        <span class="comment">// 当前位置后有 right_small_index - current_index 种取法</span></span><br><span class="line">        sum += (current_index - left_small_index[current_index]) * (right_small_index - current_index) * A[current_index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><p>利用单调递增栈，计算当前值在连续子数组中为最小值的次数。即，需要找到当前值，往前第一个小于、往后第一个小于等于它的元素。</p>
<p><strong>时间复杂度</strong> ：<strong>O(n)</strong> </p>
<p><strong>空间复杂度</strong> ：<strong>O(n)</strong> </p>
<p>【<strong>单调栈在本题的应用</strong>】</p>
<ul>
<li>单调栈，保存还未找齐小于（或在右侧，小于等于）栈顶所指元素的索引；</li>
<li>若当前元素 &lt;= 栈顶索引对应的元素，则栈顶对于的元素右侧第一个小于等于它的元素；</li>
<li>经过上一步，栈内索引所指元素必然小于当前元素；</li>
<li>若栈非空，则栈顶索引对应的元素即为当前元素左侧最后一个小于其值的元素；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算当前值在连续子数组中为最小值的次数 单调递增栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = A.size(); </span><br><span class="line">    <span class="comment">// 栈内存放的是在当前位置左侧的数，且还未得到其右侧第一个小于等于其值的数</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; greater_stack; <span class="comment">// 单调递增栈    </span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_small_index</span><span class="params">(A.size(), <span class="number">-1</span>)</span></span>;    <span class="comment">// 左侧最后一个小于当前位置值的索引</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_small_index</span><span class="params">(A.size(), n)</span></span>;    <span class="comment">// 右侧第一个小于等于当前位置值的索引</span></span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> current_index = <span class="number">0</span>; current_index &lt; n; ++current_index)&#123;</span><br><span class="line">        <span class="comment">// 当前数值大于等于栈顶所指的值 则栈顶元素右边第一个大于等于它的值出现</span></span><br><span class="line">        <span class="keyword">while</span>(!greater_stack.empty() &amp;&amp; A[current_index] &lt;= A[greater_stack.top()])&#123;</span><br><span class="line">            right_small_index[greater_stack.top()] = current_index; <span class="comment">// 记录右侧第一个大于等于它的值的索引</span></span><br><span class="line">            greater_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈非空，因为是单调递增栈，故得到当前元素左侧最后一个小于它的值</span></span><br><span class="line">        <span class="keyword">if</span>(!greater_stack.empty()) &#123;</span><br><span class="line">            left_small_index[current_index] = greater_stack.top();  <span class="comment">// 记录左侧最后一个小于它的值的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前值索引进栈</span></span><br><span class="line">        greater_stack.push(current_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再算总和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; A.size(); ++index)&#123;</span><br><span class="line">        sum += (index - left_small_index[index]) * (right_small_index[index] - index) * (<span class="keyword">long</span>)A[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-480.滑动窗口中位数</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-480.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480. 滑动窗口中位数"></a>480. 滑动窗口中位数</h2><blockquote>
<p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p>
<p>例如：</p>
<ul>
<li><p>[2,3,4]，中位数是 3</p>
</li>
<li><p>[2,3]，中位数是 (2 + 3) / 2 = 2.5</p>
</li>
</ul>
<p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>
<p>给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗口位置                      中位数</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7      -1</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7      -1</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       5</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      6</span><br></pre></td></tr></table></figure>

<p> 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。</p>
<p>提示：</p>
<ul>
<li>你可以假设 k 始终有效，即：k 始终小于输入的非空数组的元素个数。</li>
<li>与真实值误差在 10 ^ -5 以内的答案将被视作正确答案。</li>
</ul>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/sliding-window-median">https://leetcode-cn.com/problems/sliding-window-median</a></p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>【思路】</p>
<p>看到计算 <strong>中位数</strong> ，首先想到的是 <strong>堆</strong> 。将较小的半部分放在大顶堆中，较大的部分放在小顶堆中，并且满足「小顶堆大小」与「大顶堆大小」的平衡关系，即可很方便的取得中位数。顺着这个思路我们需要做的是：</p>
<ol>
<li>提供大顶堆和小顶堆；</li>
<li>添加数据，并且要平衡大小顶堆的大小；</li>
<li>删除数据，并且要平衡大小顶堆的大小；</li>
<li>获取中位数，本题中也就是根据滑动窗口大小取堆顶元素（窗口大小为奇数，则中位数为小顶堆堆顶；为偶数，则取两堆顶的平均值）。</li>
</ol>
<p>现在问题又来了，从堆中删除指定数据是件麻烦的事，堆结构只能删除堆顶元素。</p>
<p>解决的一种方法就是 <strong>延迟删除</strong> ，我们先记下来该元素待删除，当该元素在堆顶的时候就把它清除掉。这时我们在上一步的基础上，需要补充的有这些：</p>
<ol>
<li>记录待删除元素的待删除次数；</li>
<li>需要有两个值分别记录两个堆中的有效数据个数；</li>
<li>如何确保堆顶元素有效：<ol>
<li>新增数据不会影响堆顶元素的有效性；</li>
<li>删除堆中数据可能影响到堆顶元素的有效性（包括删除窗口最左侧值、调整堆大小时的删除操作）。</li>
</ol>
</li>
</ol>
<p>【<strong>总结思路</strong>】 <strong>堆</strong> + <strong>哈希表</strong> </p>
<ol>
<li>提供大小堆数据结构，并记录各堆中的有效数据个数；</li>
<li>延迟删除，记录待删除元素的待删除次数（哈希表）；</li>
<li>要平衡大小堆，保证大小堆的有效元素个数关系；</li>
<li>保证堆顶元素有效性，在堆的的删除操作后清除无效的堆顶元素；</li>
<li>提供 添加元素、删除元素、获取中位数 的接口。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxMinHeap</span> &#123;</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; maxHeap;    <span class="comment">// 大顶堆 </span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; minHeap;  <span class="comment">// 小顶堆 </span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; delCountHash;   <span class="comment">// 哈希表 待删除次数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> maxHeapNums, minHeapNums;   <span class="comment">// 大小堆中的有效值数量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 调整大小堆元素比例 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeapNums - minHeapNums &gt; <span class="number">1</span>) &#123; <span class="comment">// 要从大顶堆取未删除的最大值放到小顶堆</span></span><br><span class="line">            minHeap.push(maxHeap.top());</span><br><span class="line">            maxHeap.pop();</span><br><span class="line">            ++minHeapNums;</span><br><span class="line">            --maxHeapNums;</span><br><span class="line">            <span class="comment">// 保证堆顶元素未删除</span></span><br><span class="line">            <span class="keyword">while</span> (!maxHeap.empty() &amp;&amp; delCountHash[maxHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --delCountHash[maxHeap.top()];</span><br><span class="line">                maxHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxHeapNums &lt; minHeapNums) &#123; <span class="comment">// 从小顶堆中取未删除的最小值放到大顶堆</span></span><br><span class="line">            maxHeap.push(minHeap.top());</span><br><span class="line">            minHeap.pop();</span><br><span class="line">            ++maxHeapNums;</span><br><span class="line">            --minHeapNums;</span><br><span class="line">            <span class="comment">// 保证堆顶元素未删除</span></span><br><span class="line">            <span class="keyword">while</span> (!minHeap.empty() &amp;&amp; delCountHash[minHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --delCountHash[minHeap.top()];</span><br><span class="line">                minHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxMinHeap(<span class="keyword">int</span> k) : n(k), maxHeapNums(<span class="number">0</span>), minHeapNums(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据数据值 插入指定堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.empty() || maxHeap.top() &gt;= value) &#123;</span><br><span class="line">            maxHeap.push(value);</span><br><span class="line">            ++maxHeapNums;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.push(value);</span><br><span class="line">            ++minHeapNums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调整大小堆元素比例 </span></span><br><span class="line">        adjust();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        ++delCountHash[value]; <span class="comment">// 先记录下待删除</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.top() &gt;= value) &#123;</span><br><span class="line">            --maxHeapNums;</span><br><span class="line">            <span class="comment">// 每次删除 保证堆顶元素不是待删除元素</span></span><br><span class="line">            <span class="keyword">while</span> (!maxHeap.empty() &amp;&amp; delCountHash[maxHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --delCountHash[maxHeap.top()];</span><br><span class="line">                maxHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --minHeapNums;</span><br><span class="line">            <span class="comment">// 每次删除 保证堆顶元素不是待删除元素</span></span><br><span class="line">            <span class="keyword">while</span> (!minHeap.empty() &amp;&amp; delCountHash[minHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --delCountHash[minHeap.top()];</span><br><span class="line">                minHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调整大小堆元素比例 </span></span><br><span class="line">        adjust();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (n &amp; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> maxHeap.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)maxHeap.top() + minHeap.top()) / <span class="number">2.0</span>;  <span class="comment">// 两数相加可能造成越界  [2147483647,2147483647] 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大小为 k 的滑动窗口</span></span><br><span class="line">        <span class="function">MaxMinHeap <span class="title">window</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            window.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动滑动窗口 [left, right)</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span>, window.getMedian())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = k; right &lt; nums.size(); ++left, ++right) &#123;</span><br><span class="line">            window.add(nums[right]);</span><br><span class="line">            window.del(nums[left]);</span><br><span class="line">            ans.push_back(window.getMedian());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
        <tag>堆</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性</title>
    <url>/C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="数量不定的模板参数"><a href="#数量不定的模板参数" class="headerlink" title="数量不定的模板参数"></a>数量不定的模板参数</h2><p><strong>variadic-templates 数量不定的模板参数</strong>。<code>...</code> 就是所谓的 <strong>pack(包)</strong> ，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">// 参数传递：一个 + 一包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变化的是 template parameters：</p>
<ul>
<li>参数个数，参数的个数可以不再明确指出。</li>
<li>参数类型，“一包”数据中的数据类型可以是不同的类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head, Tail...&gt; :</span> <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tuple()&#123;&#125;</span><br><span class="line">    tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//auto head()-&gt;decltype(m_head) &#123; return m_head; &#125;</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; retrun *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>程序使用 <code>new</code> 从堆（自由存储区）分配内存，在不需要时，应使用 <code>delete</code> 将其释放。这个内存管理过程由程序员控制，内存泄露（主要是堆内存）是困扰C/C++程序员的一大难题。因此C++引入了智能指针 <code>auto_ptr</code> 以帮助自动完成这个过程。</p>
<p>在C++11中摒弃了auto_ptr，新增三种智能指针：</p>
<ul>
<li><p><code>shared_ptr</code> ：通过指针保持对象<strong>共享</strong>所有权的智能指针；</p>
</li>
<li><p><code>weak_ptr</code>：到 std::shared_ptr 所管理对象的<strong>弱引用</strong>，在访问所引用的对象前必须先转换为 std::shared_ptr ；</p>
</li>
<li><p><code>unique_ptr</code>： 拥有<strong>独有</strong>对象所有权语义的智能指针。</p>
</li>
</ul>
<p>详细见：</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>关键字 <code>decltype</code> （declare type）将变量的类型声明为表达式指定的类型。</p>
<blockquote>
<ol>
<li>声明 return types</li>
<li>模板间的应用，面对 obj 取其 class type</li>
<li>获取 lambda 类型</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>(d*i) q; <span class="comment">// same type as d*i, double</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;d) qd; <span class="comment">// same type as &amp;d, double *</span></span><br><span class="line"><span class="keyword">decltype</span>((d)) k; <span class="comment">// double &amp;</span></span><br></pre></td></tr></table></figure>

<p>C++11新增在函数名和参数列表后面指定返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">// 传统的语法</span></span><br><span class="line">auto f2(double, int) -&gt; double; // 新语法 返回类型double</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x+y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 因为编译到decltype(x+y)的时候 编译器不知道x y是什么东西</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) add(T1 x, T2 y);</span><br></pre></td></tr></table></figure>

<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda函数（也称lambda表达式），仿函数，匿名函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = [] &#123;</span><br><span class="line">    strd::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">l(); <span class="comment">// prints &quot;hello lambda&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>[...] (...) mutable   throwSpec    -&gt;retType  &#123;...&#125;</code> </p>
<blockquote>
<p>[…] ：lambda introducer 导入器，取外部的变量（传值、传引用）</p>
<p>(…) ：函数参数，可选，但后面三个可选项只要有一个就必须有 ()</p>
<p>mutable ：可选，</p>
<p>throwSpec ：可选，</p>
<p>-&gt;retType ：可选，返回类型</p>
</blockquote>
<h2 id="模板嵌套使用-gt-gt"><a href="#模板嵌套使用-gt-gt" class="headerlink" title="模板嵌套使用&gt;&gt;"></a>模板嵌套使用&gt;&gt;</h2><p>Space in Template Expressions</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="comment">// 在每个版本都适用 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;  <span class="comment">// c++11后可以</span></span><br></pre></td></tr></table></figure>

<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr and std::nullptr_t，C++11建议使用 <code>nullptr</code> 替代 <strong>0或NULL</strong> 给指针赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11之后指针可以用 nullptr代替 0 or NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">f(<span class="number">0</span>); <span class="comment">// call f(int)</span></span><br><span class="line">f(<span class="literal">NULL</span>); <span class="comment">// call f(int) if NULL is 0 ambiguous</span></span><br><span class="line">f(<span class="literal">nullptr</span>); <span class="comment">// call f(void*)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++中 <code>NULL</code> 仅仅是 <code>define NULL 0</code> 的一个宏定义，因此，有时候会产生歧义：<ul>
<li>0 既可以是指针常量，又可以是整形常量。</li>
<li><code>f(char*)</code> 和 <code>f(int)</code> ，参数传 <code>NULL</code> 的话到底该调用哪个？</li>
</ul>
</li>
<li><code>nullptr</code> 是一个空指针，可以被转换成其他任意<strong>指针类型</strong> 。</li>
</ul>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p><strong>编译器自动类型推导</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #1 c++11 you can declare a var or an object without specifiying type by using auto</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>; <span class="comment">// i has type int</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> d = f(); <span class="comment">// d has type double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 auto用于2种情况 第一种是type太长 另一种是复杂的表达式 lambda </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin(); <span class="comment">// vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span>&#123; <span class="comment">// l has the type of a lambda</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一致性初始化"><a href="#一致性初始化" class="headerlink" title="一致性初始化 {}"></a>一致性初始化 {}</h2><p><strong>Uniform Initialization 一致性初始化</strong>。C++11之前，新手很容易困惑如何初始化一个对象或变量，初始化可能发生在 <strong>() {} =</strong> 操作符。</p>
<p>C++11 后统一使用一个方法 <code>&#123;&#125;</code> 。之前的也是可以用。</p>
<p><strong>原理</strong>：编译器看到大括号 {t1,t2,tn}变做出一个 Initializer_list 他关联到一个array&lt;T,n&gt; 调用ctor的时候 array内的元素被编译器被逐一赋值给ctor。但如果参数参数是个Initializer_list 那就将参数打包直接发给函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++11 后统一用&#123;&#125;</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; city &#123;</span><br><span class="line">  <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;London&quot;</span>, <span class="string">&quot;Beijing&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">comlex&lt;<span class="keyword">int</span>&gt; c&#123;<span class="number">4.0</span>, <span class="number">3.0</span>&#125;; <span class="comment">// 等价于 c(4.0, 3.0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ 11 之前</span></span><br><span class="line">Rect r1 = &#123;<span class="number">3</span>,<span class="number">7</span>,&amp;area&#125;;</span><br><span class="line"><span class="function">Rect <span class="title">r1</span><span class="params">(<span class="number">3</span>,<span class="number">7</span>,&amp;area)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="初始化列表-initializer-list"><a href="#初始化列表-initializer-list" class="headerlink" title="初始化列表 initializer_list"></a>初始化列表 initializer_list</h2><p><strong>Initializer Lists</strong> ，<code>initializer_list&lt;type&gt; vals</code> 须是<strong>相同类型</strong>。<strong>variadic-templates</strong> 则可以是不同的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">// i没有定义初值</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;; <span class="comment">// j定义初值为0</span></span><br><span class="line"><span class="keyword">int</span>* p; <span class="comment">// 指针p没有初值</span></span><br><span class="line"><span class="keyword">int</span> *q&#123;&#125;; <span class="comment">// 指针q的初值是nullptr</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;initializer_list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持函数接受任意个数的参数</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; v&#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line"><span class="comment">// 的实现原理就是将&#123;1,2,3,4,5&#125;包装成initializer_list 调用参数是initializer_list的ctor</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = vals.begin(); p!=vals.end(); ++p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    P(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(int a,int b)=&quot;</span> &lt;&lt;a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    P(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; initlist) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(initializer_list&lt;int&gt;)=&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : initlist) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;        <span class="comment">// 调用 P(int a, int b)</span></span><br><span class="line">    P q&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;      <span class="comment">// 调用 P(initializer_list&lt;int&gt; initlist)</span></span><br><span class="line">    P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">23</span>&#125;;    <span class="comment">// 调用 P(initializer_list&lt;int&gt; initlist)</span></span><br><span class="line">    <span class="comment">// 调用构造函数</span></span><br><span class="line">    P s = &#123;<span class="number">77</span>, <span class="number">5</span>&#125;;    <span class="comment">// 调用 P(initializer_list&lt;int&gt; initlist)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>P(initializer_list&lt;int&gt; initlist)</code> 主函数中的 <code>P q&#123;77,5&#125;;</code> 将调用 <code>P(int a, int b)</code> 。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit for ctors taking <strong>more than</strong> one argument.</p>
<blockquote>
<p>旧版C++，explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值的构造函数。</p>
</blockquote>
<p><code>explicit</code> 键字的作用就是防止对象间实现 =赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (decl : coll)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = coll.begin(), end=coll.end(); pos!=end; ++pos) &#123;</span><br><span class="line">    decl = *pos</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="default、-delete"><a href="#default、-delete" class="headerlink" title="=default、=delete"></a>=default、=delete</h2><p>如何你自行定义了一个<strong>构造函数</strong>，那么编译器不会生成 default ctor。</p>
<p>如果强制加上 <code>=default</code> ，就可以重新获得使用 default ctor。</p>
<p><code>=delete</code> 是告诉编译器，不要该函数。</p>
<p><code>=default</code> 用于 <strong>Big-Five</strong>。<code>=delete</code> ，可以用于任何函数身上。 [<a href="https://www.feabhas.com/sites/default/files/2016-06/Rule%20of%20the%20Big%20Five.pdf]">https://www.feabhas.com/sites/default/files/2016-06/Rule%20of%20the%20Big%20Five.pdf]</a>(<a href="https://www.feabhas.com/sites/default/files/2016-06/Rule">https://www.feabhas.com/sites/default/files/2016-06/Rule</a> of the Big Five.pdf)</p>
<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><p><code>using</code> 类似于 <code>typedef</code> 能够创建别名。此外，<code>using</code> 还可用于模板部分具体化。模板模板参数（没搞懂）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedef std::vector&lt;std::string&gt;::iterator itType</span></span><br><span class="line"><span class="keyword">using</span> itType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">arr12</span> = <span class="title">std</span>:</span>:<span class="built_in">array</span>&lt;T, 12&gt;; <span class="comment">// 模板部分具体化</span></span><br><span class="line">arr12&lt;<span class="keyword">double</span>&gt; a1; <span class="comment">// 等价于 std::array&lt;double, 12&gt; a1;</span></span><br></pre></td></tr></table></figure>



<h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>在函数后面加上 noexcept 说明保证函数一定不会产生异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当存在 <strong>move constructor</strong> ，并且是 <strong>noexcept</strong> ，在增长时（如：vector）才会调用 <strong>move constructor</strong> 。</p>
<blockquote>
<p>能够增长的容器只有两种：vector、deque</p>
<p>只有 vector 才大量搬动元素</p>
</blockquote>
<h2 id="类内初始化"><a href="#类内初始化" class="headerlink" title="类内初始化"></a>类内初始化</h2><p>可以使用 <code>=</code>、<code>&#123;&#125;</code> 在类定义中初始化成员，但是不能使用 <strong>()</strong> 在类中进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> mem2 &#123;<span class="number">12.34</span>&#125;;</span><br><span class="line">    <span class="keyword">short</span> mem3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Session()&#123;&#125;</span><br><span class="line">    Session(<span class="keyword">short</span> s) : mem3(s) &#123;&#125;</span><br><span class="line">    <span class="comment">// 覆盖类内成员初始化</span></span><br><span class="line">    Session(<span class="keyword">int</span> i, <span class="keyword">double</span> d, <span class="keyword">short</span> s): mem1(i), mem2(d), mem3(s) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用（Rvalue references）是一种新的<strong>引用类型</strong>，能够<strong>减少非必要的拷贝</strong>。</p>
<p><strong>左值</strong>：可以出现在 operator= 左侧。</p>
<blockquote>
<p>int a = 9, b = 4;</p>
<p>a = b;         // OK</p>
<p>b = a;         // OK</p>
</blockquote>
<p><strong>右值</strong>：<strong>只能</strong>出现在 operator= 右侧。</p>
<blockquote>
<p>a + b = 42;         // Error!!!</p>
<p>string s1(“Hello”),  s2(“World”);</p>
<p>s1 + s2 = s2;         // 编译通过，s1、s2值未变</p>
<p>string() = “World”;     // 竟然可以对临时对象赋值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> i = foo();    <span class="comment">// OK </span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;foo(); <span class="comment">//Error!!!</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>左值引用</strong>，必须引用左值 <code>int a = 0; int &amp;b = a;</code> 。</li>
<li><strong>右值引用</strong>，可以引用结果 <code>int &amp;&amp; i = 0</code> 。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Default Constructor的构造操作</title>
    <url>/C++/Default%20Constructor%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Default Constructor 会 <strong>“在需要的时候”</strong> 被编译器产生出来。具体何时被产生呢？首先需要明确， <strong>“在需要的时候”</strong> 是针对<strong>编译器</strong>来说的。此外，被合成出来的 Constructor <strong>只执行编译器所需的行动</strong>，不会对数据进行初始化。</p>
<p>下面讨论什么情况下编译器会产生 Default Constructor：</p>
<h3 id="情况一：成员对象有默认构造函数"><a href="#情况一：成员对象有默认构造函数" class="headerlink" title="情况一：成员对象有默认构造函数"></a>情况一：成员对象有默认构造函数</h3><p><strong>条件</strong>：</p>
<ul>
<li>一个 class 没有任何构造函数；</li>
<li>内含一个<strong>成员对象</strong>，且该对象有默认构造函数。</li>
</ul>
<p>该情况下，隐式默认构造函数（implicit default constructor）对编译器而言就是有用的（nontrivial），编译器需要为该 class 合成一个默认构造函数。不过这个<strong>合成操作只有在构造函数真正被调用时才会发生</strong>。</p>
<p>有趣的问题：C++各个不同模块的编译中，编译器如何避免合成多个默认构造函数呢？解决方法是<strong>合成的默认构造函、拷贝构造函数、析构函数、赋值拷贝运算符都以<font color=red>inline</font>方式</strong>完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A();      &#x2F;&#x2F; 默认构造函数</span><br><span class="line">    A(int );</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    A a;    &#x2F;&#x2F; 内含</span><br><span class="line">    char *str; &#x2F;&#x2F; 不会被初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void function()&#123;</span><br><span class="line">    B b;    &#x2F;&#x2F; B::a 必须在此处初始化</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被合成的 class B 的默认构造函数内含必要代码。能调用 class A 的默认构造函数来处理该类的成员对象。默认构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline B::B()&#123;</span><br><span class="line">    &#x2F;&#x2F;伪代码</span><br><span class="line">    a.A::a(); &#x2F;&#x2F;调用成员对象的默认构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果有多个成员对象需要构造函数进行初始化操作，初始化顺序为<strong>成员对象的声明顺序</strong>。</p>
<blockquote>
<ol>
<li>基类先构造</li>
<li>复合（内含）成员对象构造</li>
<li>派生类（当前类）最后构造</li>
</ol>
</blockquote>
<h3 id="情况二：基类有默认构造函数"><a href="#情况二：基类有默认构造函数" class="headerlink" title="情况二：基类有默认构造函数"></a>情况二：基类有默认构造函数</h3><p><strong>条件</strong>：</p>
<ul>
<li>派生类没有任何构造函数；</li>
<li><strong>基类</strong>带有默认构造函。</li>
</ul>
<p>若已有多个构造函数，但是没有默认构造函数，编译器不会再合成一个默认构造函数。但是会扩充每一个构造函数，<strong>“用以调用所有有必要的默认构造函数（构造基类、复合成员对象）”</strong>。</p>
<h3 id="情况三：带有虚方法"><a href="#情况三：带有虚方法" class="headerlink" title="情况三：带有虚方法"></a>情况三：带有虚方法</h3><p><strong>条件</strong>：</p>
<ul>
<li>当前没没有任何构造函数；</li>
<li>两种情况：<ul>
<li>class 声明（或继承）一个 <code>virtual function</code>；</li>
<li>class 派生自一个<strong>继承链</strong>，其中有一个或多个 <code>virtual base class</code>。</li>
</ul>
</li>
</ul>
<p>编译阶段的扩张行动：</p>
<ol>
<li><strong>虚表</strong>。虚表会被编译器产生，内放类的虚函数地址；</li>
<li><strong>虚表指针</strong>。每一个类对象中，编译器会合成出一个额外的指针成员，以保存虚表地址。</li>
</ol>
<p>正是由于需要做上述扩展操作，对已有的每一个构造函数，编译器会安插一些代码来做这些事。对于未声明任何构造函数的类，编译器会为它合成一个默认构造函数，以正确额初始化每一个类对象的虚表指针。</p>
<h3 id="情况四：带有一个虚基类"><a href="#情况四：带有一个虚基类" class="headerlink" title="情况四：带有一个虚基类"></a>情况四：带有一个虚基类</h3><p><strong>条件</strong>：</p>
<ul>
<li>当前没没有任何构造函数；</li>
<li>有虚基类（<code>virtual base class</code>）。</li>
</ul>
<p>解释：菱形继承中使用了虚继承，编译器需要 ”允许每个虚基类的执行期存取操作“，即<strong>运行时确定</strong>，也就同虚函数类似了。对于未声明任何构造函数的类，编译器会为它合成一个默认构造函数。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-1052.爱生气的书店老板</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-1052.%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052.爱生气的书店老板"></a>1052.爱生气的书店老板</h2><blockquote>
<p>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner">https://leetcode-cn.com/problems/grumpy-bookstore-owner</a></p>
</blockquote>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>把老板控制情绪，看成是对服务质量的提升，那么这题就解决了。在老板不控制生气的情况下，顾客的满意数量是很显然的。现在老板可以控制 X 分钟不生气，其余时间不改变，那么也就是在这 X 分钟内，要有最大的顾客满意数量提升。</p>
<p>【<strong>滑动窗口</strong>】</p>
<ol>
<li>先计算正常生气情况下，客人的满意数量;</li>
<li>再采用滑动窗口，计算控制生气情况下，最大可提升的客人满意数量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minutes = customers.size();</span><br><span class="line">        <span class="comment">// 1、正常生气情况下，客人的满意数量</span></span><br><span class="line">        <span class="keyword">int</span> satisfied = <span class="number">0</span>; <span class="comment">// 默认情况下的满意数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minutes; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                satisfied += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、采用滑动窗口，计算控制生气情况下，最大可提升的客人满意数量</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; X &amp;&amp; right &lt; minutes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[right] == <span class="number">1</span>) &#123;</span><br><span class="line">                tmp += customers[right];</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> improve = tmp; <span class="comment">// 控制生气情况下的最大可提升满意数量</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; minutes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[right] == <span class="number">1</span>) &#123;</span><br><span class="line">                tmp += customers[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[left] == <span class="number">1</span>) &#123;</span><br><span class="line">                tmp -= customers[left];</span><br><span class="line">            &#125;</span><br><span class="line">            improve = max(improve, tmp);</span><br><span class="line">            ++left, ++right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> satisfied + improve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-03.数组中重复的数字</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03.数组中重复的数字"></a>03.数组中重复的数字</h2><blockquote>
<p>找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p>
</blockquote>
<h2 id="方法一：排序-遍历"><a href="#方法一：排序-遍历" class="headerlink" title="方法一：排序 + 遍历"></a>方法一：排序 + 遍历</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N*logN)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>排序后，数组元素有序，那么遍历数组，判断相邻元素是否相对即可找到重复元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 方法一：排序 + 遍历 **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_ordered</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、排序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：数组-count-n-记录-0-n-1-各出现的次数"><a href="#方法二：数组-count-n-记录-0-n-1-各出现的次数" class="headerlink" title="方法二：数组 count[n] 记录 0~n-1 各出现的次数"></a>方法二：数组 count[n] 记录 0~n-1 各出现的次数</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(N)</strong> </p>
</blockquote>
<p>排序使得时间复杂度为 <code>O(N*logN)</code> ，既然题目限制了 n 的大小，可以以空间换时间。使用辅助数组 count 记录各个数出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 方法二：数组 count[n] 记录 0~n-1 各出现的次数 **/</span></span><br><span class="line"><span class="comment">// 长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[val] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        ++count[val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三：哈希表记录-0-n-1-各出现的次数"><a href="#方法三：哈希表记录-0-n-1-各出现的次数" class="headerlink" title="方法三：哈希表记录 0~n-1 各出现的次数"></a>方法三：哈希表记录 0~n-1 各出现的次数</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(N)</strong> </p>
</blockquote>
<p>与方法二类似，只是使用哈希表记录各值出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 方法三：哈希表记录 0~n-1 各出现的次数 **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_hash</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashMap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap[val] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        ++hashMap[val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法四：直接通过原数组建立哈希表"><a href="#方法四：直接通过原数组建立哈希表" class="headerlink" title="方法四：直接通过原数组建立哈希表"></a>方法四：直接通过原数组建立哈希表</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>留意到题目信息，<strong>数组 nums 里的所有数字都在 0～n-1 的范围内</strong> 。我们可以直接在原数组中建立哈希表，<strong>索引值</strong> 与 <strong>元素值</strong> 相匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 方法四：直接通过原数组建立哈希表 **/</span></span><br><span class="line"><span class="comment">// 长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_direct_hash</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i) &#123; <span class="comment">// 刚好在对应hash位置</span></span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[nums[i]] == nums[i]) &#123; <span class="comment">// 已存在该数字</span></span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-11.旋转数组的最小数字</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.旋转数组的最小数字"></a>11.旋转数组的最小数字</h2><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 </p>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(logN)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>首先，原数组是递增的，旋转数组可以看成是部分递增（分成两段递增）。不考虑重复值的情况下，数组内元素大小关系变化如图所示：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E5%89%91%E6%8C%87Offer-11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.png" alt="剑指Offer-11.旋转数组的最小数字"></p>
<p>很显然，可以采用 【<strong>二分查找</strong>】</p>
<ul>
<li>若区间 [left, right] 有 <code>numbers[left] &lt; numbers[right]</code> ，那么第一个元素即为最小值；</li>
<li>若区间 [left, right] 有 <code>numbers[left] &gt;= numbers[right]</code> ，最小值在区间内，采用 <strong>二分法</strong> ，取中间位置 mid ；<ul>
<li>若 <code>numbers[left] &gt; numbers[mid]</code> ，则最小值在子区间 [left, mid] 中；</li>
<li>若 <code>numbers[left] == numbers[mid]</code> ：<ul>
<li>最小值在 [mid, right] ，必然是从左侧开始第一个小于 numbers[mid] 的值；</li>
<li>最小值在 [left, mid]，继续二分。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空数组没有预期输出</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 1、[left, right] 递增有序，最小值为 numbers[left]</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[left] &lt; numbers[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[left];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、最小值在区间 [left, right] 中</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 2.1 numbers[left] &gt; numbers[mid] 最小值在子区间 [left, mid] 中</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[left] &gt; numbers[mid]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.2 numbers[left] == numbers[mid]</span></span><br><span class="line">            <span class="comment">// 最小值在 [mid, right]，必然是从左侧开始第一个小于 numbers[mid] 的值</span></span><br><span class="line">            <span class="comment">// 否则，最小值在 [left, mid]</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (numbers[mid] &gt; numbers[i])</span><br><span class="line">                        <span class="keyword">return</span> numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-1178.猜字谜</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-1178.%E7%8C%9C%E5%AD%97%E8%B0%9C/</url>
    <content><![CDATA[<h2 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178.猜字谜"></a>1178.猜字谜</h2><blockquote>
<p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p>
<ul>
<li><p>单词 word 中包含谜面 puzzle 的第一个字母。</p>
</li>
<li><p>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</p>
</li>
</ul>
<p>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;输入：</span><br><span class="line">words &#x3D; [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class="line">puzzles &#x3D; [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class="line">输出：[1,1,3,2,4,0]</span><br><span class="line">解释：</span><br><span class="line">1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; </span><br><span class="line">1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;</span><br><span class="line">3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class="line">2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class="line">4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class="line">没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#39;g&#39;。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= words.length &lt;= 10^5</li>
<li>4 &lt;= words[i].length &lt;= 50</li>
<li>1 &lt;= puzzles.length &lt;= 10^4</li>
<li>puzzles[i].length == 7</li>
<li>words[i][j], puzzles[i][j] 都是小写英文字母。</li>
<li>每个 puzzles[i] 所包含的字符都不重复。</li>
</ul>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle">https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle</a></p>
</blockquote>
<p>注意到题目中，关于谜底的定义以及要求：</p>
<ul>
<li><p><strong>单词 word 中包含谜面 puzzle 的第一个字母。</strong></p>
</li>
<li><p><strong>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。</strong></p>
</li>
</ul>
<h2 id="方法一：生成字典数组"><a href="#方法一：生成字典数组" class="headerlink" title="方法一：生成字典数组"></a>方法一：生成字典数组</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(MN)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(M+N)</strong> </p>
</blockquote>
<p>要验证是否满足这两个条件，就需要判断字符是否在字符串中。不仅要判断字符是否在 word 中，还要判断字符是否在 puzzle 中。首先想到的就是 <strong>生成字典，记录字符串中各个字符是否出现（该题不关注字符出现多少次）</strong>。</p>
<ul>
<li>对于每个字符串（word、puzzle）都生成字典数组，给定一个长度为26的数组记录一个字符串对应字符是否出现；</li>
<li>匹配 puzzle 的第一个字母是否出现在 word 中；</li>
<li>匹配 word 中的每一个字母是否都在 puzzle 中。</li>
</ul>
<h2 id="改进一：位字典（超时）"><a href="#改进一：位字典（超时）" class="headerlink" title="改进一：位字典（超时）"></a>改进一：位字典（超时）</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(MN)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(M)</strong> </p>
</blockquote>
<p>我们留意到，<strong>方法一：生成字典数组</strong>，在进行匹配时，有个缺陷：<strong>需要匹配字典数组中的每一位（word 字典数组中的每一位）</strong>。有注意到一个条件：<strong>words[i][j], puzzles[i][j] 都是小写英文字母</strong>。我们就想到使用<strong>二进制位</strong>来表示对应的字符存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是小写英文字母</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordNums = words.size(); <span class="comment">// 1 &lt;= words.length &lt;= 10^5</span></span><br><span class="line">        <span class="keyword">int</span> puzzleNums = puzzles.size(); <span class="comment">// 1 &lt;= puzzles.length &lt;= 10^4</span></span><br><span class="line">        <span class="comment">// if (puzzleNums == 0)</span></span><br><span class="line">        <span class="comment">//     return &#123;&#125;;</span></span><br><span class="line">        <span class="comment">// 1、生成字典</span></span><br><span class="line">        <span class="comment">// word字典: 二进制位表示26个字符</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">wordDictionarys</span><span class="params">(wordNums, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordNums; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : words[i]) &#123;</span><br><span class="line">                wordDictionarys[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(puzzleNums, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzleNums; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> puzzleBit = <span class="number">0</span>; <span class="comment">// puzzle 位字典</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : puzzles[i]) &#123; <span class="comment">// puzzles[i].length == 7</span></span><br><span class="line">                puzzleBit |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; wordBit : wordDictionarys) &#123;</span><br><span class="line">                <span class="comment">// 2、匹配 puzzle 的第一个字母是否出现在 word 中</span></span><br><span class="line">                <span class="comment">// 3、匹配 word 中的每一个字母是否都在 puzzle 中</span></span><br><span class="line">                <span class="keyword">if</span> ((wordBit &amp; (<span class="number">1</span> &lt;&lt; (puzzles[i][<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>))) != <span class="number">0</span> &amp;&amp; (wordBit &amp; puzzleBit) == wordBit) &#123;</span><br><span class="line">                    ++ans[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="改进二：哈希表-子集位字典"><a href="#改进二：哈希表-子集位字典" class="headerlink" title="改进二：哈希表+子集位字典"></a>改进二：哈希表+子集位字典</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(M+N)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(M)</strong> </p>
</blockquote>
<p>上一步改进，虽然降低了空间复杂度，也减少了匹配运算，但是在数量级上，时间复杂度还是 <code>O(MN)</code> 。</p>
<p>留意题中信息 <strong>每个 <code>puzzles[i]</code> 所包含的字符都不重复</strong> ，我们再次改进：</p>
<ol>
<li>引入<strong>哈希表</strong>记录一个位字典数对应多少个 word。例如 <code>&quot;ab&quot;</code> 与 <code>&quot;aabb&quot;</code> 对应相同的位字典。</li>
<li>匹配改为<strong>查找子集位字典</strong>，puzzle 长度为7，首位必须取，剩下6位，直接暴力dfs。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 都是小写英文字母</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordNums = words.size(); <span class="comment">// 1 &lt;= words.length &lt;= 10^5</span></span><br><span class="line">        <span class="keyword">int</span> puzzleNums = puzzles.size(); <span class="comment">// 1 &lt;= puzzles.length &lt;= 10^4</span></span><br><span class="line">        <span class="comment">// if (puzzleNums == 0)</span></span><br><span class="line">        <span class="comment">//     return &#123;&#125;;</span></span><br><span class="line">        <span class="comment">// 1、生成字典</span></span><br><span class="line">        <span class="comment">// word字典: 二进制位表示26个字符</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; wordBitMap; <span class="comment">// 位字典哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordNums; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> wordBit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : words[i]) &#123;</span><br><span class="line">                wordBit |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++wordBitMap[wordBit];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(puzzleNums, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzleNums; ++i) &#123;</span><br><span class="line">            <span class="comment">// puzzle 子集位字典，首位必须取</span></span><br><span class="line">            <span class="comment">// 深度优先，puzzle子集</span></span><br><span class="line">            dfs(wordBitMap, puzzles[i], <span class="number">1</span> &lt;&lt; (puzzles[i][<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, ans[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; wordBitMap, <span class="built_in">string</span>&amp; puzzle, <span class="keyword">int</span> puzzleSubBit, <span class="keyword">int</span> index, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == puzzle.length()) &#123;</span><br><span class="line">            count += wordBitMap[puzzleSubBit];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(wordBitMap, puzzle, puzzleSubBit, index+<span class="number">1</span>, count);</span><br><span class="line">        dfs(wordBitMap, puzzle, puzzleSubBit | (<span class="number">1</span> &lt;&lt; (puzzle[index] - <span class="string">&#x27;a&#x27;</span>)), index+<span class="number">1</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-5690.最接近目标价格的甜点成本</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-5690.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="5690-最接近目标价格的甜点成本"><a href="#5690-最接近目标价格的甜点成本" class="headerlink" title="5690.最接近目标价格的甜点成本"></a>5690.最接近目标价格的甜点成本</h2><blockquote>
<p>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>
<ul>
<li>必须选择 <strong>一种</strong> 冰激凌基料。</li>
<li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。</li>
<li>每种类型的配料 <strong>最多两份</strong> 。</li>
</ul>
<p>给你以下三个输入：</p>
<ul>
<li>baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。</li>
<li>toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。</li>
<li>target ，一个整数，表示你制作甜点的目标价格。</li>
</ul>
<p>你希望自己做的甜点总成本尽可能接近目标价格 target 。<br>返回最接近 target 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：baseCosts &#x3D; [1,7], toppingCosts &#x3D; [3,4], target &#x3D; 10</span><br><span class="line">输出：10</span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 0 开始）：</span><br><span class="line">- 选择 1 号基料：成本 7</span><br><span class="line">- 选择 1 份 0 号配料：成本 1 x 3 &#x3D; 3</span><br><span class="line">- 选择 0 份 1 号配料：成本 0 x 4 &#x3D; 0</span><br><span class="line">总成本：7 + 3 + 0 &#x3D; 10 。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/closest-dessert-cost">https://leetcode-cn.com/problems/closest-dessert-cost</a></p>
</blockquote>
<h2 id="状态数组"><a href="#状态数组" class="headerlink" title="状态数组"></a>状态数组</h2><p>梳理一下题意，配置甜点的方案规则如下：</p>
<ol>
<li>选择一种基料</li>
<li>每种配料有以下可能：<ol>
<li>不配置</li>
<li>配置一份</li>
<li>配置两份</li>
</ol>
</li>
</ol>
<p>【目标】得到最接近 <code>target</code> 且值更小的甜点成本。</p>
<p>【<strong>方案分析</strong>】</p>
<p><strong>暴力的解法</strong> 就是记录所有配置方案，去计算每种方案的成本。</p>
<blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n * m)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(n * 3^m)</strong> </p>
</blockquote>
<p>尝试保存中间状态（中间配置方案），使用数组记录。实际上我们不需要记录配置的方案，只需要记录配置的价格，使得价格逼近 <code>target</code> 。超过 target 的价格，再增加后续的配料肯定不符合题意了，不用再考虑。</p>
<blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n * m)</strong>   最坏情况！</p>
<p>【<strong>空间复杂度</strong>】<strong>O(n * 2^m)</strong> </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">两种搭配方案：</span></span><br><span class="line"><span class="comment">    1、选择一种基料</span></span><br><span class="line"><span class="comment">    2、配料选择：</span></span><br><span class="line"><span class="comment">        a) 不配置</span></span><br><span class="line"><span class="comment">        b) 配置一份</span></span><br><span class="line"><span class="comment">        c) 配置两份</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; baseCosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; toppingCosts, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = baseCosts.size();</span><br><span class="line">        <span class="keyword">int</span> m = toppingCosts.size();</span><br><span class="line">        <span class="keyword">int</span> ans = baseCosts[<span class="number">0</span>];        </span><br><span class="line">        <span class="keyword">int</span> minAbs = <span class="built_in">abs</span>(baseCosts[<span class="number">0</span>] - target);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; base : baseCosts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(base - target) &lt; minAbs || (<span class="built_in">abs</span>(base - target) == minAbs &amp;&amp; base &lt; ans)) &#123;</span><br><span class="line">                ans = base;</span><br><span class="line">                minAbs = <span class="built_in">abs</span>(base - target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= base) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span>, base)</span></span>;  <span class="comment">// 只记录 target - cost &gt; 0 的值</span></span><br><span class="line">            <span class="comment">// 选配料</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> end = dp.size();</span><br><span class="line">                <span class="comment">// 组合前面的配料</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; end; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = dp[j] + toppingCosts[i];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp - target) &lt; minAbs || (<span class="built_in">abs</span>(tmp - target) == minAbs &amp;&amp; tmp &lt; ans)) &#123;</span><br><span class="line">                        ans = tmp;</span><br><span class="line">                        minAbs = <span class="built_in">abs</span>(tmp - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt; target)</span><br><span class="line">                        dp.push_back(tmp);</span><br><span class="line">                    </span><br><span class="line">                    tmp += toppingCosts[i];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp - target) &lt; minAbs || (<span class="built_in">abs</span>(tmp - target) == minAbs &amp;&amp; tmp &lt; ans)) &#123;</span><br><span class="line">                        ans = tmp;</span><br><span class="line">                        minAbs = <span class="built_in">abs</span>(tmp - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt; target)</span><br><span class="line">                        dp.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>状态数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-1353.最多可以参加的会议数目</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-1353.%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1353-最多可以参加的会议数目"><a href="#1353-最多可以参加的会议数目" class="headerlink" title="1353.最多可以参加的会议数目"></a>1353.最多可以参加的会议数目</h2><blockquote>
<p>给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。</p>
<p>你可以在满足 startDayi &lt;= d &lt;= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。</p>
<p>请你返回你可以参加的 最大 会议数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：events &#x3D; [[1,2],[2,3],[3,4]]</span><br><span class="line">输出：3</span><br><span class="line">解释：你可以参加所有的三个会议。</span><br><span class="line">安排会议的一种方案如上图。</span><br><span class="line">第 1 天参加第一个会议。</span><br><span class="line">第 2 天参加第二个会议。</span><br><span class="line">第 3 天参加第三个会议。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended">https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended</a></p>
</blockquote>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n * logn)</strong></p>
<p>【<strong>空间复杂度</strong>】<strong>O(n)</strong>  最坏情况！</p>
</blockquote>
<p>注意两个关键信息：</p>
<ol>
<li>在会议进行中的任意一天参加，即可表示参加了该会议；</li>
<li>一天只能参加一个会议。</li>
</ol>
<p>该题也就等价于，在所有会议持续的这段时间内如何能尽可能多的天数参加不同的会议。最好就是每天的可以参加，且参加的会议为不同的会议。这也就是 <strong>贪心</strong> 的解法。要使得参加会议的数目最多，那么也就是在第 i 天选择参加一个正在进行的会议后，后续的时间有尽可能多的会议可选择。也就是优先选择当前进行中的最早结束的会议。</p>
<p>【<strong>贪心思路</strong>】</p>
<ol>
<li>根据会议开始时间排序会议数组；</li>
<li>对于第 i 天，优先选择正在进行且结束时间最早的会议。</li>
</ol>
<p>【<strong>解题实现</strong>】</p>
<ol>
<li>根据会议<strong>开始时间升序</strong>排序会议数组；</li>
<li>从最早的会议时间开始，当前正在进行的会议放入以<strong>结束时间最早优先的优先队列</strong>中，并且已结束的会议从队列中删除；</li>
<li>选择参加正在进行且结束时间最早的会议。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greedy(events);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sort(events.begin(), events.end(), [&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;            </span><br><span class="line">            <span class="comment">// 以开始时间优先</span></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt;= b[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> day = events[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 当前日期</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt;day&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// 小顶堆 结束日期</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n || !minHeap.empty(); ++day) &#123;</span><br><span class="line">            <span class="comment">// 已结束的会议 出堆</span></span><br><span class="line">            <span class="keyword">while</span> (!minHeap.empty() &amp;&amp; minHeap.top() &lt; day) &#123;</span><br><span class="line">                minHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一开始的会议 入堆</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; n &amp;&amp; events[index][<span class="number">0</span>] &lt;= day) &#123;</span><br><span class="line">                minHeap.push(events[index][<span class="number">1</span>]); <span class="comment">// 结束时间入堆</span></span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 选择当前日期正在进行的，并且最早结束的会议</span></span><br><span class="line">            <span class="keyword">if</span> (!minHeap.empty()) &#123;</span><br><span class="line">                minHeap.pop();</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>C++左值右值</title>
    <url>/C++/C++%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<h2 id="定义与区别"><a href="#定义与区别" class="headerlink" title="定义与区别"></a>定义与区别</h2><p><strong>左值 (lvalue, locator value)</strong> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。即左值指的是可以取地址的变量。</p>
<p>区分表达式的左右值属性有一个简便方法：<strong>若可对表达式用 &amp; 符取址，则为左值，否则为右值</strong>。左值与右值的根本区别在于能否获取内存地址，而能否赋值不是区分的依据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// &#x27;a&#x27; 是左值</span></span><br><span class="line">a = <span class="number">10</span>;           <span class="comment">// 但不可以赋值给它！</span></span><br></pre></td></tr></table></figure>

<h2 id="左值与右值直接的转换"><a href="#左值与右值直接的转换" class="headerlink" title="左值与右值直接的转换"></a>左值与右值直接的转换</h2><p>一般上讲，对象之间的运算，对象是以右值的形式参与的。表示<strong>数组</strong>、<strong>函数</strong>和<strong>非完整类型</strong>的左值是不能转换为右值的，因为无法对那些类型进行求值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a 是左值</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b 是左值</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// a和b自动转换为右值求和</span></span><br></pre></td></tr></table></figure>

<p>右值可以通过一些更显式的方法产生左值。例如，一元解引用操作符 <code>&#39;*&#39;</code> 需要一个右值参数，但返回一个左值结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p + <span class="number">1</span>) = <span class="number">10</span>;   <span class="comment">// 正确: p + 1 是右值，但 *(p + 1) 是左值</span></span><br></pre></td></tr></table></figure>

<p>相反地，一元取地址操作符 <code>&#39;&amp;&#39;</code> 需要一个左值参数，返回一个右值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* bad_addr = &amp;(var + <span class="number">1</span>); <span class="comment">// 错误: 一元 &#x27;&amp;&#x27; 操作符需要左值参数</span></span><br><span class="line"><span class="keyword">int</span>* addr = &amp;var;           <span class="comment">// 正确: var 是左值</span></span><br><span class="line">&amp;var = <span class="number">40</span>;                  <span class="comment">// 错误: 赋值操作的左操作数需要是左值</span></span><br></pre></td></tr></table></figure>

<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>C++中可以使用&amp;符定义引用，如果一个左值同时是引用，就称为“左值引用”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; sref = s;  <span class="comment">//sref为左值引用</span></span><br></pre></td></tr></table></figure>

<p><strong>非const左值引用</strong> 不能使用右值对其赋值。但 <strong>const左值引用</strong> 可以。</p>
<p>【<strong>解析</strong>】非const引用类型的变量是可以后续对其进行赋值操作的，但是右值是不可获取内存地址。但const左值引用不一样，因为常量不能被修改，也就不存在上述问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; r = <span class="built_in">std</span>::<span class="built_in">string</span>(); <span class="comment">//错误！std::string（）产生一个临时对象，为右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r = <span class="built_in">std</span>::<span class="built_in">string</span>(); <span class="comment">//可以</span></span><br></pre></td></tr></table></figure>

<p>因此，我们经常<strong>使用const左值引用作为函数的参数类型，可以减少不必要的对象复制</strong>。</p>
<h2 id="C-11-右值引用"><a href="#C-11-右值引用" class="headerlink" title="C++11 右值引用"></a>C++11 右值引用</h2><p>参考：</p>
<ul>
<li><p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C/C++ 中的左值和右值</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/p942005405/article/details/84644069/">c++ 之 std::move 原理实现与用法总结</a></p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C/C++ 中的左值和右值</a> </p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习资料整理</title>
    <url>/interview/C++%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p><a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368">C++内存管理（超长，例子很详细，排版很好）_caogenwangbaoqiang的博客-CSDN博客</a>  </p>
<p><a href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 - 陪她去流浪</a> </p>
<p><a href="https://www.cnblogs.com/qinguoyi/p/10304882.html">C++异常机制 - 两猿社 - 博客园</a> </p>
<p><a href="https://www.cnblogs.com/qinguoyi/p/10277350.html">C++继承 - 两猿社 - 博客园</a> </p>
<p><a href="https://www.cnblogs.com/skynet/p/3343726.html">C++对象模型 - 吴秦 - 博客园</a> </p>
<p><a href="https://github.com/steveLauwh/SGI-STL/tree/master/The%20Annotated%20STL%20Sources%20V3.3">SGI-STL/The Annotated STL Sources V3.3 at master · steveLauwh/SGI-STL</a> </p>
<p><a href="https://blog.csdn.net/yusiguyuan/article/details/37100179">C++智能指针–auto_ptr指针_鱼思故渊的专栏-CSDN博客</a> </p>
<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">C++ 风格指南 - 内容目录 — Google 开源项目风格指南</a> </p>
<ul>
<li><p>《C和指针》</p>
<blockquote>
<p>该书全面深入的剖析了指针的概念与使用，是C语言的进阶。</p>
</blockquote>
</li>
<li><p>《C++ Primer Plus》</p>
<blockquote>
<p>集中学习该书的1~8章，涉及C语言基础语法及指针、结构体的使用。</p>
</blockquote>
</li>
<li><p>《C++ Primer》</p>
<blockquote>
<p>作为C++查询的工具书，相当于新华词典，里面会涉及C++的很多技术细节，实际工程中用到的并不会太多。平时遇到问题可以查询该书，另外也可以作为面试的参考书。</p>
</blockquote>
</li>
<li><p><strong>《STL 源码剖析》</strong> </p>
<blockquote>
<p>涉及C++标准模板库的源码实现，其中vector、map的实现需要重点关注，比如内存分配，底层数据结构等。</p>
</blockquote>
</li>
<li><p>《深度探索C++对象模型》</p>
<blockquote>
<p>深度探索C++对象模型这本书讲解了C++面向对象特性的底层实现机制，由于是翻译版本，读起来内容会相对晦涩一些，但是内容非常重要，尤其是虚函数底层的实现机制，建议多看几遍加深理解，这个基本是C++必问的知识点。看完这本书，对C++面向对象的理解帮助极大，建议必读。</p>
</blockquote>
</li>
<li><p>《Effective C++》</p>
<blockquote>
<p>Effective C++这本书主要讲解了编写C++程序的过程中需要注意的一些条款，有助于梳理在编写C++程序时的一些常见错误和注意事项，也是面试常考的。如果认真读过了C++ Primer，这本书看起来会非常快，其中的很多内容都包含在C++ Primer中了。</p>
</blockquote>
</li>
</ul>
<h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>了解链表，栈，队列，二叉树，哈希表，堆等基础的数据结构。</p>
</blockquote>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote>
<p>直接刷题。</p>
</blockquote>
<p><a href="https://github.com/Making-It/Code">Making-It/Code: 面试高频算法题总结，个人博客</a> </p>
<p><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming–从菜鸟到老鸟_有图有真相-CSDN博客_动态规划</a> </p>
<p><a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环——公式法（递推公式）_再难也要坚持-CSDN博客</a> </p>
<p><a href="https://github.com/labuladong/fucking-algorithm">github - labuladong 的算法小抄</a> \ <a href="https://labuladong.gitbook.io/algo/">gitbook - labuladong的算法小抄</a> </p>
<p><a href="https://www.cxyxiaowu.com/2665.html">老司机开车，教会女朋友什么是「马拉车算法」</a></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><blockquote>
<p>重点看深入理解计算机系统的6,7,9,10章。主要理解线程，进程，虚拟内存及锁机制。</p>
</blockquote>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><blockquote>
<p>主要理解TCP/UDP/HTTP三种协议。其中TCP/UDP以谢希仁老师的计算机网络为主，HTTP以图解HTTP协议为主。</p>
</blockquote>
<p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">TCP 协议 · 笔试面试知识整理</a> (http、SSL/TLS、TCP、UDP、IP、Socket编程)</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote>
<p>MySQL和Redis数据库是当前面试的热门，书籍先看MySQL必知必会，再看Redis设计与实现。</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/MCFHNOQnTtJ6MGVjM3DP4A">MySQL 三万字精华总结 + 面试100 问，吊打面试官绰绰有余（收藏系列）</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/29118331">MySQL索引总结 - 知乎 </a></p>
<p><a href="https://blog.csdn.net/zhu4674548/article/details/103796005">MySQL InnoDB 聚簇索引 非聚簇索引 二级索引 普通索引定义_zhu4674548的专栏-CSDN博客</a> </p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><blockquote>
<p>《大话设计模式》，设计模式可以放在所有知识的最后进行学习。</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a> </p>
<p><a href="https://github.com/liu-jianhao/Cpp-Design-Patterns">liu-jianhao/Cpp-Design-Patterns: C++设计模式</a></p>
</blockquote>
<h2 id="Linux开发相关"><a href="#Linux开发相关" class="headerlink" title="Linux开发相关"></a>Linux开发相关</h2><h3 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h3><p><a href="https://segmentfault.com/a/1190000021950993">Linux常用命令 - 个人文章 - SegmentFault 思否</a> </p>
<h3 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h3><blockquote>
<p>在Linux下进行编程，会涉及到与系统的交互，内存访问，需要学习Linux系统API用法。</p>
<p>《Unix环境高级编程》</p>
</blockquote>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><blockquote>
<p>书籍先看tcp/ip网络编程查漏补缺，补齐网络编程基础知识，然后看《Linux高性能编程》。</p>
<p>《Unix网络编程 卷1：套接字联网API》、《Unix网络编程 卷2：进程间通信》</p>
</blockquote>
<p><a href="http://gityuan.com/2019/01/05/linux-poll-select/">源码解读poll/select内核机制 - Gityuan博客 | 袁辉辉的技术博客</a> </p>
<p><a href="http://gityuan.com/2019/01/06/linux-epoll/">源码解读epoll内核机制 - Gityuan博客 | 袁辉辉的技术博客</a> </p>
<p><a href="https://blog.csdn.net/qq_29108585/article/details/60468522">epoll底层实现过程_学无止境-CSDN博客_epoll底层数据结构</a> </p>
<p><a href="http://www.pandademo.com/category/tech/kernel/">Kernel | PandaDemo</a>  Linux内核epoll ET/LT辨析、Linux内核epoll源码剖析、Linux内核select源码剖析 </p>
<p><a href="https://www.jianshu.com/p/da6642369ef0">Linux select/poll源码剖析 - 简书</a> </p>
<p><a href="https://www.jianshu.com/p/fe54ca4affe8">I/O模型之二：Linux IO模式及 select、poll、epoll详解 - 简书</a> </p>
<p><a href="https://www.cnblogs.com/junneyang/p/6126635.html">【Networkk】一篇文章完全搞清楚 scoket read/write 返回码、阻塞与非阻塞、异常处理 等让你头疼已久的问题 - junneyang - 博客园</a> </p>
<h2 id="网络笔记"><a href="#网络笔记" class="headerlink" title="网络笔记"></a>网络笔记</h2><ul>
<li><p><a href="https://github.com/KelvinYin/libevent-src-analysis">libevent源码分析</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/linyacool/article/details/84560901">我的C++后台开发学习路线(秋招，C++后台，面经)</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/muyuyuzhong/article/details/92382210">C++服务器开发学习进阶路线和资料</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/xie810005152/article/details/88649826">C++后台开发学习路线（已签腾讯后台开发）</a> </p>
</li>
<li><p><a href="https://github.com/twomonkeyclub/BackEnd">twomonkeyclub/BackEnd: 后台开发相关知识</a> </p>
</li>
<li><p><a href="https://www.cyc2018.xyz/">技术面试必备基础知识</a> </p>
<blockquote>
<p>技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++</p>
</blockquote>
</li>
<li><p><a href="https://github.com/linw7/Skill-Tree">linw7/Skill-Tree: 🐼 准备秋招，欢迎来树上取果实</a> </p>
</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li><a href="https://github.com/qinguoyi/TinyWebServer">qinguoyi/TinyWebServer: Linux下C++轻量级Web服务器</a> </li>
<li><a href="https://github.com/wangbojing?tab=repositories">wangbojing (王博靖) / Repositories</a> </li>
<li><a href="https://blog.csdn.net/qq_39751437/article/details/105265301">服务器项目–Tinyhttpd_with_threadpool_epoll_田田天天甜甜的博客-CSDN博客</a> </li>
</ul>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><ul>
<li><p><a href="https://interview.huihut.com/#/?id=%f0%9f%93%91-%e7%9b%ae%e5%bd%95">C/C++ 技术面试基础知识总结</a> </p>
<blockquote>
<p>C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。</p>
</blockquote>
</li>
<li><p><a href="https://blog.csdn.net/charles_r_chiu/article/details/47858885">C++面试常见题目问与答(汇总一)</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/charles_r_chiu/article/details/48227281">C++面试常见题目问与答(汇总二)</a> </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/YupbAFtC0txbt7b9PHbEFA">当输入 xxxxHub 后，到网页显示，其间发生了什么？</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/amoscykl">amoscykl的博客-看看博客面经</a>  </p>
</li>
<li><p><a href="https://www.nowcoder.com/discuss/563162">秋招结束，面经回馈牛客（字节、阿里云、英伟达、滴滴等) </a> </p>
</li>
<li><p><a href="https://blog.csdn.net/qq_39751437/article/details/107027063">2021校招技术面试经验总结–持续更新–_田田天天甜甜的博客-CSDN博客</a> </p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-131.分割回文串</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。回文串 是正着读和反着读都一样的字符串。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 16</li>
<li>s 仅由小写英文字母组成</li>
</ul>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/palindrome-partitioning">https://leetcode-cn.com/problems/palindrome-partitioning</a></p>
</blockquote>
<h2 id="动态规划-回溯"><a href="#动态规划-回溯" class="headerlink" title="动态规划+回溯"></a>动态规划+回溯</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n^2)</strong></p>
<p>【<strong>空间复杂度</strong>】<strong>O(n^2)</strong>  </p>
</blockquote>
<p>首先想到的是计算过程必然要判断子串是否是回文串，假设子串长度m，判断回文串的复杂度是 O(m)，但是该过程会多次重复计算，因此肯定采用【<strong>动态规划</strong>】记录子串是否是回文串。</p>
<p>再有结果集是字符串数组集合，采用【<strong>回溯</strong>】减少函数参数拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【回溯】+【动态规划】</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        dfs(s, <span class="number">0</span>, ans, tmp, dp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// dp[begin][end] 表示子串 [begin, end] 是不是回文串：-1表示未知、0表示不是、1表示是</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) <span class="comment">// 空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == dp[begin][end]) &#123;</span><br><span class="line">            dp[begin][end] = s[begin] != s[end]? <span class="number">0</span> : isPalindrome(s, begin+<span class="number">1</span>, end<span class="number">-1</span>, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[begin][end];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先 回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= n) &#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, begin, i, dp)) &#123;</span><br><span class="line">                tmp.push_back(s.substr(begin, i - begin + <span class="number">1</span>));</span><br><span class="line">                dfs(s, i + <span class="number">1</span>, ans, tmp, dp);  <span class="comment">// 深度优先</span></span><br><span class="line">                tmp.pop_back();  <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-132.分割回文串 II</title>
    <url>/leetcode/%E5%8A%9B%E6%89%A3-132.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-II/</url>
    <content><![CDATA[<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132.分割回文串 II"></a>132.分割回文串 II</h2><blockquote>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n^2)</strong></p>
<p>【<strong>空间复杂度</strong>】<strong>O(n^2)</strong>  </p>
</blockquote>
<p>【分析】</p>
<p>切分子串，要求子串都是回文串。也就是要对子串是否是回文串进行判断，这个过程会重复计算，使用【<strong>动态规划</strong>】记录子串是否是回文串。</p>
<p>[0, end] 字符串可切分为：<code>[0, begin]</code> + <code>[begin+1, end]</code>。[begin+1, end] 是回文串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[begin][end] 表示子串 [begin, end] 是不是回文串</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">true</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">1</span>; end &lt; n; ++end) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">0</span>; begin &lt; end; ++begin) &#123;</span><br><span class="line">                dp[begin][end] = s[begin] == s[end] ? dp[begin+<span class="number">1</span>][end<span class="number">-1</span>] : <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minCutNum</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; n; ++end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][end]) &#123; <span class="comment">// [0, i] 是回文串 最小分割次数0</span></span><br><span class="line">                minCutNum[end] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// [0, i] 不是回文串</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">0</span>; begin &lt; end; ++begin) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[begin+<span class="number">1</span>][end]) &#123; <span class="comment">// [begin+1, end] 是回文串</span></span><br><span class="line">                        minCutNum[end] = min(minCutNum[end], minCutNum[begin] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCutNum[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-35.复杂链表的复制</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-35.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="剑指Offer-35-复杂链表的复制"><a href="#剑指Offer-35-复杂链表的复制" class="headerlink" title="剑指Offer-35.复杂链表的复制"></a>剑指Offer-35.复杂链表的复制</h2><blockquote>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 </p>
<p><strong>示例 1</strong>：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-03/%E5%89%91%E6%8C%87Offer-35.%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-%E7%A4%BA%E4%BE%8B1.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a></p>
</blockquote>
<h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(n)</strong> </p>
</blockquote>
<p>使用哈希表，映射新旧链表节点的关系（一一对应）:</p>
<ol>
<li>复制各节点，并建立 “原节点 -&gt; 新节点” 的 hashMap 映射</li>
<li>构建新链表的 next 和 random 指向</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        unordered_hashMap&lt;Node*, Node*&gt; hashMap;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 hashMap 映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            hashMap[cur] = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 2. 构建新链表的 next 和 random 指向</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            hashMap[cur]-&gt;next = hashMap[cur-&gt;next];</span><br><span class="line">            hashMap[cur]-&gt;random = hashMap[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashMap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="方法二：插入-分离"><a href="#方法二：插入-分离" class="headerlink" title="方法二：插入+分离"></a>方法二：插入+分离</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>直接在原链表上操作：</p>
<ol>
<li>在原链表中每个节点后插入一个节点;</li>
<li>遍历链表，使得新的节点的 random 随机指针指向正确；</li>
<li>再次遍历链表，分离新旧链表。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、在原链表中每个节点后插入一个节点</span></span><br><span class="line"><span class="comment">2、遍历链表，使得新的节点的 random 随机指针指向正确</span></span><br><span class="line"><span class="comment">3、再遍历链表，分离链表</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 1、在原链表中每个节点后插入一个节点</span></span><br><span class="line">        Node *oldNode = head;</span><br><span class="line">        Node *newNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != oldNode) &#123;</span><br><span class="line">            newNode = <span class="keyword">new</span> Node(oldNode-&gt;val);</span><br><span class="line">            newNode-&gt;next = oldNode-&gt;next;</span><br><span class="line">            oldNode-&gt;next = newNode;</span><br><span class="line">            oldNode = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、遍历链表，使得新的节点的 random 随机指针指向正确</span></span><br><span class="line">        oldNode = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != oldNode) &#123;</span><br><span class="line">            oldNode-&gt;next-&gt;random = oldNode-&gt;random == <span class="literal">NULL</span>? <span class="literal">NULL</span> : oldNode-&gt;random-&gt;next;</span><br><span class="line">            oldNode = oldNode-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、再遍历链表，分离链表</span></span><br><span class="line">        Node *newHead = head-&gt;next; <span class="comment">// 新链表头</span></span><br><span class="line">        head-&gt;next = newHead-&gt;next; <span class="comment">// 先分离第一个链表节点</span></span><br><span class="line">        Node *oldTail = head-&gt;next;</span><br><span class="line">        Node *newTail = newHead;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != oldTail) &#123;</span><br><span class="line">            newTail-&gt;next = oldTail-&gt;next;</span><br><span class="line">            oldTail-&gt;next = oldTail-&gt;next-&gt;next;</span><br><span class="line">            newTail = newTail-&gt;next;</span><br><span class="line">            oldTail = oldTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-36.二叉搜索树与双向链表</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="剑指Offer-36-二叉搜索树与双向链表"><a href="#剑指Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指Offer-36.二叉搜索树与双向链表"></a>剑指Offer-36.二叉搜索树与双向链表</h2><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-03/%E5%89%91%E6%8C%87Offer-36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-03/%E5%89%91%E6%8C%87Offer-36.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8.png"></p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</a></p>
</blockquote>
<h2 id="方法一：数组保存结点指针"><a href="#方法一：数组保存结点指针" class="headerlink" title="方法一：数组保存结点指针"></a>方法一：数组保存结点指针</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(n)</strong> </p>
</blockquote>
<p><strong>二叉搜索树</strong> 中序遍历即可得到递增序列。我们的目标就是按递增顺序修改结点的指针。</p>
<p>【<strong>思路</strong>】</p>
<ol>
<li>中序遍历二叉搜索树，得到递增中序序列；</li>
<li>修改递增序列中结点指针。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">二叉搜索树结点大小关系：左孩子 &lt;= 根 &lt;= 右孩子 【中序遍历】</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; treeArray;</span><br><span class="line">        dfsTreeArray(root, treeArray);</span><br><span class="line">        <span class="keyword">int</span> n = treeArray.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+<span class="number">1</span> &lt; n; ++i) &#123;</span><br><span class="line">            treeArray[i]-&gt;right = treeArray[i + <span class="number">1</span>];</span><br><span class="line">            treeArray[i + <span class="number">1</span>]-&gt;left = treeArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        treeArray[<span class="number">0</span>]-&gt;left = treeArray[n - <span class="number">1</span>];</span><br><span class="line">        treeArray[n - <span class="number">1</span>]-&gt;right = treeArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> treeArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">方法一：中序遍历记录所有结点，再修改指针连接</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function">Node* <span class="title">funcA</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfsTreeArray</span><span class="params">(Node* root, <span class="built_in">vector</span>&lt;Node*&gt;&amp; treeArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        dfsTreeArray(root-&gt;left, treeArray);</span><br><span class="line">        treeArray.push_back(root);</span><br><span class="line">        dfsTreeArray(root-&gt;right, treeArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：原树上直接修改"><a href="#方法二：原树上直接修改" class="headerlink" title="方法二：原树上直接修改"></a>方法二：原树上直接修改</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<p>根据中序序列，我们可以直接在树上修改指针。对于一个树结点，只需要指定其前驱结点，即可将其与其前驱结点连接成双向链表，最后再链接表头表尾，即完成双向循环链表。</p>
<p>【<strong>思路</strong>】</p>
<p>对于一棵树：</p>
<ol>
<li>传入整棵树中序的前一个结点指针；</li>
<li>传出整棵树中序的最后一个结点指针。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* head = <span class="keyword">new</span> Node(<span class="number">0</span>); <span class="comment">// 链表头结点 减少NULL判断</span></span><br><span class="line">        Node* tail = constructList(root, head);</span><br><span class="line">        tail-&gt;right = head-&gt;right;</span><br><span class="line">        head-&gt;right-&gt;left = tail;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">方法二：原树上直接修改</span></span><br><span class="line"><span class="comment">对于一棵树：</span></span><br><span class="line"><span class="comment">    1、传入整棵树中序的前一个结点</span></span><br><span class="line"><span class="comment">    2、传出整棵树中序的最后一个结点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function">Node* <span class="title">constructList</span><span class="params">(Node* root, Node* preNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != root-&gt;left) &#123;</span><br><span class="line">            preNode = constructList(root-&gt;left, preNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根结点</span></span><br><span class="line">        preNode-&gt;right = root;</span><br><span class="line">        root-&gt;left = preNode;</span><br><span class="line">        <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> constructList(root-&gt;right, root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>链表</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-37.序列化二叉树</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-37.%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="剑指Offer-37-序列化二叉树"><a href="#剑指Offer-37-序列化二叉树" class="headerlink" title="剑指Offer-37.序列化二叉树"></a>剑指Offer-37.序列化二叉树</h2><blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。示例: </p>
<p> 你可以将以下二叉树：</p>
<pre><code>你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 &quot;[1,2,3,null,null,4,5]&quot;</code></pre>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof</a></p>
</blockquote>
<h2 id="后序遍历–队列"><a href="#后序遍历–队列" class="headerlink" title="后序遍历–队列"></a>后序遍历–队列</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span>  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【层次遍历】队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; m_queue;</span><br><span class="line">        m_queue.push(root);</span><br><span class="line">        <span class="keyword">int</span> notNull = <span class="number">1</span>; <span class="comment">// 队列中未序列化的非空结点数</span></span><br><span class="line">        <span class="keyword">while</span>(notNull &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode *node = m_queue.front();</span><br><span class="line">            m_queue.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != node) &#123;</span><br><span class="line">                --notNull;</span><br><span class="line">                ans += to_string(node-&gt;val);</span><br><span class="line">                m_queue.push(node-&gt;left);</span><br><span class="line">                m_queue.push(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != node-&gt;left)</span><br><span class="line">                    ++notNull;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != node-&gt;right)</span><br><span class="line">                    ++notNull;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (notNull &gt; <span class="number">0</span>)</span><br><span class="line">                ans += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = data.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; m_queue;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;  <span class="comment">// 结点值正反号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(data[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(data[i])) &#123;</span><br><span class="line">                    value = value * <span class="number">10</span> + (data[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(value * sign);</span><br><span class="line">                m_queue.push_back(node);</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;n&#x27;</span> == data[i]) &#123;</span><br><span class="line">                m_queue.push_back(<span class="literal">NULL</span>);</span><br><span class="line">                i += <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> == data[i]) &#123;</span><br><span class="line">                sign = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = m_queue.size();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *root = m_queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> parent = <span class="number">0</span>, child = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != m_queue[parent]) &#123;</span><br><span class="line">                m_queue[parent]-&gt;left = m_queue[child++];</span><br><span class="line">                <span class="keyword">if</span> (child &lt; n)  <span class="comment">// [1,2] 情况</span></span><br><span class="line">                    m_queue[parent]-&gt;right = m_queue[child++];</span><br><span class="line">            &#125;</span><br><span class="line">            ++parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-38.字符串的排列</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="剑指Offer-38-字符串的排列"><a href="#剑指Offer-38-字符串的排列" class="headerlink" title="剑指Offer-38.字符串的排列"></a>剑指Offer-38.字符串的排列</h2><blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p>1 &lt;= s 的长度 &lt;= 8</p>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p>
</blockquote>
<h2 id="深度优先DFS"><a href="#深度优先DFS" class="headerlink" title="深度优先DFS"></a>深度优先DFS</h2><p>这是一个排列问题。暴力思想是枚举所有的可能，但是因为字符可能重复，那么问题也就是怎么避免结果集中有重复元素。解决的办法就是 <strong>排序</strong> 。这里的排序需要注意是两方面：</p>
<ol>
<li>原字符串排序（字符升序）。</li>
<li>排序过程中要保证 “待排字符串” 有序。</li>
</ol>
<p>【<strong>重要说明</strong>】现在举例说明保证 “<strong>待排字符串</strong>“ 有序的操作 （加粗表示待排序字符串）：</p>
<p>初始字符串：”a<strong>abbcc</strong>“；</p>
<p>已排序串末尾选择加入 a ：”aa<strong>bbcc</strong>“</p>
<p>已排序串末尾选择加入 b ：”ab<strong>abcc</strong>“</p>
<p>已排序串末尾选择加入 c ：”ac<strong>abbc</strong>“</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">排列问题 【DFS】</span></span><br><span class="line"><span class="comment">1、字符串可分解成两部分：“已排列” + “待排列”</span></span><br><span class="line"><span class="comment">2、先排序，方便剪枝</span></span><br><span class="line"><span class="comment">3、往 “已排序” 末尾添加一个字符（相同字符只能插入一次）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        sort(s.begin(), s.end()); <span class="comment">//  排序</span></span><br><span class="line">        dfs(s, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= s.length() - <span class="number">1</span>)&#123; <span class="comment">// 仅剩最后一个字符</span></span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// “已排列”字符串末尾添加一个字符</span></span><br><span class="line">        dfs(s, start + <span class="number">1</span>, res);  <span class="comment">// 第一个“待排序”字符添加到“已排序”末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[start] == s[i])  <span class="comment">// 剪枝 相同字符只插入一次</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(s[start], s[i]); <span class="comment">// 交换很巧妙！！！太妙了！！！</span></span><br><span class="line">            dfs(s, start + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-42.连续子数组的最大和</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer-42.%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h2 id="剑指Offer-42-连续子数组的最大和"><a href="#剑指Offer-42-连续子数组的最大和" class="headerlink" title="剑指Offer-42.连续子数组的最大和"></a>剑指Offer-42.连续子数组的最大和</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<blockquote>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
</blockquote>
<h2 id="动态规划-区间问题"><a href="#动态规划-区间问题" class="headerlink" title="动态规划-区间问题"></a>动态规划-区间问题</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(n)</strong> </p>
</blockquote>
<ul>
<li><p><strong>dp[i]</strong> ：记录[0, i] 中包括 nums[i] 的最大子数组和。</p>
</li>
<li><p>状态转移方程：<code>dp[i] = max(dp[i-1] + nums[i], nums[i])</code> </p>
</li>
</ul>
<ul>
<li>初始状态：<code>dp[0]= nums[0]</code> </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 动态规划 区间问题</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i] -- [0, i] 中包括 nums[i] 的最大子数组和</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            maxSum = max(maxSum, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优化：原数组dp"><a href="#优化：原数组dp" class="headerlink" title="优化：原数组dp"></a>优化：原数组dp</h2><blockquote>
<p>【<strong>时间复杂度</strong>】<strong>O(n)</strong> </p>
<p>【<strong>空间复杂度</strong>】<strong>O(1)</strong> </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">动态规划 区间问题</span></span><br><span class="line"><span class="comment">1、dp[i] -- [0, i] 中包括 nums[i] 的最大子数组和</span></span><br><span class="line"><span class="comment">2、优化：原数组dp</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nums[i] = max(nums[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            maxSum = max(maxSum, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux进程地址空间（程序内存布局）</title>
    <url>/APUE/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%88%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="进程地址空间分布图"><a href="#进程地址空间分布图" class="headerlink" title="进程地址空间分布图"></a>进程地址空间分布图</h1><img src="https://i.loli.net/2020/08/05/jxbWsi5ae4q1GfR.png" alt="Linux程序内存布局图.png" style="zoom:67%;" />

<p>由低地址到高地址，依次是：</p>
<ul>
<li><p><strong>程序段（text）</strong>：程序代码在内存中的映射，存放函数体的二进制代码，常常是只读的</p>
</li>
<li><p><strong>初始化过的数据（data）</strong>：在程序运行初已经对变量进行初始化的数据</p>
<ul>
<li><p>只读数据段（RO data，即常量区）：</p>
<blockquote>
<p> 这个区域的存在与否，一直是一个争议的地方，但是我们这里认同是存在的，因为我们的程序中的确出现了与其他数据段不同的一块区域，但是往往很多时候大家把只读数据段（RO data）和下面的已初始化读写数据段（RW data）合成为数据段data，但是其实这个是不合适的，因为在执行过程中，这两个区域的读写权限是不同的，顾名思义，只读数据段（RO data）是只读的，而已初始化读写数据段是可读可写的。</p>
</blockquote>
</li>
<li><p>读写数据段（RW data）：需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并具有初值，以供程序运行时读写</p>
</li>
</ul>
</li>
<li><p><strong>未初始化过的数据（bss）</strong>：未初始化数据是在程序中声明，但是没有初始化的变量，这些变量在程序运行之前不需要占用存储器的空间。Block Started by Symbol，BSS段的变量只有名称和大小却没有值</p>
</li>
<li><p>堆 （heap）<strong>：存储动态内存分配,需要程序员手工分配,手工释放。注意它与数据结构中的堆是两回事，分配方式类似于链表</strong></p>
</li>
<li><p><strong>栈（stack）</strong>：存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存，结束时自动释放内存，其操作方式类似于数据结构中的栈</p>
</li>
<li><p><strong>内核空间（kernel）</strong></p>
</li>
</ul>
<h1 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h1><p> Linux的<font color=red><strong>虚拟地址空间</strong></font>范围为0～4G，Linux内核将这4G字节的空间分为两部分：</p>
<p><strong>内核空间</strong>：将高地址的<strong>1G</strong>字节供内核使用，称为“内核空间“</p>
<p><strong>用户空间</strong>：低地址的<strong>3G</strong>字节（供各个进程使用，称为“用户空间“</p>
<p>因为每个进程可以通过系统调用进入内核，因此，<font color=red><strong>Linux内核由系统内的所有进程共享</strong></font>。</p>
<p>Linux使用两级保护机制：</p>
<ul>
<li>0级供内核使用</li>
<li>3级供用户程序使用</li>
</ul>
<h1 id="虚拟地址！！！"><a href="#虚拟地址！！！" class="headerlink" title="虚拟地址！！！"></a>虚拟地址！！！</h1><p>进程空间是<strong>虚拟地址</strong>，不管是内核空间还是用户空间，它们都处于虚拟空间中。</p>
<p>使用虚拟地址可以很好的保护内核空间被用户空间破坏，虚拟地址到物理地址转换过程由操作系统和CPU共同完成(操作系统为CPU设置好页表，CPU通过MMU单元进行地址转换)。</p>
<h1 id="段区对应数据"><a href="#段区对应数据" class="headerlink" title="段区对应数据"></a>段区对应数据</h1><table>
<thead>
<tr>
<th>进程空间段区域</th>
<th>地址空间</th>
<th>存储变量</th>
</tr>
</thead>
<tbody><tr>
<td>stack</td>
<td>栈</td>
<td>局部变量和常量</td>
</tr>
<tr>
<td>heap</td>
<td>堆</td>
<td>动态分配的数据</td>
</tr>
<tr>
<td>BSS</td>
<td>未初始化数据段</td>
<td>未初始化的全局变量以及静态变量</td>
</tr>
<tr>
<td>RW data</td>
<td>已初始化读写数据段</td>
<td>已初始化的全局变量和静态变量</td>
</tr>
<tr>
<td>RO data</td>
<td>只读文本段中的数据段</td>
<td>全局常量或者字符串面变量</td>
</tr>
<tr>
<td>text</td>
<td>只读文本段中的程序代码段</td>
<td>程序的代码</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>《UNIX环境高级编程》</p>
</li>
<li><p><a href="https://blog.csdn.net/zhangzhebjut/article/details/39060253">Linux - 进程(一) 进程空间</a></p>
</li>
<li><p><a href="https://blog.csdn.net/gatieme/article/details/43567433">C程序的内存布局(Memory Layout)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>apue</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>apue</tag>
        <tag>进程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐</title>
    <url>/APUE/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>现代计算机中内存空间都是按照<strong>字节（byte）</strong>划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p><strong>如果一个变量的内存地址正好位于它长度的整数倍</strong>，他就被称做<strong>自然对齐</strong>。比如4字节的 int 型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即对齐跟数据在内存中的位置有关。</p>
<h2 id="为什么要对齐"><a href="#为什么要对齐" class="headerlink" title="为什么要对齐"></a>为什么要对齐</h2><ul>
<li>一些平台严格要求，比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,</li>
<li><strong>为了使CPU能够对变量进行快速的访问</strong></li>
</ul>
<p>如果0x02～0x05存了一个 int ，读取这个 int 就需要先读0x01～0x04，留下0x02～0x04的内容，再读0x05～0x08，留下0x05的内容，两部分拼接起来才能得到那个 int 的值，这样读一个 int 就要两次内存访问，效率就低了。</p>
<h2 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="pragma pack"></a>pragma pack</h2><p>用 <code>sizeof</code> 运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，有时候为了内存对齐需要补齐空字节。通常写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。</p>
<p>语法：<b>#pragma pack( [show] | [push | pop] [, identifier], n )</b></p>
<p>作用：指定结构，联合和类的包对齐方式（pack alignment）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)    <span class="comment">//通知编译器 4字节对齐</span></span></span><br></pre></td></tr></table></figure>

<h2 id="字节对齐规则"><a href="#字节对齐规则" class="headerlink" title="字节对齐规则"></a>字节对齐规则</h2><p>结构体中各个成员按照它们<strong>被声明的顺序</strong>在内存中顺序存储。对齐规则如下：</p>
<ol>
<li><p>各个数据成员按各自数据类型对齐</p>
<blockquote>
<p>对齐模数是【该数据成员所占内存】与【#pragma pack指定的数值】中的<font color=red><strong>较小者</strong></font>。</p>
</blockquote>
</li>
<li><p>整个结构体字节大小向结构体模数对齐</p>
<blockquote>
<p>结构体模数是【#pragma pack指定的数值（32位机默认4字节、64位机默认8字节）】和【结构体内部最大的基本数据类型成员】长度中数值<font color=red><strong>较小者</strong></font>。结构体的长度应该是该模数的整数倍。</p>
</blockquote>
</li>
</ol>
<p>【<strong>基本数据类型</strong>】无符号字节数一样。32位机默认4字节对齐、64位机默认8字节对齐。（<strong>实践数据：linux 64位机默认16字节对齐、linux 32位机默认4字节对齐</strong>）。win64未验证。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>char</th>
<th>bool</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>long long</th>
<th>long double</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>Win-32</td>
<td>长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>模数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>Linux-32</td>
<td>长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>12</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>模数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>Linux-64</td>
<td>长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>模数</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>16</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>内部数据成员都是以基本数据类型进行对齐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;        <span class="comment">// 8 bits</span></span><br><span class="line">    <span class="keyword">double</span> val2;    <span class="comment">// 8 bits</span></span><br><span class="line">&#125; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_i;            <span class="comment">// 4 bits    </span></span><br><span class="line">    A m_A;                <span class="comment">// 16 bits</span></span><br><span class="line">    <span class="keyword">double</span> m_d;    <span class="comment">// 8 bits</span></span><br><span class="line">    <span class="keyword">int</span> m_i2;            <span class="comment">// 4 bits</span></span><br><span class="line">&#125; B;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>b.m_int          = 0x61fed8                 </p>
<p>b.m_A.val      = 0x61fee0</p>
<p>b.m_A.val2    = 0x61fee8</p>
<p>b.m_double  = 0x61fef0 </p>
<p> b.m_int2        = 0x61fef8 </p>
<p>sizeof(A) = 16  </p>
<p>sizeof(B) = 40 </p>
</blockquote>
<img src="https://i.loli.net/2020/09/24/Xu15mr2JeHyjpVY.jpg" alt="字节对齐-样例.jpg" style="zoom: 25%;" /> 

<h2 id="static静态数据"><a href="#static静态数据" class="headerlink" title="static静态数据"></a>static静态数据</h2><p>静态变量的存放位置与结构体实例的存储地址无关，是单独存放在静态数据区的，因此用 sizeof() 计算其大小时没有将静态成员所占的空间计算进来。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>空类是会占用内存空间的，而且大小是</strong><font color=red><strong>1 byte</strong></font>，原因是<strong>C++要求每个实例在内存中都有独一无二的地址</strong> 。</p>
<ul>
<li><p>类内成员变量</p>
<ul>
<li><strong>non-static变量</strong>：要占用内存，参考上面对齐规则</li>
<li><strong>static变量</strong>：不占用内存，存储在全局/静态存储区</li>
</ul>
</li>
<li><p>类成员函数</p>
<ul>
<li><p>普通函数：不占内存</p>
</li>
<li><p><strong>虚函数</strong>：4字节（32位），虚表指针（vptr），指向虚函数表（vtbl)。并且，<strong>虚表指针存放在第一个4字节</strong>。</p>
<ul>
<li>一个类的虚函数所占用的地址是不变的，和虚函数的个数没有关系。</li>
<li>子类与父类共享一个虚表指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// 4 bits</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fOut</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;virtual base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerive</span> :</span> <span class="keyword">public</span> CBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 4 bits</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fPut</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;virtual derive&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印地址</span></span><br><span class="line">CDerive derive;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(derive) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;derive &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0x61fe9c </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;derive.a &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0x61fea0 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;derive.n &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0x61fea4 </span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lime1991/article/details/44536343">#pragma pack()用法详解</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>系统I/O函数与C标准库函数</title>
    <url>/APUE/%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0%E4%B8%8EC%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>先上图</p>
<img src="https://i.loli.net/2020/08/06/RIMrGxbPWyizjnK.png" alt="库函数与系统调用的层次关系.png" style="zoom: 67%;" />

<img src="https://i.loli.net/2020/08/06/tl8ykNe6wrx7VOd.png" alt="系统IO函数与C标库函数.png" style="zoom:67%;" />

<p><strong><em>read、write函数常常被称为 Unbuffered I/O。指的是无用户输入级缓冲区，但不保证不使用内核缓冲区。</em></strong></p>
<h2 id="系统I-O与标准库I-O差异"><a href="#系统I-O与标准库I-O差异" class="headerlink" title="系统I/O与标准库I/O差异"></a>系统I/O与标准库I/O差异</h2><p>用户程序在读写文件时既可以调用C标准I/O库函数，也可以直接调用底层的系统I/O函数，有什么区别呢？</p>
<ul>
<li>使用系统I/O函数每次读写都需要进入内核，调一个系统调用比调一个用户空间的函数要慢很多。（此时用户有必要维护一个I/O缓冲区，但用C标准I/O库函数就比较方便，省去了自己管理I/O缓冲区的麻烦）</li>
<li>用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，在必要时需调用<code>fflush</code></li>
<li>UNIX是Everything is a file，在读写设备文件时通常是不希望有缓冲的，例如网络编程通常直接调用Unbuffered I/O函数。</li>
</ul>
<h2 id="标准库缓冲类型"><a href="#标准库缓冲类型" class="headerlink" title="标准库缓冲类型"></a>标准库缓冲类型</h2><p>C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。</p>
<h3 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h3><p>如果缓冲区写满了就写回内核。对于驻留在<strong>磁盘</strong>上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。</p>
<h3 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h3><p>如果用户程序写的数据中有<strong>换行符</strong>就把这一行写回内核，或者如果<strong>缓冲区写满</strong>了就写回内核。<font color=red><strong>标准输入</strong></font>和<font color=red><strong>标准输出</strong></font>对应终端设备时通常是行缓冲的。 </p>
<h3 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h3><p>用户程序每次调库函数做写操作都要通过系统调用写回内核。</p>
<p><font color=red><strong>标准错误输出</strong></font>通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。这里的无缓冲，并不是指缓冲区大小为0，其实，还是有缓冲的，大小为1。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>apue</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>apue</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11智能指针</title>
    <url>/C++/C++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>程序使用 <code>new</code> 从堆（自由存储区）分配内存，在不需要时，应使用 <code>delete</code> 将其释放。这个内存管理过程由程序员控制，内存泄露是困扰C/C++程序员的一大难题。，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放）、二次释放、程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p>
<p>在C++11中摒弃了auto_ptr（在 C++ 17 中被移除），新增三种智能指针：</p>
<ul>
<li><code>shared_ptr</code> ：通过指针保持对象<strong>共享</strong>所有权的智能指针；</li>
<li><code>weak_ptr</code>：到 std::shared_ptr 所管理对象的<strong>弱引用</strong>，在访问所引用的对象前必须先转换为 std::shared_ptr ；</li>
<li><code>unique_ptr</code>： 拥有<strong>独有</strong>对象所有权语义的智能指针。</li>
</ul>
<h2 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h2><p><code>shared_ptr</code> 、 <code>unique_ptr</code> 都有一个 <code>explicit</code> 构造函数，因此不能自动将指针转换为智能指针对象，<strong>必须显式调用</strong>。</p>
<blockquote>
<p>4.8.2</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line"><span class="function">        : __shared_ptr&lt;_Tp&gt;<span class="params">(__p)</span> </span>&#123; &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(pointer __p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _<span class="title">M_t</span><span class="params">(__p, deleter_type())</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">static_assert</span>(!is_pointer&lt;deleter_type&gt;::value,</span><br><span class="line">              <span class="string">&quot;constructed with null function pointer deleter&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>std::shared_ptr</code> 是通过指针保持对象共享所有权的智能指针。<code>shared_ptr</code>的目标非常简单：多个指针可以同时指向一个对象。下列情况之一出现时销毁对象并解分配其内存：</p>
<ul>
<li>最后剩下的占有对象的 <code>shared_ptr</code> 被销毁；</li>
<li>最后剩下的占有对象的 <code>shared_ptr</code> 被通过<code>operator=</code> 或 <code>reset()</code>]赋值为另一指针时。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_int = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sptr1</span><span class="params">(p)</span></span>;            <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr2 = sptr1;        <span class="comment">// OK 引用计数+1</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr3 = p_int;        <span class="comment">// Error!!!</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>); <span class="comment">// OK 使用 make_shared</span></span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr析构"><a href="#shared-ptr析构" class="headerlink" title="shared_ptr析构"></a>shared_ptr析构</h3><p><code>shared_ptr</code> 默认调用 <code>delete</code> 释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个 <code>shared_ptr</code> 的策略。如下：当离开作用域时，默认的析构函数调用 <code>delete</code> 释放资源。实际上，我们应该调用 <code>delete[]</code> 来销毁这个数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Test&gt; <span class="title">sptr1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;  <span class="comment">// 默认使用 delete 析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以通过调用一个<strong>函数</strong>，例如一个 <strong>lamda 表达式</strong>，来指定一个通用的释放步骤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Test&gt; <span class="title">sptr1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], [ ](Test* p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li><p><code>shared_ptr</code> 也提供解引用操作符 <code>*</code> 、<code>-&gt;</code> 。</p>
</li>
<li><p><code>std::make_shared</code> ：创建管理一个新对象的共享指针</p>
</li>
<li><p><code>get()</code> ：获取<code>shared_ptr</code>绑定的资源。</p>
</li>
<li><p><code>reset()</code> ：释放关联内存块的所有权，如果是最后一个指向该资源的<code>shared_ptr</code>,就释放这块内存。</p>
</li>
<li><p><code>unique</code> ：判断是否是唯一指向当前内存的<code>shared_ptr</code>。</p>
</li>
<li><p><code>operator bool</code> ：判断当前的<code>shared_ptr</code>是否指向一个内存块，可以用if 表达式判断。</p>
</li>
</ul>
<h3 id="原始指针初始化shared-ptr"><a href="#原始指针初始化shared-ptr" class="headerlink" title="原始指针初始化shared_ptr"></a>原始指针初始化shared_ptr</h3><p><strong>不要用一个原始指针初始化多个 <code>shared_ptr</code>，否则会造成二次释放同一内存。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;  <span class="comment">// 引用计数 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;  <span class="comment">// 引用计数 1   p1、p2两者不知对方存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，直接使用原始指针初始化多个 <code>shared_ptr</code> ，使用时，智能指针相互间不知道彼此的存在。p1、p2存储在栈上，程序结束时，首先 p2 死亡时引用计数为 0 ，释放掉 ptr 。接着 p1 死亡，p1 记录的引用计数也为 0 。再次对对象进行释放，<font color=red><strong>Crash !!!</strong></font> 。</p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Parent() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Child&gt; m_child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Child() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Parent&gt; m_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p_parent</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Child&gt; <span class="title">p_child</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">    p_child-&gt;m_parent = p_parent;</span><br><span class="line">    p_parent-&gt;m_child = p_child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个对象的引用计数都是 2 。当 <code>p_child</code> 离开作用域时，子类对象引用计数 -1 （值为1）。当 <code>p_parent</code> 离开作用域时，父类对象引用计数 -1 （值为1）。两个智能指针生命期都结束了，但是对象内存却都没得到释放！！！</p>
<p>【<strong>解决循环引用</strong>】</p>
<ul>
<li>当只剩下最后一个引用的时候需要手动打破循环引用释放对象。</li>
<li>当parent的生存期超过child的生存期的时候，child改为使用一个普通指针指向parent。</li>
<li>使用<strong>弱引用</strong>的智能指针打破这种循环引用。</li>
</ul>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>为了解决<strong>循环引用</strong>，<code>C++</code>提供了另外一种智能指针：<code>weak_ptr</code> 。</p>
<p><code>std::weak_ptr</code> 是一种智能指针，它对被 <code>std::shared_ptr</code> 管理的对象存在非拥有性（“弱”）引用。在访问所引用的对象前必须先转换为 <code>std::shared_ptr</code>。</p>
<p><strong>强引用</strong>：被引用的对象活着，这个引用就存在。只要有一个强引用存在，这个对象就不能被释放。</p>
<p><strong>弱引用</strong>：弱引用不修改对象的引用计数，意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Parent() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;Child&gt; m_child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Child() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child destroying...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;Parent&gt; m_parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>std::unique_ptr</code> 是通过指针占有并管理另一对象，并在 <code>unique_ptr</code> 离开作用域时释放该对象的智能指针。</p>
<p>在下列两者之一发生时用关联的删除器释放对象：</p>
<ul>
<li>销毁了管理的 <code>unique_ptr</code> 对象。</li>
<li>通过 <code>operator=</code> 或 <code>reset()</code> 赋值另一指针给管理的 <code>unique_ptr</code> 对象。</li>
</ul>
<p><code>unique_ptr</code>的创建方法和<code>shared_ptr</code>一样，除非创建一个指向数组类型的<code>unique_ptr</code>。<code>unique_ptr</code>提供了创建数组对象的特殊方法，当指针离开作用域时，调用<code>delete[]</code>代替<code>delete</code>。当创建<code>unique_ptr</code>时，这一组对象被视作模板参数的部分。这样，程序员就不需要再提供一个指定的析构方法</p>
<p><code>unique_ptr</code>提供一个<code>release()</code>的方法，释放所有权。<code>release</code>和<code>reset</code>的区别在于，<code>release</code>仅仅释放所有权但不释放资源，<code>reset</code>释放所有权同时也释放资源。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类型转换运算符</title>
    <url>/C++/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<ul>
<li><code>dynamic_cast</code>：有虚函数的类，指针或引用，类层次结构中进行转换（主要是向上转换）；</li>
<li><code>const_cast</code>：去掉 const 或 volatile 属性；</li>
<li><code>static_cast</code>：编译期间转换，没有运行时类型检查来保证转换的安全性；</li>
<li><code>reinterpret_cast</code>：仅仅重新解释类型，没有对数据进行调整。</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>

<p><code>dynamic_cast</code>动态类型转换，用于实现RTTI。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</p>
<ul>
<li><p>只能用于有<strong>虚函数</strong>的类；</p>
</li>
<li><p>只能用于<strong>指针</strong>或<strong>引用</strong>；</p>
</li>
<li><p>对运行期类型信息（RTTI）进行了检查，类层次结构中<strong>向上转换</strong>成功，其余转换返回空指针；</p>
<blockquote>
<p>若是基类指针指向派生类对象，再将基类指针向下转型，成功！</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> A();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    B *pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败 赋值NULL</span></span><br><span class="line">    C *pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败 赋值NULL</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> D();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const_cast</span> &lt; new_type &gt; ( expression )        </span><br></pre></td></tr></table></figure>

<p>修改类型的 <code>const</code> 或 <code>volatile</code> 属性。除了 const 或 volatile 修饰之外， new_type 和 expression 的类型必须是一样的。</p>
<p>函数指针和成员函数指针不可用于 <code>const_cast</code></p>
<p><strong><em>expression 内存空间是只读的，转换类型后，只能读，不能写</em></strong>。<font color=red><strong>转换后的指针或引用能修改值，源数据值却未改变，但是他们的地址是同一个！！！</strong></font>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;                 <span class="comment">// 不声明 i 为 const</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rci = i; </span><br><span class="line">    <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(rci) = <span class="number">4</span>; <span class="comment">// OK：修改 i</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// i = 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_val = <span class="number">233</span>;  <span class="comment">//声明为常量类型</span></span><br><span class="line">    <span class="keyword">int</span> &amp;use_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(c_val); <span class="comment">//使用去const 引用</span></span><br><span class="line">    <span class="keyword">int</span> *ptr_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;c_val);<span class="comment">//使用去const 指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;c_val = &quot;</span> &lt;&lt; &amp;c_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    use_val = <span class="number">111</span>;  <span class="comment">//未定义行为</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; <span class="string">&quot;\t&amp;use_val = &quot;</span> &lt;&lt; &amp;use_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    *ptr_val = <span class="number">222</span>; <span class="comment">//未定义行为</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; use_val &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ptr_val &lt;&lt; <span class="string">&quot;\tptr_val = &quot;</span> &lt;&lt; ptr_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;&amp;c_val = &quot; &lt;&lt; &amp;c_val &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  https://zh.cppreference.com/w/cpp/language/const_cast  输出为</span></span><br><span class="line"><span class="comment">    i = 4</span></span><br><span class="line"><span class="comment">    &amp;c_val = 0x7ffd3abc86cc</span></span><br><span class="line"><span class="comment">    233    111    111    &amp;use_val = 0x7ffd3abc86cc</span></span><br><span class="line"><span class="comment">    233    222    222    ptr_val = 0x7ffd3abc86cc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>

<p><code>static_cast</code> 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。<code>static_cast</code> 是“静态转换”的意思，也就是在<strong>编译期间转换</strong>，转换失败的话会抛出一个编译错误。</p>
<ul>
<li>能使用隐式转换的地方，均可以使用<code>static_cast</code>转换；</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证；</li>
<li>如果类型不兼容，使用<code>static_cast</code>编译检查，会报错；</li>
<li>类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。向上转换是安全的，向下转换不安全；</li>
<li>把void指针转换成目标类型的指针(不安全！！)；</li>
<li>把任何类型的表达式转换成void类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是正确的用法</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">long</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line"><span class="keyword">void</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line"><span class="comment">//下面的用法是错误的</span></span><br><span class="line"><span class="keyword">float</span> *p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);  </span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reinterpret_cast</span>&lt; new_type &gt; ( expression )</span><br></pre></td></tr></table></figure>

<p>用于高度危险的类型转换，仅仅是对二进制位的<strong>重新解释</strong>，不会对数据进行调整。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1  = <span class="string">&quot;hello world&quot;</span>;                       </span><br><span class="line"><span class="keyword">int</span>  *p2  = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记(面向对象高级编程--侯捷)</title>
    <url>/C++/C++%E7%AC%94%E8%AE%B0(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--%E4%BE%AF%E6%8D%B7)/</url>
    <content><![CDATA[<blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV14s411E772">https://www.bilibili.com/video/BV14s411E772</a> </p>
<p>别人的git：<a href="https://github.com/harvestlamb/Cpp_houjie">https://github.com/harvestlamb/Cpp_houjie</a> </p>
</blockquote>
<h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>在C/C++中，有些函数会被频繁的调用，会有频繁的函数入栈、出栈操作，这样就造成一定程度上时间以及空间的消耗。于是在C++中便提出了内联函数的概念。</p>
<p><strong>内联函数的特征：</strong> </p>
<ul>
<li>在编译时，编译器使用函数的定义替换掉函数的调用语句，这种替代行为发生在编译阶段而非程序运行阶段</li>
<li><strong>在类声明中定义的函数, 除了虚函数的其他函数都会自动隐式的成为内联函数</strong></li>
<li><strong>关键字<code>inline</code>必须与函数定义体放在一起才能使函数成为内联, 仅将inline放在函数声明前不起任何作用</strong> </li>
</ul>
<p><strong>优点：</strong> </p>
<ul>
<li>省去函数调用时的参数压栈, 栈帧开辟, 结构返回等步骤, 从而提高了程序的运行速度</li>
<li>内联函数优于宏，宏不能按值传递，并且内联函数可以访问类的成员变量</li>
<li>内联函数在运行时可以调试, 而宏定义则不行(因为宏定义是被预定义处理的, 所以不会有人黑的编译符号和调试信息, 调试的时候基本只能用肉眼去看)</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>代码膨胀，内联函数增大了可执行程序的体积</li>
<li>C++内联函数的展开是中编译阶段，这就意味着如果你的内联函数发生了改动，那么就需要重新编译代码</li>
<li><font color=red><b>是否内联是程序员不可控的，<code>inline</code> 只是对编译器的建议，最终有编译器决定</b></font></li>
</ul>
<h2 id="构造函数（初始化、赋值）"><a href="#构造函数（初始化、赋值）" class="headerlink" title="构造函数（初始化、赋值）"></a>构造函数（初始化、赋值）</h2><p>构造函数可以分为两步：</p>
<ul>
<li><strong>初始化</strong></li>
<li><strong>赋值</strong></li>
</ul>
<p>对比以下两种方式的构造函数，方式一在直接通过参数初始化变量；而方式二先初始化，然后再对变量进行赋值。显然效率就有差异。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：初始化</span></span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : re(r), im(i) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：赋值</span></span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">    re = r;</span><br><span class="line">    im = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>关键字 <code>const</code> 限定<strong>常量只读</strong>。仅在声明时进行初始化，若声明变量时没有提供值，则该常量的值将是不确定的，且无法修改。</p>
<p><code>const</code> 优于 <code>#define</code> ：</p>
<ol>
<li>const 能够明确指定类型</li>
<li>可以使用C++的作用域规则将定义限定在特定的函数或文件中</li>
<li>可以将 const 用于更复杂的类型</li>
</ol>
<h3 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h3><p>通常我的理解是用 <strong>const</strong> 修饰函数也就是标识函数不会修改数据。此时有了新的理解。先看简略代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的部分定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : re(r), im(i) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="comment">/* const */</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="comment">/* const */</span> </span>&#123; <span class="keyword">return</span> im; &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类对象的使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 常量对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.real() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.imag(); <span class="comment">// 函数调用可能修改值，矛盾！编译器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以上面代码来分析为什么要用 <strong>const</strong> ，我们定义的<strong>常量复数类对象</strong>打印输出复数实部和虚部，假如两个函数没有 const 修饰，意思是<strong>函数可能改数据</strong>，但是对象是常量，<strong>不允许改数据</strong>，这是 <font color=red><strong>矛盾的</strong></font> ，那么编译器表示不行。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">const object（data members 不可改变）</th>
<th align="center">non-const object（data members 可改变）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const member functions</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">non-const member functions</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong><em>当成员函数的 <code>const</code> 和 <code>non-const</code> 版本同时存在，const object 只会（只能）调用 const 版本，non-const object 只会（只能）调用 non-const 版本。</em></strong> </p>
<h2 id="friend友元"><a href="#friend友元" class="headerlink" title="friend友元"></a>friend友元</h2><p>友元函数可直接访问<strong>私有成员</strong>。</p>
<p><font color=red><b>同一个 <code>lass</code> 的各个 <code>objects</code> 互为友元。</b></font> （如：拷贝构造函数）</p>
<p>友元关系<strong>不可传递</strong>、<strong>不可继承</strong>。（你是我的朋友，但你的朋友不一定是我的朋友）</p>
<h2 id="拷贝构造、拷贝赋值"><a href="#拷贝构造、拷贝赋值" class="headerlink" title="拷贝构造、拷贝赋值"></a>拷贝构造、拷贝赋值</h2><p>class 带有 <code>pointer members</code> 必须有<strong>拷贝构造（深拷贝）</strong>和<strong>拷贝赋值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr) &#123; <span class="comment">// 拷贝构造</span></span><br><span class="line">   <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">      m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;   </span><br><span class="line">      m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">      *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str) &#123; <span class="comment">// 拷贝赋值</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">   <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数、析构函数"><a href="#构造函数、析构函数" class="headerlink" title="构造函数、析构函数"></a>构造函数、析构函数</h2><p><b><code>new</code></b> ：先分配内存 <code>memory</code> ，再调用构造 <code>constructor</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String* ps = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器转化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String* ps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(String)); <span class="comment">// 分配内存 内部调用 malloc</span></span><br><span class="line">ps = <span class="keyword">static_cast</span>&lt;String*&gt;(mem);            <span class="comment">// 转型</span></span><br><span class="line">ps-&gt;String::String(<span class="string">&quot;Hello&quot;</span>);            <span class="comment">//构造函数</span></span><br></pre></td></tr></table></figure>

<p><b><code>delete</code></b> ：先再析构 <code>destructor</code> ，再释放内存 <code>memory</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> ps;</span><br></pre></td></tr></table></figure>

<p>编译器转化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String::~String(ps);             <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;            <span class="comment">// 释放内存 内部调用 free(ps)</span></span><br></pre></td></tr></table></figure>

<h2 id="动态分配所得内存块（in-VC）"><a href="#动态分配所得内存块（in-VC）" class="headerlink" title="动态分配所得内存块（in VC）"></a>动态分配所得内存块（in VC）</h2><p>创建Complex对象、String对象，编译器（VC）给两对象分配内存如下：</p>
<img src="https://i.loli.net/2020/09/16/oXHKxDMsbdeuZ7w.png" alt="动态分配所得内存块.png" style="zoom: 67%;" />

<ul>
<li><p><font color=00FF33><strong>绿色部分</strong></font>是<strong>对象实际占有的空间</strong> </p>
</li>
<li><p><font color=CC3333><strong>红色部分</strong></font>是<strong>cookie</strong>，编译器在对象内存的头尾插入cookie，cookie值表示内存块大小以及状态，如图中：</p>
<blockquote>
<p>cookie = 0x00000041</p>
<p>内存块大小 64 字节，对应十六进制数 0x40</p>
<p>内存块是已分配的（给出去了）cookie最后一位为 1 标识，由此的到cookie值 0x00000041</p>
</blockquote>
</li>
<li><p><font color=gray><strong>灰色部分</strong></font>是debug模式下编译器分配空间时需要插入的字节，VC下为 *<em>4</em>8+4** 字节</p>
</li>
<li><p><font color=33CCCC><strong>青色部分</strong></font>为<strong>字节对齐</strong>（VC为16字节对齐）</p>
</li>
</ul>
<p>对于数组array，内存块如下：</p>
<img src="https://i.loli.net/2020/09/16/D2OunVsfGLHo4tN.png" alt="动态分配array所得内存块.png" style="zoom: 50%;" />

<p><font color=red><strong>array new 一定要搭配 array delete</strong></font>，下图给出内存泄露位置：</p>
<img src="https://i.loli.net/2020/09/16/5ib9a1IGFDvWm2M.png" alt="array-new一定要搭配array-delete.png" style="zoom: 55%;" />

<h2 id="复合、委托、继承"><a href="#复合、委托、继承" class="headerlink" title="复合、委托、继承"></a>复合、委托、继承</h2><p><code>Composition</code> （复合）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="built_in">deque</span> c; <span class="comment">// 复合 （包含对象）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表示 <strong>has-a</strong> 关系。</li>
<li>构造函数<strong>由内向外</strong> </li>
<li>析构函数<strong>由外向内</strong> </li>
</ul>
<p><code>Delegation</code> （委托）：</p>
<p>个人理解有点文件存储node结点的味道。引用计数。写时复制，读时共享。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    StringRep* rep; <span class="comment">// 指针 指向实现功能的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Inheritance</code> （继承）：</p>
<ul>
<li>表示 <strong>is-a</strong> 关系（是一种）</li>
<li>构造函数由内而外（父类—子类）</li>
<li>析构函数由外而内（子类—父类）、父类析构必须为 <code>virtual</code> </li>
</ul>
<h3 id="复合-Composition-继承-Inheritance"><a href="#复合-Composition-继承-Inheritance" class="headerlink" title="复合(Composition)+继承(Inheritance)"></a>复合(Composition)+继承(Inheritance)</h3><p>析构函数顺序与构造函数恰好相反。</p>
<ul>
<li><p>情况一</p>
<blockquote>
<p><strong>构造函数</strong> ：Base —&gt; Composition —&gt; Derived<img src="https://i.loli.net/2020/09/16/iqjHPfFJ3s5malX.png" alt="Inheritance_Composition关系下的构造和析构_一_.png" style="zoom:67%;" /></p>
</blockquote>
</li>
<li><p>情况二（直接推导即知）</p>
<blockquote>
<p><strong>构造函数</strong> ：Composition —&gt; Base —&gt; Derived</p>
<img src="https://i.loli.net/2020/09/16/hanmBwb6gKfuqso.png" alt="Inheritance_Composition关系下的构造和析构_二_.png" style="zoom:67%;" />
</blockquote>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><code>non-virtual</code> 函数：非虚函数，不希望派生类重新定义（override）它；</p>
<p><code>vitual</code> 函数：虚函数，希望派生类重新定义，且已有默认定义；</p>
<p><code>pure virtual</code> 函数：纯虚函数，希望派生类一定要重新定义它，且，没有默认的定义。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p>仿函数（functors）另名函数对象（function objects）。</p>
<p>函数有函数名称，用一个 <code>()</code> 作用上去，任何一个东西如果可以接受 <code>()</code> 操作符，我们就称它 <strong>function-like</strong> 。每个<strong>仿函数</strong>都是某个类重载 <code>()</code> 运算符，然后变成了“仿函数”，实质还是一个类，但看起来具有函数的属性。</p>
<p>对 <code>()</code> 的重载，都继承了 <code>unary_function</code> 或 <code>binary_function</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span>  <span class="comment">// 一元函数</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="title">class</span> _<span class="title">Arg2</span>, <span class="title">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span>  <span class="comment">// 二元函数</span></span><br><span class="line">  <span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="模板泛化、特化"><a href="#模板泛化、特化" class="headerlink" title="模板泛化、特化"></a>模板泛化、特化</h2><p><strong>泛化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>特化</strong>：模板特化指的是模板中指定特定的数据类型，这和泛化是不同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; retrun x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板特化也有程度之分，可以部分类型指定，称之为<strong>偏特化</strong>。</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="数量不定的模板参数"><a href="#数量不定的模板参数" class="headerlink" title="数量不定的模板参数"></a>数量不定的模板参数</h3><p><code>...</code> 就是所谓的 <strong>pack(包)</strong> ，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">firstArg</span>, <span class="title">const</span> <span class="title">Types</span>&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ite = find(c.begin(), c.end(), target);</span><br></pre></td></tr></table></figure>

<h3 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (decl : coll)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚指针、虚表"><a href="#虚指针、虚表" class="headerlink" title="虚指针、虚表"></a>虚指针、虚表</h2><p>只要类里有<strong>虚函数</strong>，类的对象就有一个<strong>指针（<code>vptr</code>）</strong>，指向一个<strong>虚函数表（虚表，<code>vtbl</code>）</strong>。基类有虚函数，派生类必然有虚函数。</p>
<img src="https://i.loli.net/2020/09/17/ImqXaP8hBDcLvWu.jpg" alt="虚函数-虚指针-虚表.jpg" style="zoom:67%;" />]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>能不能在头文件中定义全局变量？</title>
    <url>/C++/%E8%83%BD%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译器驱动程序</strong>（compiler driver），它代表用户在需要时调用语言<strong>预处理器</strong>、<strong>编译器</strong>、<strong>汇编器</strong>、和<strong>链接器</strong>。</p>
<p>我们所常说的 <em>“编译生成可执行文件”</em> 实际包括以下过程：</p>
<ol>
<li><p><strong>预处理器</strong> （某些编译系统，预处理器被集成到 <strong><em>编译器</em></strong>  中）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpp [other arguments] main.c /tmp/main.i</span><br></pre></td></tr></table></figure>

<p>处理预处理指令，生成<strong>中间文件</strong>，所有的预处理器命令都是以井号（#）开头。主要任务包括：</p>
<ul>
<li>删除注释；</li>
<li>插入被 #include 指令所包含的的文件内容；</li>
<li>定义和替换由#define指令定义的符号；</li>
<li>确定代码的部分内容是否应该根据一些条件编译指令进行编译；</li>
</ul>
</li>
<li><p><strong>编译器</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s</span><br></pre></td></tr></table></figure>

<p>将预处理后的中间文件翻译成一个<strong>ASCII汇编语言文件</strong>。</p>
</li>
<li><p><strong>汇编器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">as [other arguments] -o /tmp/main.o /tmp/main.s</span><br></pre></td></tr></table></figure>

<p>将ASCII汇编语言文件翻译成一个<strong>可重定位目标文件</strong>。</p>
</li>
<li><p><strong>链接器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o</span><br></pre></td></tr></table></figure>

<p>将一个或多个可重定位目标文件，以及必要的系统目标文件组合起来，创建一个<strong>可执行文件</strong>。</p>
</li>
</ol>
<img src="https://i.loli.net/2020/10/10/9y28jwNmZRcgiGE.png" alt="编译生成可执行文件过程.png" style="zoom:67%;" />

<h2 id="非静态全局变量"><a href="#非静态全局变量" class="headerlink" title="非静态全局变量"></a>非静态全局变量</h2><p>先个下结论：<font color=red><strong>可以，但非常非常非常不建议！！</strong></font> </p>
<ul>
<li>若头文件仅被一个源文件使用到，可以正常生成可执行文件。</li>
<li>若头文件被多个源文件包含，可正常执行完 cpp、cc1、as，但在链接(ld)时便会报错（重复定义）。</li>
</ul>
<p>由上面的图可以分析出，源程序代码在生成可执行文件的过程中，前三步均可看做独立完成的，仅在最后一步将多个源文件生成的目标文件链接起来。</p>
<p>如下代码：</p>
<p>a.cpp 、 b.cpp 在经过预处理器、编译器、汇编器时均认为是没有定义变量 A 的，于是都有变量定义。在链接时，便出现了二义性（重复定义）。</p>
<blockquote>
<p>[root@localhost val]# g++ a.cpp b.cpp </p>
<p>/tmp/ccVzRqVG.o:(.bss+0x0): multiple definition of `A’</p>
<p>/tmp/ccjI4zgp.o:(.bss+0x0): first defined here</p>
<p>collect2: error: ld returned 1 exit status</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H</span></span><br><span class="line"><span class="keyword">int</span> A;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line">                                              </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a.cpp : &quot;</span> &lt;&lt; A &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    funcA();</span><br><span class="line">    A =<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b.cpp : &quot;</span> &lt;&lt; A &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><p>上面的代码如若将变量 A定义为 static，编译执行没有问题。<strong>但是</strong>，静态变量的<strong>作用域仅在 ”当前源文件“</strong> ，即两处的变量 A 不是同一个变量，是不同的文件作用域内的静态变量。</p>
<p>“静态全局变量” 这个称谓其实就有点怪异，静态变量在文件作用域内就是全局的，且仅在文件作用域内。</p>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>全局变量在某一个源文件中定义，其余源文件若要使用，将外部声明 <code>extern</code> 写在头文件中，源文件包含这个头文件。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">int</span> nums;  <span class="comment">// 全局变量定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// out.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> nums;    <span class="comment">//外部变量声明</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;out.h&quot;</span> <span class="comment">// 相当于声明了外部变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_nums</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    nums = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>g++ a.cpp b.cpp</p>
</blockquote>
<h2 id="更加深入-全局变量"><a href="#更加深入-全局变量" class="headerlink" title="更加深入-全局变量"></a>更加深入-全局变量</h2><p>如果在 a.h 中变量定义时，定义为 <strong>“弱定义”</strong>，那么是能达到预期的目标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  A __attribute__((weak));</span><br></pre></td></tr></table></figure>

<h3 id="Linux-gcc"><a href="#Linux-gcc" class="headerlink" title="Linux gcc"></a>Linux gcc</h3><p><font color=red><strong><em>注意：仅在 gcc 下正确，换做 g++ 同样报错（重复定义）。</em></strong></font> </p>
<p>在编译时，编译器向汇编器输出每个全局符号，或者是<em>强（strong）</em>或者是<em>弱（weak）</em>，而编译器把这个信息隐含地编码在可重定位目标文件的符号表里。<strong>函数</strong>和<strong>已初始化的全局变量</strong>是*<strong>强(strong)符号*** 。<strong>未初始化的全局变量</strong>是*</strong>弱(weak)符号***。</p>
<p>根据弱符号的定义，<strong>Linux链接器</strong>使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li>规则1：不允许有多个同名的强符号。</li>
<li>规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>规则3：若干有多个弱符号同名，那么从这些弱符号中任意选择一个。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bar.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; &quot;begin f() x = &quot; &lt;&lt; x &lt;&lt; std::endl;      </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin f() x = %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">654321</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x  = <span class="number">12345</span>; <span class="comment">// 已初始化 强符号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f();</span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; &quot;after f() x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after f() x = %d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost 7]# gcc foo.c bar.c </span><br><span class="line">[root@localhost 7]# ./a.out </span><br><span class="line">begin f() x = 12345</span><br><span class="line">after f() x = 654321</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Union-Find算法详解</title>
    <url>/Algorithm/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Union-Find%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>【<font color=red><strong>声明</strong></font>】 <strong>本文转载自 <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/UnionFind%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md">Union-Find算法详解 - GitHub</a></strong> </p>
<p> Union-Find 算法，也就是常说的并查集算法，主要是解决图论中「<strong>动态连通性</strong>」问题的。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>简单说，动态连通性其实可以抽象成给一幅有 <code>N</code> 个结点的图连线，其中结点按 0~N 编号。</p>
<p>Union-Find 算法主要需要实现以下API：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<p>1、自反性：结点 <code>a</code> 和 <code>a</code> 是连通的。</p>
<p>2、对称性：如果结点 <code>a</code> 和 <code>b</code> 连通，那么 <code>b</code> 和 <code>a</code> 也连通。</p>
<p>3、传递性：如果结点 <code>a</code> 和 <code>b</code> 连通， <code>b</code> 和 <code>c</code> 连通，那么 <code>a</code> 和 <code>c</code> 也连通。</p>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>假定我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 其他函数 **/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;            <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;    <span class="comment">// parent[i]: 结点 i 的父节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UnionFind::UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">    <span class="comment">// 初始时所有结点互不连通</span></span><br><span class="line">    <span class="comment">// 父节点指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        parent.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionFind::connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (rootA == rootB)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 将一棵树接在另一棵树上</span></span><br><span class="line">    parent[a] = rootB;</span><br><span class="line">    <span class="comment">// 连通分量 -1</span></span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UnionFind::isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRoot(a) == findRoot(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnionFind::findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根结点有 x == parent[x]</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x])</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，主要 API <code>isConnected</code> 和 <code>connect</code> 中的复杂度都是 <code>findRoot</code> 函数造成的，所以说它们的复杂度和 <code>findRoot</code> 一样。<code>findRoot</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度<strong>最坏情况</strong>下可能变成 <code>N</code>。</p>
<h3 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h3><p>我们一开始就是简单粗暴的把 <code>a</code> 所在的树接到 <code>b</code> 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 其他函数 **/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;            <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;    <span class="comment">// parent[i]: 结点 i 的父节点</span></span><br><span class="line">    <span class="comment">// 新增一个数组记录树的 “重量”</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UnionFind::UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">    <span class="comment">// 初始时所有结点互不连通</span></span><br><span class="line">    <span class="comment">// 父节点指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        parent.push_back(i);</span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionFind::connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (rootA == rootB)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 小树根节点接到大树根节点下 「较平衡」</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootA] &lt; size[rootB])&#123;</span><br><span class="line">        parent[rootA] = rootB;</span><br><span class="line">        size[rootB] += size[rootA];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootB] = rootA;</span><br><span class="line">        size[rootA] += size[rootB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连通分量 -1</span></span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。此时，<code>findRoot</code> 、<code>connect</code>、<code>isConnected</code> 的时间复杂度都下降为 <code>O(logN)</code> 。</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？这样<code>findRoot</code> 就能以 <code>O(1)</code> 的时间找到某一节点的根节点，相应的， <code>connect</code> 和 <code>isConnected</code>  复杂度都下降为 <code>O(1)</code> 。要做到这一点，非常简单，只需要在 <code>findRoot</code>  中加一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnionFind::findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根结点有 x == parent[x]</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">        <span class="comment">// 「路径压缩」 减少查询迭代次数</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n);         </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;        <span class="comment">/* 将 a 和 b 连接(连通) */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;    <span class="comment">/* 判断 a 和 b 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125; <span class="comment">/* 返回图中的连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span></span>;            <span class="comment">/* 返回结点 x 的根节点 */</span></span><br><span class="line">    <span class="comment">/** 其他函数 **/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;            <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;    <span class="comment">// parent[i]: 结点 i 的父节点    </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;    <span class="comment">// 新增一个数组记录树的 “重量”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UnionFind::UnionFind(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">    <span class="comment">// 初始时所有结点互不连通</span></span><br><span class="line">    <span class="comment">// 父节点指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        parent.push_back(i);</span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size.push_back(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionFind::connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootA = findRoot(a);</span><br><span class="line">    <span class="keyword">int</span> rootB = findRoot(b);</span><br><span class="line">    <span class="keyword">if</span> (rootA == rootB)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 小树根节点接到大树根节点下 「较平衡」</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootA] &lt; size[rootB])&#123;</span><br><span class="line">        parent[rootA] = rootB;</span><br><span class="line">        size[rootB] += size[rootA];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootB] = rootA;</span><br><span class="line">        size[rootA] += size[rootB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连通分量 -1</span></span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UnionFind::isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRoot(a) == findRoot(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnionFind::findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根结点有 x == parent[x]</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">        <span class="comment">// 「路径压缩」 减少查询迭代次数</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法收录</title>
    <url>/Algorithm/%E7%AE%97%E6%B3%95%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><blockquote>
<p>约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p><a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环——公式法（递推公式）</a> </p>
<p><strong>递推公式：</strong><br><font color=red><b><em>f</em>(<em>N</em>,<em>M</em>) = ( <em>f</em>(<em>N</em>−1,<em>M</em>) + <em>M</em> ) % <em>N</em></b></font> </p>
<ul>
<li><em>f</em>(<em>N</em>,<em>M</em>) 表示，N个人报数，每报到M时杀掉那个人，最终胜利者的编号</li>
<li><em>f</em>(<em>N</em>−1,<em>M</em>) 表示，N-1个人报数，每报到M时杀掉那个人，最终胜利者的编号</li>
</ul>
<p><em>注：求出的结果是数组中的下标，若从1开始编号，最终的编号还要加 1。</em> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circle</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>; <span class="comment">// 仅一个人时 胜利者下标为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        p=(p + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【<strong>例题</strong>】</p>
<p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">孩子们的游戏(圆圈中最后剩下的数)</a> </p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>动态规划（Dynamic Programming）问题一般形式是<strong>求最值</strong> 。</p>
<p>求解动态规划问题的核心是<strong>穷举</strong>，由于这类问题存在<strong>重叠子问题</strong>，因此简单的暴力算法效率极低，便需要 <strong>DP table</strong> 来优化穷举过程。</p>
</blockquote>
<p>动态规划的核心思想是 <font color=red><strong>以空间换时间</strong></font> 。</p>
<p>【<strong>算法解析</strong>】</p>
<p><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a> </p>
<p>【<strong>例题分析</strong>】</p>
<p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架- labuladong的算法小抄</a> </p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Algorithm/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>排序算法可以分为内部排序和外部排序，<strong>内部排序</strong>是数据记录在内存中进行排序，而<strong>外部排序</strong>是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<p><img src="https://i.loli.net/2021/01/12/7of3z16dpaKVUgh.png" alt="十大排序算法"></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p>顾名思义，就像一堆气泡，大的气泡往上冒，一次遍历完的结果是待排序的气泡中最大的气泡冒出到有序序列。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>从第一个元素开始比较相邻元素，若前者更大，则交换这两个元素；</li>
<li>一次遍历完，一个元素完成有序；</li>
<li>重复第一步，直到所有元素有序。</li>
</ol>
<p>【<strong>优化</strong>】<strong>当一次遍历结束，没有发生交换，整个序列便已完成排序。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">bubble_sort</span>(<span class="title">vector</span>&lt;T&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 优化 一次遍历是否发生交换</span></span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+<span class="number">1</span> &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums[i], nums[i+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)    <span class="keyword">break</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>每次遍历，选择待排序元素中最大元素，放置到待排序子数组最后位置。一次遍历至多只进行交换一次。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>遍历待排序子数组，选择最大待排序元素；</li>
<li>将待排序最大元素放置在待排序子数组最后位置；</li>
<li>重复第一步，直到所有元素有序。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">select_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[max_index] &lt; nums[i])</span><br><span class="line">                max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[max_index], nums[n<span class="number">-1</span>]);</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote>
<p>将待排序元素依次插入有序序列</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>将第一个元素视为有序序列，往后为待排序序列；</li>
<li>依次向有序序列插入元素到合适的位置。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ordered = <span class="number">1</span>; ordered &lt; n; ++ordered)&#123;</span><br><span class="line">        Type value = nums[ordered];</span><br><span class="line">        <span class="keyword">int</span> i = ordered - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; value)&#123;</span><br><span class="line">            nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<p>也称递减增量排序算法，希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
</blockquote>
<p>【图解】</p>
<p>参考：<a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">shell_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// 增量 gap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="comment">// 增量为 gap 的子序列【插入排序】</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; value &lt; nums[j - gap]) &#123; </span><br><span class="line">                nums[j] = nums[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>归并排序采用分而治之的思想。将原序列均分为两个子序列，选排序子序列，再合并有序子序列。</p>
</blockquote>
<p>【图解】</p>
<p>参考：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*logn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">merge_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    _merge_sort(nums, start, mid);    <span class="comment">// [start, mid]</span></span><br><span class="line">    _merge_sort(nums, mid + <span class="number">1</span>, end);  <span class="comment">// [mid+1, end]</span></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">temp</span><span class="params">(end - start + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 暂存数组 可只使用一个 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> left = start, right = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[right])</span><br><span class="line">            temp[t++] = nums[left++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[t++] = nums[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid)</span><br><span class="line">        temp[t++] = nums[left++];</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= end)</span><br><span class="line">        temp[t++] = nums[right++];</span><br><span class="line">    <span class="comment">// 拷贝暂存的有序序列</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">        nums[start++] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>)&#123;</span></span><br><span class="line">    _merge_sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>【步骤】</p>
<ol>
<li>待排序列中取一个“基准”</li>
<li>所有比“基准”小的元素放”基准“前面，所有比“基准”大的元素放“基准”后面。</li>
<li>递归处理基准两侧的子序列。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*logn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">quick_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 基准 nums[start]</span></span><br><span class="line">    <span class="keyword">int</span> low = start, high = end;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= nums[start])  <span class="comment">// 先从右找小于基准</span></span><br><span class="line">            --high;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= nums[start])   <span class="comment">// 再从左找大于基准</span></span><br><span class="line">            ++low;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">            swap(nums[low], nums[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将基准归位</span></span><br><span class="line">    swap(nums[start], nums[low]);  </span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    _quick_sort(nums, start, low - <span class="number">1</span>);</span><br><span class="line">    _quick_sort(nums, low + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">quick_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    _quick_sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>堆排序将待排序数组视为静态二叉树组。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>构建（大顶）堆：此处从有孩子的结点开始调整；</li>
<li>取堆顶元素与末尾元素交换；</li>
<li>调整堆结构，循环执行，直到所有元素有序。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定（可能打破原来元素的相对位置）</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*logn)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// 自顶向下调整堆 [start, end]</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">adjustMaxHeap</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dad = start; <span class="comment">// 父结点</span></span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 子结点</span></span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// 选择较大的子结点</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; nums[son] &lt; nums[son + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++son;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[son] &lt;= nums[dad]) <span class="comment">// 满足大顶堆条件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 不满足大顶堆添加 交换父子结点 继续向下调整</span></span><br><span class="line">            swap(nums[dad], nums[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">heap_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 1. 构建堆 从第一个有孩子的结点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        adjustMaxHeap(nums, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 依次取最大元素放置末尾</span></span><br><span class="line">    --n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[n]);</span><br><span class="line">        adjustMaxHeap(nums, <span class="number">0</span>, --n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><blockquote>
<p>计数排序算法思想就是先遍历一遍得到所有元素的值区间[min, max]，然后使用临时数组统计区间中每个值出现的次数，再得到小于等于该元素的元素个数，便得到该元素放在目标数组中的位置，最后给目标数组赋值。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>得到待排序序列的最值 [min, max]；</li>
<li>统计 [min, max] 中值出现的次数；</li>
<li>对所有的计数累加，得到小于等于该元素的个数（即该元素排序的位置）；</li>
<li>反向填充临时数组；</li>
<li>赋值目标数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">counting_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 得到待排序序列的最值 [min, max]</span></span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; nums[i])</span><br><span class="line">            min = nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (max &lt; nums[i])</span><br><span class="line">            max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计 [min, max] 中值出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> n_count = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">count</span><span class="params">(n_count, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ++count[nums[i] - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 对所有的计数累加，得到小于等于该元素的个数（即该元素排序的位置）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_count; ++i) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 反向填充临时数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">temp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        temp[--count[nums[i] - min]] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 给目标数组赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><blockquote>
<p>桶排序是计数排序的升级。设置一个定量的数组当作空桶，得到待排序元素范围 [min, max] 后，将元素放入对应的<strong>桶</strong>中。对非空的桶进行排序。最后将非空桶中的元素放回目标数组。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>得到待排序序列的元素范围 [min, max]；</li>
<li>将待排序元素放入对应的桶中；</li>
<li>队非空的桶进行排序；</li>
<li>将非空桶中的元素放回目标数组。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n+m)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n+m)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">bucket_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>, <span class="title">int</span> <span class="title">bucketCount</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 设置一个定量的数组当作空桶</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Type&gt;&gt; <span class="title">temp</span><span class="params">(bucketCount, <span class="built_in">vector</span>&lt;Type&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// 2. 得到待排序序列的元素范围[min, max]</span></span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; nums[i])</span><br><span class="line">            min = nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (max &lt; nums[i])</span><br><span class="line">            max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 将待排序元素放入对应的桶中</span></span><br><span class="line">    <span class="keyword">int</span> space = (max - min + <span class="number">1</span>) / bucketCount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp[(nums[i] - min) / space].push_back(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 对非空的桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; ++i) &#123;</span><br><span class="line">        insert_sort(temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 将非空桶中的元素放回目标数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp[i].size(); ++j) &#123;</span><br><span class="line">            nums[index++] = temp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<p>基数排序是计数排序和桶排序的结合。</p>
</blockquote>
<p>【步骤】</p>
<ol>
<li>计算最大位数 <code>bits</code></li>
<li>进行 <code>bits</code> 次排序<ol>
<li>清空计数</li>
<li>统计每个桶中的记录数</li>
<li>将临时数组中的位置依次分配给每个桶</li>
<li>反向将所有桶中记录依次收集到临时数组中</li>
<li>将临时数组的内容复制到目标数组中</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 稳定性：稳定</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n*m)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n+m)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">radix_sort</span>(<span class="title">vector</span>&lt;Type&gt;&amp; <span class="title">nums</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 计算最大位数 bits</span></span><br><span class="line">    <span class="keyword">int</span> max_value = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_value &lt; nums[i])</span><br><span class="line">            max_value = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;  <span class="comment">// 最大位数</span></span><br><span class="line">    <span class="keyword">while</span> (max_value) &#123;</span><br><span class="line">        max_value /= <span class="number">10</span>;</span><br><span class="line">        ++bits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 进行 bits 次排序</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Type&gt; <span class="title">temp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (bits--) &#123;</span><br><span class="line">        <span class="comment">// 2.1 清空计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.2 统计每个桶中的记录数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++count[(nums[i] / radix) % <span class="number">10</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.3 将 temp 中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.4 反向将所有桶中记录依次收集到 temp 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            temp[--count[(nums[i] / radix) % <span class="number">10</span>]] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.5 将临时数组的内容复制到 nums 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>笔记</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-RB-tree</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-RB-tree/</url>
    <content><![CDATA[<p><strong>在线演示：</strong><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树在线操作演示</a></p>
<h2 id="红黑树概念"><a href="#红黑树概念" class="headerlink" title="红黑树概念"></a>红黑树概念</h2><p><strong>RB Tree</strong>，全称是Red-Black Tree，又称为“红黑树”。红黑树本质上是一种<strong>二叉查找树</strong>，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 <code>O(logn)</code>。</p>
<h2 id="红黑树的性质-重点"><a href="#红黑树的性质-重点" class="headerlink" title="红黑树的性质(重点)"></a>红黑树的性质(重点)</h2><ol>
<li>每个节点不是<font color=red><strong>红色</strong></font>就是<strong>黑色</strong></li>
<li><strong>根结点</strong>永远都是<strong>黑色</strong></li>
<li>所有<strong>叶节点</strong>都是<strong>黑色</strong>（注意这里说叶子节点其实是上图中的 <code>NIL</code> 节点）</li>
<li>父子节点不同为<font color=red><strong>红色</strong></font></li>
<li>从任一节点到其子树中每个叶子节点的r任一路径都包含<strong>相同数量</strong>的<strong>黑色</strong>节点</li>
</ol>
<p><strong>注意</strong>：</p>
<blockquote>
<p>性质(3)中的叶子节点，是只为空(NIL或null)的节点。</p>
<p>性质(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/10/vfWSnHY2ZmdX3D6.jpg" alt="红黑树.jpg"></p>
<h2 id="树的旋转操作"><a href="#树的旋转操作" class="headerlink" title="树的旋转操作"></a>树的旋转操作</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>简略记忆：<font color=red size=5><strong>“右子变老子”</strong></font>，<strong>左旋中的“左”，意味着“被旋转的节点将变成一个左节点”</strong>。如图所示</p>
<ol>
<li>旋转点右孩子的左子树(B)变成旋转点的右子树</li>
<li>旋转点右孩子顶替旋转点位置</li>
<li>修改旋转点与右孩子关系</li>
</ol>
<img src="https://i.loli.net/2020/09/07/7JhabscBD6kIler.png" alt="左旋.png" style="zoom: 80%;" />

<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-左旋代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 左旋 右子节点变为父节点（原父节点变为右子节点的左节点）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __x-&gt;_M_right;</span><br><span class="line">  __x-&gt;_M_right = __y-&gt;_M_left; <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="comment">/* Step 1: right_child 的左子树 B 变成 p 的右子树 */</span></span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_left !=<span class="number">0</span>)</span><br><span class="line">    __y-&gt;_M_left-&gt;_M_parent = __x; <span class="comment">// B 的父节点修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: right_child 顶替 p 的位置 */</span></span><br><span class="line">  __y-&gt;_M_parent = __x-&gt;_M_parent;</span><br><span class="line">  <span class="keyword">if</span> (__x == __root)<span class="comment">// right_child 的父节点修改 </span></span><br><span class="line">    __root = __y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_left) <span class="comment">// p 为父节点的左孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_left = __y; </span><br><span class="line">  <span class="keyword">else</span>                                     <span class="comment">// p 为父节点的右孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 修改 p 和 right_child 关系 */</span></span><br><span class="line">  __y-&gt;_M_left = __x;</span><br><span class="line">  __x-&gt;_M_parent = __y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>简略记忆：<font color=red size=5><strong>“左子变老子”</strong></font>，<strong>右旋中的“右”，意味着“被旋转的节点将变成一个右节点”</strong>。如图所示</p>
<ol>
<li>旋转点左孩子的右子树(B)变成旋转点的左子树</li>
<li>旋转点左孩子顶替旋转点位置</li>
<li>修改旋转点与右孩子关系</li>
</ol>
<img src="https://i.loli.net/2020/09/07/VOxf3ajq8hH7ETd.png" alt="右旋.png" style="zoom: 80%;" />

<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-右旋代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 右旋 左子节点变为父节点（原父节点变为左孩子的右孩子）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  _Rb_tree_node_base* __y = __x-&gt;_M_left; <span class="comment">// 左孩子</span></span><br><span class="line">  <span class="comment">/* Step 1: left_child 的右子树 B 变成 p 的左子树 */</span></span><br><span class="line">  __x-&gt;_M_left = __y-&gt;_M_right; </span><br><span class="line">  <span class="keyword">if</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">    __y-&gt;_M_right-&gt;_M_parent = __x; <span class="comment">// B 的父节点修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: left_child 顶替 p 的位置 */</span></span><br><span class="line">  __y-&gt;_M_parent = __x-&gt;_M_parent; <span class="comment">// left_child 的父节点修改</span></span><br><span class="line">  <span class="keyword">if</span> (__x == __root) <span class="comment">// p 为根节点</span></span><br><span class="line">    __root = __y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_right) <span class="comment">// p 为父节点的左孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_right = __y;</span><br><span class="line">  <span class="keyword">else</span>                                      <span class="comment">// p 为父节点的右孩子</span></span><br><span class="line">    __x-&gt;_M_parent-&gt;_M_left = __y;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Step 3: 修改 p 和 left_child 关系 */</span></span><br><span class="line">  __y-&gt;_M_right = __x;</span><br><span class="line">  __x-&gt;_M_parent = __y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="STL红黑树插入节点"><a href="#STL红黑树插入节点" class="headerlink" title="STL红黑树插入节点"></a>STL红黑树插入节点</h2><p>红黑树的插入操作主要步骤如下：</p>
<ul>
<li>插入节点，和<strong>二叉查找树</strong>一样</li>
<li>调整结构，保证满足红黑树状态<ul>
<li>旋转操作</li>
<li>重新着色（新插入节点初始为<font color=red><strong>红色</strong></font>）</li>
</ul>
</li>
</ul>
<p><strong>假设：</strong></p>
<blockquote>
<p><strong>X</strong>：新节点（默认<font color=red><strong>红色</strong></font>）</p>
<p><strong>P</strong>：父节点</p>
<p><strong>S</strong>：伯父节点（父节点的兄弟节点）</p>
<p><strong>G</strong>：祖父节点</p>
<p><strong>GG</strong>：曾祖父节点</p>
</blockquote>
<table><tr><td bgcolor=yellow><b>强调：只有当父节点P为<font color=red >红色</font>时需要调整树形!!!</b></td></tr></table>

<p><strong>插入节点分为以下情况：</strong></p>
<ul>
<li><p><strong>状况1：无父</strong></p>
<blockquote>
<p>没有父节点（即插入后为根节点）</p>
</blockquote>
<p>直接着色新节点为<strong>黑色</strong>。</p>
</li>
<li><p><strong>状况2：父黑</strong></p>
<blockquote>
<p>父节点为黑色</p>
</blockquote>
<p>不用变色，新节点为<font color=red><strong>红色</strong></font>。</p>
</li>
<li><p><strong>状况3：父红，伯黑（或NIL），父子同侧</strong></p>
</li>
<li><p><strong>状况4：父红，伯黑（或NIL），父子异侧</strong></p>
</li>
<li><p><strong>状况5：父红，伯红</strong></p>
</li>
</ul>
<h3 id="状况3：父红，伯黑（或NIL），父子同侧"><a href="#状况3：父红，伯黑（或NIL），父子同侧" class="headerlink" title="状况3：父红，伯黑（或NIL），父子同侧"></a>状况3：父红，伯黑（或NIL），父子同侧</h3><blockquote>
<p>父节点是红色，伯父节点也是黑色（或NIL），祖父节点必定是黑色。</p>
<p>父子节点同侧，即，子节点、父节点、以及祖父节点是直线型。</p>
</blockquote>
<ol start="2">
<li>父节点、祖父节点<strong>变色</strong>（父节点变为黑色，祖父节点变为红色）</li>
<li>单旋，以<strong>祖父节点</strong>为旋转点<ul>
<li>父节点在左侧——右旋</li>
<li>父节点在右侧——左旋</li>
</ul>
</li>
</ol>
<img src="https://i.loli.net/2020/09/10/nSV3irRho1fXECK.png" alt="红黑树-父红-伯黑_或NIL_-父子同侧.png" />

<h3 id="状况4：父红，伯黑（或NIL），父子异侧"><a href="#状况4：父红，伯黑（或NIL），父子异侧" class="headerlink" title="状况4：父红，伯黑（或NIL），父子异侧"></a>状况4：父红，伯黑（或NIL），父子异侧</h3><blockquote>
<p>父节点是红色，伯父节点也是黑色（或NIL），祖父节点必定是黑色。</p>
<p>父子节点异侧，即，子节点、父节点、以及祖父节点是非直线型。</p>
</blockquote>
<ol>
<li>单旋，以父节点为旋转点<ul>
<li>子节点在左侧——右旋</li>
<li>子节点在右侧——左旋</li>
</ul>
</li>
<li>把<strong>父节点</strong>作为<strong>“新节点”</strong></li>
<li>按 <strong>状况3：父红，伯黑（或NIL），父子同侧</strong> 继续处理</li>
</ol>
<img src="https://i.loli.net/2020/09/10/WaumZbHoJGAKRU4.png" alt="红黑树-父红-伯黑_或NIL_-父子异侧.png" style="zoom:67%;" />

<h3 id="状况5：父红，伯红"><a href="#状况5：父红，伯红" class="headerlink" title="状况5：父红，伯红"></a>状况5：父红，伯红</h3><blockquote>
<p>父节点是红色，伯父节点也是红色，祖父节点必定是黑色。</p>
</blockquote>
<ol>
<li><p>变色</p>
<ul>
<li>父节点变<strong>黑色</strong></li>
<li>伯父节点变<strong>黑色</strong></li>
<li>祖父节点变<font color=red><strong>红色</strong></font></li>
</ul>
</li>
<li><p>把<strong>祖父节点</strong>作为<strong>“新节点”</strong></p>
</li>
<li><p>向上继续调整：</p>
<p>3.1 曾祖父节点为<strong>黑色</strong>，结束</p>
<p>3.2 当前新节点为<strong>根</strong>，直接设置成<strong>黑色</strong>，结束</p>
<p>3.3 曾祖父节点为<font color=red><strong>红色</strong></font>，所属状况，继续调整树形</p>
</li>
</ol>
<img src="https://i.loli.net/2020/09/10/Xzra3KJARyQPIWB.png" alt="红黑树-父红-伯红.png" style="zoom:67%;" />

<h3 id="STL红黑树调整平衡源码"><a href="#STL红黑树调整平衡源码" class="headerlink" title="STL红黑树调整平衡源码"></a>STL红黑树调整平衡源码</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-STL红黑树调整平衡</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*&amp; __root)</span><br><span class="line">&#123;</span><br><span class="line">  __x-&gt;_M_color = _S_rb_tree_red; <span class="comment">// 新节点 设置为红</span></span><br><span class="line">  <span class="comment">/* 当前新节点不是根节点，并且其父节点为红色 */</span></span><br><span class="line">  <span class="keyword">while</span> (__x != __root &amp;&amp; __x-&gt;_M_parent-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">    <span class="comment">/* 父红，父节点为祖父节点的左孩子 */</span></span><br><span class="line">    <span class="keyword">if</span> (__x-&gt;_M_parent == __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left) &#123;</span><br><span class="line">      _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_right; <span class="comment">// 伯父节点</span></span><br><span class="line">      <span class="comment">/* 状况5：父(左)红，伯(右)红 */</span></span><br><span class="line">      <span class="keyword">if</span> (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123; </span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; <span class="comment">//父变黑</span></span><br><span class="line">        __y-&gt;_M_color = _S_rb_tree_black; <span class="comment">//伯变黑</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; <span class="comment">//祖父变红</span></span><br><span class="line">        __x = __x-&gt;_M_parent-&gt;_M_parent; <span class="comment">//设置祖父为 当前新节点</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 伯父节点为黑色（或NIL）</span></span><br><span class="line">      <span class="comment">/* 状况4：父(左)红，伯(右)黑(或NIL)，新节点为右子 #附加# */</span></span><br><span class="line">        <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_right) &#123;</span><br><span class="line">          __x = __x-&gt;_M_parent;</span><br><span class="line">          _Rb_tree_rotate_left(__x, __root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 状况3：父(左)红，伯(右)黑(或NIL)，新节点为左子 */</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        _Rb_tree_rotate_right(__x-&gt;_M_parent-&gt;_M_parent, __root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Rb_tree_node_base* __y = __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_left; <span class="comment">// 伯父节点</span></span><br><span class="line">      <span class="comment">/* 状况5：父(右)红，伯(左)红 */</span></span><br><span class="line">      <span class="keyword">if</span> (__y &amp;&amp; __y-&gt;_M_color == _S_rb_tree_red) &#123;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black; <span class="comment">//父变黑</span></span><br><span class="line">        __y-&gt;_M_color = _S_rb_tree_black; <span class="comment">//伯父变黑</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red; <span class="comment">//祖父变红</span></span><br><span class="line">        __x = __x-&gt;_M_parent-&gt;_M_parent; <span class="comment">//祖父为 新节点</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 状况4：父(右)红，伯(左)黑(或NIL)，新节点为左子 */</span></span><br><span class="line">        <span class="keyword">if</span> (__x == __x-&gt;_M_parent-&gt;_M_left) &#123;</span><br><span class="line">          __x = __x-&gt;_M_parent;</span><br><span class="line">          _Rb_tree_rotate_right(__x, __root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 状况3：父(右)红，伯(左)黑(或NIL)，新节点为右子 */</span></span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_color = _S_rb_tree_black;</span><br><span class="line">        __x-&gt;_M_parent-&gt;_M_parent-&gt;_M_color = _S_rb_tree_red;</span><br><span class="line">        _Rb_tree_rotate_left(__x-&gt;_M_parent-&gt;_M_parent, __root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __root-&gt;_M_color = _S_rb_tree_black; <span class="comment">// 根节点设置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="STL红黑树删除节点"><a href="#STL红黑树删除节点" class="headerlink" title="STL红黑树删除节点"></a>STL红黑树删除节点</h2><p>红黑树可以看成是具有特殊性质的二叉查找树，因此红黑树的删除过程可分为两步：</p>
<ul>
<li><strong>第一步：二叉树的删除过程</strong></li>
<li><strong>第二步：红黑树的调整过程</strong></li>
</ul>
<h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><p>二叉查找树的删除分为以下情况：</p>
<ol>
<li>删除节点是叶子节点，直接删除；</li>
<li>删除节点只有左孩子（或右孩子），孩子节点替代删除节点位置；</li>
<li>删除节点有两个孩子，选择一个合适的<strong>子孙节点</strong>替代删除节点位置，该节点称为<strong>继承节点</strong>。</li>
</ol>
<h3 id="红黑树的调整过程"><a href="#红黑树的调整过程" class="headerlink" title="红黑树的调整过程"></a>红黑树的调整过程</h3><p>按照二叉查找树的规则删除节点后，还需要检查是非满足红黑树的性质。</p>
<p>根据红黑树的性质，主要是性质4）父子节点不同为<font color=red><strong>红色</strong></font>，性质5）从任一节点到其子树中每个叶子节点的r任一路径都包含<strong>相同数量</strong>的<strong>黑色</strong>节点。</p>
<p>待补充。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u011240877/article/details/53329023">重温数据结构：深入理解红黑树</a> </p>
<p><a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-分配器Allocators</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%88%86%E9%85%8D%E5%99%A8Allocator/</url>
    <content><![CDATA[<h1 id="先谈operator-new-和malloc"><a href="#先谈operator-new-和malloc" class="headerlink" title="先谈operator new()和malloc()"></a>先谈operator new()和malloc()</h1><p> <strong>new</strong>：指我们在C++里通常用到的<strong>运算符</strong></p>
<p><strong>operator new()**：指对new的重载形式，它是一个</strong>函数**，并不是运算符</p>
<p>函数operator new中调用malloc()进行内存分配。</p>
<p>malloc实际内存分配得到的内存空间如下：</p>
<p><img src="https://i.loli.net/2020/08/04/xN2TpBZyt3eKSoP.png" alt="malloc-new-分配得到的内存空间.png"></p>
<p>new 运算符执行过程：</p>
<ol>
<li>调用operator new分配内存（可重载）</li>
<li>调用构造函数构造生成类对象</li>
<li>返回相应的指针</li>
</ol>
<h1 id="SGI标准的分配器-—-allocator"><a href="#SGI标准的分配器-—-allocator" class="headerlink" title="SGI标准的分配器 — allocator"></a>SGI标准的分配器 — allocator</h1><p>最重要的两个函数：<code>allocate</code> 、<code>deallocate</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用 operator new()</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//调用 operator delete()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocato::deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br></pre></td></tr></table></figure>

<p>不建议使用，效率不佳，只对C++的<code>::operator new</code> 和 <code>::operator delete</code> 做了简单的包装在STL实际使用中，并没有使用 <code>allocator</code> 这个分配器。</p>
<h1 id="SGI-STL分配器-—-alloc（G2-9"><a href="#SGI-STL分配器-—-alloc（G2-9" class="headerlink" title="SGI STL分配器 — alloc（G2.9)"></a>SGI STL分配器 — alloc（G2.9)</h1><p><strong><em>注意：G4.9以后默认的分配器又变成了allocator；G4.9的__pool_alloc就是G2.9的alloc</em></strong></p>
<p>16条链表，每一条链表负责不同大小的区块。第0条负责8字节大小，以8字节大小增长</p>
<p>优点：减少内存分配时多余空间的分配</p>
<img src="https://i.loli.net/2020/08/04/NJt2yKDZ7E4Xo6P.png" alt="SGI-STL使用的分配器alloc原理图.png" style="zoom:70%;" />]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-deque</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-deque/</url>
    <content><![CDATA[<img src="https://i.loli.net/2020/08/08/wGu91Lk2fCWIN5U.jpg" alt="deque示意图.jpg" style="zoom: 10%;" />

<h2 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h2><ul>
<li>deque 是一种<strong>双向开口</strong>的<strong>连续线性</strong>空间。可以在头尾两端分别做元素的插入和删除操作。</li>
<li>deque是有一段一段的定量连续空间构成，是<strong>动态分段连续</strong>。</li>
<li>deque 和 vector 的差异：<ul>
<li>deque 允许于常数时间内对两端进行元素的插入或移除操作。</li>
<li>deque 没有容量，它是动态地以分段连续空间组合而成。</li>
</ul>
</li>
<li>deque 采用一块所谓的 <code>map</code> 作为主控。这个 map 是一小块连续空间（默认初值大小<strong>8个节点</strong>），其中每个节点都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。</li>
<li>deque 是分段连续空间，迭代器维持其“整体连续”的<strong>假象</strong>，并提供随机存取的接口。</li>
<li>一旦<code>map</code>提供的节点不足，就必须重新配置一个更大的一块<code>map</code>（<strong>至少两倍+2</strong>）。并将原来的数据放在<strong>中央</strong>，以使头尾两端的扩充能量一样大。</li>
<li>插入数据时，deque会根据插入位置与两端的距离判断向前还是向后。</li>
</ul>
<img src="https://i.loli.net/2020/08/08/nl75O1bUu9TzIQ4.png" alt="deque分段连续示意图.png" style="zoom:80%;" />

<h2 id="deque-的中控器map"><a href="#deque-的中控器map" class="headerlink" title="deque 的中控器map"></a>deque 的中控器map</h2><p>deque 采用一块所谓的 <code>map</code> 作为主控。这个 map 是一小块连续空间，其中每个节点都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。</p>
<h3 id="map默认初始大小为8"><a href="#map默认初始大小为8" class="headerlink" title="map默认初始大小为8"></a>map默认初始大小为8</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; _S_initial_map_size = <span class="number">8</span> &#125;; <span class="comment">// map默认初始大小 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _M_initialize_map(size_t __num_elements)中</span></span><br><span class="line"><span class="comment">// map最少8个节点，最多“所需节点数+2”（前后各预留一个，扩容时可以用）</span></span><br><span class="line"><span class="keyword">this</span>-&gt;_M_impl._M_map_size = <span class="built_in">std</span>::<span class="built_in">max</span>((<span class="keyword">size_t</span>)_S_initial_map_size, <span class="keyword">size_t</span>(__num_nodes + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="map空间重新配置"><a href="#map空间重新配置" class="headerlink" title="map空间重新配置"></a>map空间重新配置</h3><p>扩容一次至<strong>至少两倍+2</strong>。</p>
<blockquote>
<p>size_type __new_map_size = _M_map_size + max(_M_map_size, __nodes_to_add) + 2;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _M_reserve_map_at_back (size_type __nodes_to_add = <span class="number">1</span>) &#123; <span class="comment">/*默认新增节点数=1*/</span></span><br><span class="line">  <span class="keyword">if</span> (__nodes_to_add + <span class="number">1</span> &gt; _M_map_size - (_M_finish._M_node - _M_map))</span><br><span class="line">    _M_reallocate_map(__nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_reserve_map_at_front (size_type __nodes_to_add = <span class="number">1</span>) &#123; <span class="comment">/*默认新增节点数=1*/</span></span><br><span class="line">  <span class="keyword">if</span> (__nodes_to_add &gt; size_type(_M_start._M_node - _M_map))</span><br><span class="line">    _M_reallocate_map(__nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;_Tp,_Alloc&gt;:</span>:_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          <span class="keyword">bool</span> __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + <span class="number">1</span>;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">   <span class="comment">/* map节点总数 &gt; 2倍新需节点数，则移动调整节点到中央 */</span></span><br><span class="line">  <span class="keyword">if</span> (_M_map_size &gt; <span class="number">2</span> * __new_num_nodes) &#123;</span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / <span class="number">2</span> </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      copy(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      copy_backward(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/* map节点总数不足2倍新需节点数，从新配置 */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 重点!!!  现有map节点数 + max(现有map节点数, 新增节点数) +2  !!! */</span></span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + <span class="built_in">max</span>(_M_map_size, __nodes_to_add) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拷贝原map节点数据到新map中央 */</span></span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);</span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / <span class="number">2</span></span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    copy(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size); <span class="comment">/* 释放原map空间 */</span></span><br><span class="line">    </span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/* 设置新的map的start、finish迭代器 */</span></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="deque迭代器"><a href="#deque迭代器" class="headerlink" title="deque迭代器"></a>deque迭代器</h2><ul>
<li>指向连续空间</li>
<li>能判断空间边界，在边界上移动能指向正确的下一个连线空间</li>
<li>随机存取</li>
</ul>
<p><strong>_Deque_iterator</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Tp* _M_cur;        <span class="comment">//此迭代器所指的缓冲区的当前元素位置</span></span><br><span class="line">_Tp* _M_first;        <span class="comment">//此迭代器所指的缓冲区的头</span></span><br><span class="line">_Tp* _M_last;        <span class="comment">//此迭代器所指的缓冲区的尾</span></span><br><span class="line">_Map_pointer _M_node;    <span class="comment">//指向管控中心 map</span></span><br></pre></td></tr></table></figure>

<h2 id="deque插入数据"><a href="#deque插入数据" class="headerlink" title="deque插入数据"></a>deque插入数据</h2><ol>
<li><p>若头部插入：<code>push_front</code></p>
</li>
<li><p>若尾部插入： <code>push_back</code></p>
</li>
<li><p>中间位置插入：</p>
<p>1）判断距离哪端近</p>
<p>2）移动元素</p>
<p>3）插入新元素</p>
</li>
</ol>
<h2 id="deque基本操作"><a href="#deque基本操作" class="headerlink" title="deque基本操作"></a>deque基本操作</h2><p><code>push_back()</code>：尾端插入</p>
<p><code>push_front()</code>：头端插入</p>
<p><code>pop_back()</code>：尾端取出</p>
<p><code>pop_front()</code>：头端取出</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-list</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-list/</url>
    <content><![CDATA[<p>STL list 容器，又称<strong>双向链表容器</strong>，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p>
<p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速<strong>插入</strong>或<strong>删除</strong>元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p>
<p>查找元素需要遍历容器链表，时间复杂度为<code>O(n)</code>。</p>
<h1 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h1><p>增加一个”哨兵“，便能符合STL对于”前闭后开“区间的要求。</p>
<img src="https://i.loli.net/2020/08/04/vMCmnAWwHZXK39Y.png" alt="list-双向环形链表.png" style="zoom:67%;" />

<h1 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h1><p>由于STL list是一个<strong>双向环形链表</strong>，迭代器必须具备前移、后移的能力，所以list提供的是 <code>Bidirectional Iterators</code> 。</p>
<p>list一重要性质：插入（insert）和拼接（splice）都<strong>不会</strong>造成原有的list迭代器失效（区别于vector）。</p>
<p>list迭代器部分设计：</p>
<p> <strong><em>因前 <code>++</code> （或前 <code>--</code> ）返回值为引用，故允许：<code>++++i</code> 、 <code>----i</code> ；</em></strong></p>
<p><strong><em>后 <code>++</code> (或 <code>--</code> )则不允许这样</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对迭代器累计+1 也就是前进一个结点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;     <span class="comment">// 前++ (++i) 无参数</span></span><br><span class="line">    node = (link_type)(node-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   <span class="comment">// 后++ (i++) 有参数，参数无意义</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//对迭代器累计-1 也就是前进一个结点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    node = (link_type)(node-&gt;prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="list数据结构"><a href="#list数据结构" class="headerlink" title="list数据结构"></a>list数据结构</h1><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>返回一个引用，指向最后一个元素</td>
</tr>
<tr>
<td>begin()</td>
<td>返回指向第一个元素的迭代器</td>
</tr>
<tr>
<td>clear()</td>
<td>删除所有元素</td>
</tr>
<tr>
<td>empty()</td>
<td>如果list是空的则返回true</td>
</tr>
<tr>
<td>end()</td>
<td>返回末尾的迭代器</td>
</tr>
<tr>
<td>erase()</td>
<td>删除以pos指示位置的元素, 或者删除<em>start</em>和<em>end</em>之间的元素。 返回值是一个迭代器，指向最后一个被删除元素的下一个元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回一个引用，指向第一个元素</td>
</tr>
<tr>
<td><strong>insert()</strong></td>
<td>插入元素val到位置pos，返回值是一个迭代器，指向被插入的元素。 或者插入num个元素val到pos之前。或者插入start到end之间的元素到pos的位置。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个list（合并到this上，必须先经过<strong>递增排序</strong>）</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除最后一个元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除第一个元素</td>
</tr>
<tr>
<td>push_back()</td>
<td>在list的末尾添加一个元素</td>
</tr>
<tr>
<td>push_front()</td>
<td>在list的头部添加一个元素</td>
</tr>
<tr>
<td>remove()</td>
<td>从list删除所有值为val的元素</td>
</tr>
<tr>
<td>remove_if()</td>
<td>按指定条件删除元素</td>
</tr>
<tr>
<td>resize()</td>
<td>改变list的大小</td>
</tr>
<tr>
<td>reverse()</td>
<td>把list的元素倒转</td>
</tr>
<tr>
<td>size()</td>
<td>返回list中的元素个数</td>
</tr>
<tr>
<td><strong>sort()</strong></td>
<td>给list排序</td>
</tr>
<tr>
<td>splice()</td>
<td>合并两个list</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个list</td>
</tr>
<tr>
<td>unique()</td>
<td>删除list中<strong>数值相同的连续</strong>元素（保留连续的值相同的第一个元素）</td>
</tr>
</tbody></table>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><code>list</code> 不能使用 STL 算法 <code>sort()</code> ，必须使用自己的 <code>sort()</code> 。</p>
<p>因为STL算法sort()只能接受 <code>RamdonAccessIterator</code> 。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-stack-queue</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-stack-queue/</url>
    <content><![CDATA[<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack是一种先进后出(First In Last Out, <strong>FILO</strong>)的数据结构。只有一个出口。</p>
<p>SGI STL 默认是以<strong>deque</strong>作为缺省情况下的stack底层结构。也可以 <strong>list</strong> 作为 stack 的底层容器。</p>
<p>STL stack 往往不被归类为 container(容器)，而被归类为 <strong>container adapter</strong>。</p>
<p>stack所有的元素都必须符合“先进后出”的条件，只有从stack顶端对其进行新增、移除、读取操作，即stack<strong>不允许遍历</strong>行为，stack<strong>不提供迭代器</strong>。</p>
<img src="https://i.loli.net/2020/08/09/SLDxIahQRYBuc5y.jpg" alt="stack.jpg" style="zoom: 25%;" />

<p>stack基本操作：</p>
<p><code>push()</code>：顶部入栈</p>
<p><code>pop()</code>：顶部出栈</p>
<p><code>top()</code>：：指向栈顶</p>
<p><code>empty()</code>：判断栈空</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue是一种先进先出(First In First Out, FIFO)的数据结构。有两个出口，从最底端加入元素、最顶端取出元素。</p>
<p>SGI STL 默认是以 <strong>deque</strong> 作为缺省情况下的 queue 底部结构。也可以 <strong>list</strong> 作为 stack 的底层容器。</p>
<p>STL queue往往不被归类为 container(容器)，而被归类为 <strong>container adapter</strong>。</p>
<p>stack所有的元素都必须符合“先进先出”的条件，只有从queue尾端增加元素、头端取出元素。queue<strong>不允许遍历</strong>行为，queue<strong>不提供迭代器</strong>。</p>
<img src="https://i.loli.net/2020/08/09/jFngpJdNtEyoqAm.jpg" alt="queue.jpg" style="zoom:25%;" />

<p>queue基本操作：</p>
<p><code>push()</code>：尾端入队</p>
<p><code>pop()</code>：首端出队</p>
<p><code>front()</code>：返回队首</p>
<p><code>back()</code>：返回队尾</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-slist</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-slist/</url>
    <content><![CDATA[<p>STL list是一个双向链表（double linked list）。SGI STL提供了另一个单向链表（single linked list）也就是<code>slist</code>。</p>
<p><code>slist</code>与<code>list</code>差异：</p>
<ol>
<li>slist迭代器是单向的Forward Iterator，list迭代器是双向的Bidirectional Iterator。（slist迭代器没有<code>--</code>操作，因为是单向的Forward Iterator）。</li>
<li>单向链表所耗空间更小。</li>
<li>list是<strong>双向环形</strong>链表，slist是<strong>单向</strong>链表。</li>
<li>slist不提供push_back()，仅提供**push_front()**（头插法）。</li>
</ol>
<p><code>slist</code>与<code>list</code>相同点：</p>
<ol>
<li>都具有“头节点”，且都不放置元素数据。</li>
<li>进行插入、删除、接合等操作，均不会导致原迭代器失效（当然，指向被移除的那个节点的迭代器肯定会失效）。</li>
<li><code>list</code>和<code>slist</code>都不能使用 STL 算法 <code>sort()</code> ，必须使用自己的 <code>sort()</code> 。</li>
</ol>
<p>slist基本操作：</p>
<p><code>push_front()</code>：从头部插入元素</p>
<p><code>pop_front()</code>：从头部取出元素</p>
<p><code>front()</code>：取头部元素</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器-vector</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8-vector/</url>
    <content><![CDATA[<p>vector 常被称为向量容器，因为该容器擅长在<strong>尾部</strong>插入或删除元素，在常量时间内就可以完成，时间复杂度为<code>O(1)</code>；而对于在容器<strong>头部或者中部</strong>插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶<code>O(n)</code>。</p>
<p>vector实现的关键在于其对<strong>大小的控制</strong>以及<strong>重新配置时的数据移动效率</strong>。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>vector 与 array 唯一区别是空间的运用的灵活性。<ul>
<li>array 是<strong>静态空间</strong>，一旦配置了就不能改变。</li>
<li>vector是<strong>动态空间</strong>。</li>
</ul>
</li>
<li>vector 维护的是一个<strong>连续线性空间</strong>，所以不论其元素类型为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。</li>
<li>增加新元素时，如果超过当时的容量，则容量会扩大至<strong>两倍</strong>。</li>
</ul>
<img src="https://i.loli.net/2020/08/07/5KPtrc42gBWpMnz.png" alt="vector-两倍增长示意图.png" style="zoom:67%;" />

<ul>
<li><p>所谓动态增加大小，并不是在原空间之后接续新空间(因为无法保证原空间之后尚有可供配置的空间)，而是以原空间的两倍大小另外配置一块较大空间，然后将原内容拷贝过来并插入新元素，释放原空间，最后更新迭代器！！！</p>
</li>
<li><p>一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p>
</li>
<li><p><code>at()</code> 函数 比 <code>[]</code> 运算符更加安全, 因为它不会让你去访问到Vector内越界的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_THROW_RANGE_ERRORS</span></span><br><span class="line">  <span class="keyword">void</span> _M_range_check(size_type __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt;= <span class="keyword">this</span>-&gt;<span class="built_in">size</span>())</span><br><span class="line">      __stl_throw_range_error(<span class="string">&quot;vector&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">reference <span class="title">at</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; _M_range_check(__n); <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">at</span><span class="params">(size_type __n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; _M_range_check(__n); <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_THROW_RANGE_ERRORS */</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="vector动态增加容量原理-M-insert-aux"><a href="#vector动态增加容量原理-M-insert-aux" class="headerlink" title="vector动态增加容量原理_M_insert_aux"></a>vector动态增加容量原理_M_insert_aux</h2><p><strong>过程分析：</strong></p>
<blockquote>
<ol>
<li><p>配置一块更大空间（2倍，初始为0则配置新的空间大小为1）</p>
</li>
<li><p>拷贝原数据并插入新元素</p>
<p>1）拷贝插入位置前的数据</p>
<p>2）在插入位置插入新元素</p>
<p>3）拷贝插入位置后的数据</p>
</li>
<li><p>释放原空间</p>
</li>
<li><p>更新迭代器！！！</p>
</li>
</ol>
</blockquote>
<p>源码参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp, _Alloc&gt;:</span>:_M_insert_aux(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line">&#123; <span class="comment">/* 判断是否有备用空间 */</span></span><br><span class="line">  <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">    construct(_M_finish, *(_M_finish - <span class="number">1</span>));</span><br><span class="line">    ++_M_finish;</span><br><span class="line">    _Tp __x_copy = __x;</span><br><span class="line">    copy_backward(__position, _M_finish - <span class="number">2</span>, _M_finish - <span class="number">1</span>);</span><br><span class="line">    *__position = __x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">/* 扩容两倍。 注意：初始时为0，扩容后为1 */</span></span><br><span class="line">    <span class="keyword">const</span> size_type __len = __old_size != <span class="number">0</span> ? <span class="number">2</span> * __old_size : <span class="number">1</span>;</span><br><span class="line">    iterator __new_start = _M_allocate(__len); <span class="comment">/*分配新的连续空间*/</span></span><br><span class="line">    iterator __new_finish = __new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="comment">/* 拷贝插入位置前的数据到新空间 [old_start, position) --&gt; [new_start, position) */</span></span><br><span class="line">      __new_finish = uninitialized_copy(_M_start, __position, __new_start);</span><br><span class="line">      <span class="comment">/* 插入新元素 position */</span></span><br><span class="line">      construct(__new_finish, __x);</span><br><span class="line">      ++__new_finish;</span><br><span class="line">      <span class="comment">/* 拷贝插入位置后的数据到新空间 [position, finish) -- [position+1, new_finish) */</span></span><br><span class="line">      __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 释放原空间 */</span></span><br><span class="line">    __STL_UNWIND((destroy(__new_start,__new_finish), </span><br><span class="line">                  _M_deallocate(__new_start,__len)));</span><br><span class="line">    destroy(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    <span class="comment">/* 更新迭代器 */</span></span><br><span class="line">    _M_start = __new_start;</span><br><span class="line">    _M_finish = __new_finish;</span><br><span class="line">    _M_end_of_storage = __new_start + __len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector基本操作"><a href="#vector基本操作" class="headerlink" title="vector基本操作"></a>vector基本操作</h2><p><code>push_back()</code>：插入操作(末尾)</p>
<p><code>pop_back()</code>：删除操作(末尾)</p>
<p><code>erase()</code>：清除某范围 <code>[first, last)</code> 元素，或删除某个位置上的元素</p>
<p><code>insert()</code>：从某个位置，插入 n 个元素，元素初值为x</p>
<p><code>clear()</code>：清除所有元素</p>
<p><code>begin()</code>：返回第一个元素的迭代器</p>
<p><code>end()</code>：返回最末元素的迭代器(译注:实指向最末元素的下一个位置)</p>
<p>注意：</p>
<p><code>reserve(size_type __n)</code>：配置vector容量为<code>__n</code>，如果 vector 的容量已经大于或等于<code>__n</code>个元素，那么什么也不做；调用 reserve() 不会影响已存储的元素，也不会生成任何元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;&amp; __x);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(size_type __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (capacity() &lt; __n) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">    iterator __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);</span><br><span class="line">    destroy(_M_start, _M_finish);</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    _M_start = __tmp;</span><br><span class="line">    _M_finish = __tmp + __old_size;</span><br><span class="line">    _M_end_of_storage = _M_start + __n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-迭代器-iterators</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8-iterators/</url>
    <content><![CDATA[<p>迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL中迭代器一个最重要的作用就是作为容器(vector,list等)与STL算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。</p>
<p>从实现的角度来看，迭代器是一种将 <code>operator*</code>，<code>operator-&gt;</code>，<code>operator++</code>，<code>operator--</code> 等指针相关操作予以重载的 class template。 所有 STL 容器都附带有自己专属的迭代器。 native pointer 也是一种迭代器。</p>
<p>为什么每一种 STL 容器都提供有专属迭代器？主要是暴露太多细节，所以把迭代器的开发工作交给容器去完成，这样所有实现细节可以得到封装，不被使用者看到。</p>
<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><img src="https://i.loli.net/2020/08/10/MQOyeBwmSgTt8j9.png" alt="iteratortraits.png" style="zoom: 80%;" />

<h2 id="迭代器所指对象类型-associated-types"><a href="#迭代器所指对象类型-associated-types" class="headerlink" title="迭代器所指对象类型(associated types)"></a>迭代器所指对象类型(associated types)</h2><p>迭代器所指的对象类型有五种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tempalte&lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category  iterator_category;    <span class="comment">//迭代器的分类</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type  value_type;                 <span class="comment">//迭代器所指对象的型别</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type  difference_type;        <span class="comment">//两迭代器之间的距离</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer  pointer;                        <span class="comment">//指针，指向迭代器所指之物</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference  reference;                    <span class="comment">//类似引用类型，允许改变“所指对象的值”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h2><ol>
<li>Input Iterator ：能从所指向元素读取的迭代器（<strong>只读</strong>）。仅保证单趟算法的合法性。</li>
<li>Output Iterator ：能写入所指元素的迭代器（<strong>只写</strong>）。</li>
<li>Forward Iterator ：一种能从所指向元素读取数据的迭代器 。</li>
<li>Bidirectional Iterator：能<strong>双向移动</strong>（即自增与自减）的迭代器 。</li>
<li>Random Access Iterator ：<strong>随机读写</strong>，能在常数时间内移动到指向任何元素的双向迭代器。</li>
</ol>
<img src="https://i.loli.net/2020/08/10/NBfOK4GX572eFYL.png" alt="迭代器的分类于从属关系.png" style="zoom:67%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>traits 本质是什么？多一层间接性，换来灵活性。</p>
<p>iterator_traits 负责萃取迭代器的特性，__type_traits 负责萃取类型的特性。</p>
<p>STL的中心思想是将数据容器与算法分开，彼此独立设计。迭代器便作为连接两者的“桥梁”，统一访问不同容器时的访问方式，并将实际细节封装，不被使用者看到。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析-容器priority_queue-heap(算法)</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AE%B9%E5%99%A8priority_queue-heap(%E7%AE%97%E6%B3%95)/</url>
    <content><![CDATA[<img src="https://i.loli.net/2020/08/09/KF12cDuCQVkaYmT.png" alt="完全二叉树即其array表述式.png" style="zoom: 67%;" />

<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>heap的实现就是数据结构中的<strong>堆</strong>（大顶堆、小顶堆）。STL提供<code>max-heap</code>。</p>
<p>STL中并没有把<code>heap</code>作为一种容器组件，heap的实现亦需要更低一层的容器组件，诸如list，array，vector。heap并不属于STL容器，但它是其中一个容器<code>priority queue</code>必不可少的一部分。</p>
<p><strong>heap没有迭代器，</strong>heap的所有元素都必须遵循特别的排列规则，所以heap不提供遍历功能，也不提供迭代器。</p>
<h3 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h3><blockquote>
<ol>
<li><p>最新加入的源放在最下层叶子节点，填补从左至右第一个空闲单元</p>
</li>
<li><p>percolate up（上溯）：与父节点比较，调整位置</p>
<blockquote>
<p>将新节点与父节点比较，如果其键值比父节点大，就交换父子的位置，如此一直上溯，直到不需要交换或者到根节点为止。</p>
</blockquote>
</li>
</ol>
</blockquote>
<img src="https://i.loli.net/2020/08/09/5Dz7RYnrlGKIkmc.png" alt="push_heap演示.png" style="zoom: 67%;" />

<h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h3><blockquote>
<ol>
<li><p>把原尾端节点的值拿出来放至一临时变量里，然后该位置放根节点的值（最后会被pop_back()给移除）</p>
</li>
<li><p>重新构建大顶堆，实施如下调整堆：</p>
<p>1）<strong>percolate down</strong>（下溯）：从根节点开始将空洞节点（一开始是根节点）和较大子节点交换，并持续向下进行，直到到达叶节点为止。然后将已保存的原容器vector尾端节点赋给这个已到达叶层的空洞节点。</p>
<p>2）此时可能尚未满足次序特性，再执行一次<strong>percolate up</strong>（上溯）操作</p>
</li>
</ol>
</blockquote>
<p><strong><em>注意：pop_heap之后，最大元素只是被放置于底部容器的最尾端，尚未被取走。如果要取其值，可使用底部容器的back()函数。如果要移除它，可使用底部容器所提供的pop_back()函数。</em></strong></p>
<img src="https://i.loli.net/2020/08/09/PXJQOjWxi9Scezq.png" alt="pop_heap演示.png" style="zoom: 67%;" />

<h3 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h3><p><strong>堆排序算法</strong>。执行此操作之后，容器vector中的元素按照从小到大的顺序排列。</p>
<img src="https://i.loli.net/2020/08/09/fnZlGrWJxibYPo2.png" alt="sort_heap演示.png" style="zoom:67%;" />

<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>构建堆实质是一个不断调整堆的过程—通过不断调整子树，使得子树满足堆的特性来使得整个树满足堆的性质。</p>
<p>第一个需要执行调整操作的子树的根节点是从后往前的第一个非叶结点。从此节点往前到根节点对每个子树执行调整操作，即可构建堆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个 heap。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">make_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    __make_heap(first, last, value_type(first), distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">make_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">    <span class="title">Distance</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; ) <span class="keyword">return</span>; <span class="comment">// 如果長度為 0 或 1，不必重新排列。</span></span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以 parent 标示出。由于任何叶子节点都不需执行</span></span><br><span class="line">        <span class="comment">// perlocate down（下沉），所以有以下计算。</span></span><br><span class="line">        Distance parent = (len - ) / ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len 是为了让 __adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, T(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == ) <span class="keyword">return</span>; <span class="comment">// 直至根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// 未到根节点，就将（即将重排的子树的）索引值向前一個节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><code>priority_queue</code> 是一个拥有权值观念的 queue。</p>
<p>默认情况下以 <code>vector</code> 为底部容器完成其所有工作，再加上 <code>heap</code> 处理规则。</p>
<p>priority_queue的所有元素，都不一定的进程出规则，只有queue顶端的元素（权值最高）才有机会被外界取用。故<code>priority_queue</code>不提供遍历功能，也不提供迭代器。</p>
<p>priority_queue 基本操作：</p>
<p><code>priority_queue()</code>：调用 <code>make_heap()</code>， 使进入的元素后，始终保持一个堆。</p>
<p><code>top()</code>：队顶元素。</p>
<p><code>push()</code>：<code>push_back()</code>尾端插入元素，然后调用 <code>push_heap()</code> 重排堆。</p>
<p><code>pop()</code>：用 <code>pop_heap() </code>将最大元素放到底部容器的最尾端，<strong>并不是真正弹出</strong>，再调用底部容器 vector 所提供的 <code>pop_back()</code> 弹出元素。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.shuzhiduo.com/A/E35pRNwRzv/">STL源码剖析——序列式容器#5 heap</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型中的同步&amp;异步-阻塞&amp;非阻塞</title>
    <url>/UNP/IO%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5&amp;%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E&amp;%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<p>I/O模型中：</p>
<ul>
<li><p><strong>同步&amp;异步</strong>：同步和异步关注的是<strong>消息通信机制</strong>。</p>
</li>
<li><p><strong>阻塞&amp;非阻塞</strong>：阻塞和非阻塞关注的是程序在<strong>等待调用结果时的状态</strong>。</p>
</li>
</ul>
<blockquote>
<p>张三爱喝茶，烧水泡茶。</p>
<ol>
<li>张三把水壶放火上，立等水开。（同步阻塞）</li>
<li>张三把水壶放火上，去客厅看电视，时不时去厨房看水开没有。（同步非阻塞）</li>
</ol>
<p>张三买了个智能水壶，烧开后铃声提示。</p>
<ol>
<li>张三把智能水壶放火上，立等水开。（异步阻塞）</li>
<li>张三把智能水壶放火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</li>
</ol>
<p><strong>同步&amp;异步</strong>，只是对<strong>水壶（被调用）</strong>而言。普通水壶——同步。智能水壶——异步。智能水壶能自己干完活后提示张三水开了，普通水壶智能让张三去轮询查看（造成张三效率低下）。</p>
<p><strong>阻塞&amp;非阻塞</strong>，仅仅对于<strong>老张（调用者）</strong>而言。 立等的张三——阻塞；看电视的张三——非阻塞。 </p>
<p>一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<p>从理论上说，<font color=red><strong>阻塞I/O</strong>、<strong>I/O复用</strong>以及<strong>信号驱动I/O</strong>都是<strong>同步I/O模型</strong></font>。</p>
<p><strong>异步I/O</strong>的读写操作总是<strong>立即返回</strong>，而不论I/O是否是阻塞的，因为真正读写操作已经由内核接管。</p>
<p><strong>同步I/O模型</strong>要求用户代码自行执行I/O操作，而<strong>异步I/O机制</strong>由内核来执行I/O操作。即，<strong>同步I/O</strong>向应用程序通知的是I/O就绪事件，异步I/O向应用程序通知的是<strong>I/O完成事件</strong>。</p>
<hr>
<table>
<thead>
<tr>
<th>I/O模型</th>
<th>读写操作和阻塞阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞I/O</td>
<td>程序阻塞与读写函数</td>
</tr>
<tr>
<td>I/O复用</td>
<td>程序阻塞于I/O复用系统调用，但可以同时监听多个I/O事件，对于I/O本身的读写操作是非阻塞的。</td>
</tr>
<tr>
<td>SIGIO信号</td>
<td>信号触发I/O就绪事件，用户程序执行读写操作。程序没有阻塞阶段。</td>
</tr>
<tr>
<td>异步I/O</td>
<td>内核执行读写操作并触发I/O完成事件。程序没有阻塞阶段。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析概述</title>
    <url>/STL/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>源代码：SGI-STL V3.3</strong></p>
</blockquote>
<p><em>注：SGI STL并不是原封不动的被用于GCC，所以在GCC中使用STL可能会和SGI STL有一些微小的区别</em></p>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ul>
<li>容器 – <strong>containers</strong></li>
<li>配置器 – <strong>allocators</strong></li>
<li>算法 – <strong>algorithms</strong></li>
<li>迭代器 – <strong>iterators</strong></li>
<li>适配器 – <strong>adaptors</strong></li>
<li>仿函数 – <strong>functors</strong></li>
</ul>
<h3 id="STL六大组件关系"><a href="#STL六大组件关系" class="headerlink" title="STL六大组件关系"></a>STL六大组件关系</h3><img src="https://i.loli.net/2020/08/04/8O6uUKpjax4o7RP.png" alt="STL六大组件.png" style="zoom: 67%;" />

<h3 id="STL部分组件包含关系"><a href="#STL部分组件包含关系" class="headerlink" title="STL部分组件包含关系"></a>STL部分组件包含关系</h3><img src="https://i.loli.net/2020/08/04/aMjYyL1ktgQx8JN.jpg" alt="STL部分组件包含关系.jpg" style="zoom: 67%;" />

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><img src="https://i.loli.net/2020/08/04/l5AoyGxt6RpfSJ9.png" alt="STL容器结构与分类图.png" style="zoom:67%;" />

<h2 id="GCC-编译器版本"><a href="#GCC-编译器版本" class="headerlink" title="GCC 编译器版本"></a>GCC 编译器版本</h2><p>Ubuntu 16.04下gcc version <kbd>5.4.0</kbd>，源码在目录<kbd>/usr/include/c++/5.4.0/bits</kbd>下 stl_xxxx</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《STL 源码剖析》 侯捷</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>基本TCP套接字</title>
    <url>/UNP/%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<p>#include &lt;sys/types.h&gt;          /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
</blockquote>
<img src="https://i.loli.net/2020/10/23/tngDJxl8XPbZmRO.png" alt="基本TCP客户-服务器程序套接字函数.png" style="zoom:67%;" />

<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><blockquote>
<p>创建一个套接字，指定通信协议类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回文件描述符    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>domain</code> ：协议族</p>
<p><code>AF_INET</code>、<code>AF_INET6</code>、AF_LOCAL、AF_ROUTE、AF_KEY</p>
<p><code>AF_XXX</code> 指<strong>地址族</strong>，<code>PF_XXX</code> 指协议族。但是在实际中，支持多个地址族的协议族从来没有实现过，且&lt;sys/socket.h&gt;中 PF_ 值总是与对应的 AF_ 值相等，因此，<strong>两者值相等，现在可看成是一个意思</strong>。</p>
</li>
<li><p><code>type</code> ：套接字类型</p>
<p><code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、SOCK_SEQPACKET、SOCK_RAW </p>
</li>
<li><p><code>protocol</code> ：某协议类型的常值，通常为0</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/10/23/2XiDWoOtZMe1rLk.png" alt="domain-type组合.png"></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote>
<p>把一个本地<strong>协议地址</strong>赋予一个套接字。</p>
<p>协议地址：<strong>ip地址 + port</strong> </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno（常见：EACCES、EADDRINUSE）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">   <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">   <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sockfd</code> ：文件描述符（套接字）</li>
<li><code>addr</code>：指向特定协议的<strong>地址结构</strong>的指针</li>
<li><code>addrlen</code> ：地址结构长度</li>
</ul>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><blockquote>
<p>做两件事：</p>
<ol>
<li>把一个未连接的<strong>主动套接字</strong>转换成<strong>被动套接字</strong>，指示内核接收指向该套接字的连接请求，<strong>CLOSED状态</strong> –&gt; <strong>LISTEN状态</strong> </li>
<li>backlog规定<strong>已完成连接队列</strong>的最大连接个数</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li><strong>未完成连接队列</strong>：正在等待完成TCP三次握手，处于 <strong>SYN_RCVD</strong> 状态</li>
<li><strong>已完成连接队列</strong>：已完成TCP三次握手，等待通过 <code>accept</code> 从队列中取出已连接套接字，处于 <strong>ESTABLISED</strong> 状态</li>
</ul>
<p>Linux 2.2 以后，backlog 表示已完成连接队列的 socket 上限。<strong>实际测试</strong>中，队列最大长度为 <font color=red><strong>backlog + 1</strong></font>。</p>
<p><strong>测试代码及数据</strong>：<a href="https://github.com/JakeLin0fly/unp-code/tree/master/listen_backlog">listen()函数backlog参数测试</a> </p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><blockquote>
<p>TCP客户端使用，用于建立与TCP服务器的连接</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><blockquote>
<p>有TCP服务器调用，从<strong>已完成连接队列</strong>队头返回一个描述符。若队列为空，进程睡眠（默认阻塞方式）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回非负描述符    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若对返回客户端协议地址不感兴趣，可把 addr、addrlen 均值为空指针。</p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><blockquote>
<p>关闭套接字，该套接字不能再被调用进程使用。并发服务器中，close调用实际是相应套接字引用计数减1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功：返回0    失败：返回-1，设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当close关闭套接字时，TCP将尝试发送<strong>已排队等待发送</strong>到对端的任何数据，发送完毕后的是正常的TCP连接终止序列（四次握手）。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>unp</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式(一)管道</title>
    <url>/UNP/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F(%E4%B8%80)%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p>Linux环境下，<strong>进程地址空间相互独立</strong>，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过<strong>内核</strong>，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong>（<strong>IPC</strong>，InterProcess Communication）。</p>
<h2 id="管道-pipe-（半双工）"><a href="#管道-pipe-（半双工）" class="headerlink" title="管道 pipe （半双工）"></a>管道 pipe （半双工）</h2><p>管道 （<code>pipe</code>）是一种最基本的IPC机制，作用于<strong>有血缘关系</strong>的进程之间，完成数据传递。</p>
<img src="https://i.loli.net/2020/08/16/BPgd7qliosW94VM.png" alt="pipe管道-进程通信.png" style="zoom:67%;" />

<h3 id="管道特质"><a href="#管道特质" class="headerlink" title="管道特质"></a>管道特质</h3><ol>
<li>其本质是一个<strong>伪文件</strong>（实为内核缓冲区）</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>规定数据从管道的写端流入管道，从读端流出</li>
</ol>
<h3 id="pipe的原理"><a href="#pipe的原理" class="headerlink" title="pipe的原理"></a>pipe的原理</h3><p>管道实为内核使用<strong>环形队列</strong>机制，借助内核缓冲区(4k)实现。</p>
<h3 id="pipe的局限性"><a href="#pipe的局限性" class="headerlink" title="pipe的局限性"></a>pipe的局限性</h3><p>​    ① 管道采用<strong>半双工</strong>通信方式。即数据只能在一个方向上流动。</p>
<p>​    ② 只能在有<strong>公共祖先</strong>的进程间使用管道。</p>
<p>​    ③ 数据一旦被读走，便不在管道中存在，<strong>不可反复读取</strong>。</p>
<p>​    <del>④ 数据自己读不能自己写。</del></p>
<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><p>从管道中<strong>「读数据」</strong>：</p>
<ol>
<li><p>管道中<strong>有数据</strong>：</p>
<p>read返回实际读到的字节数。</p>
</li>
<li><p>管道中<strong>无数据</strong>：</p>
<p>(1) 管道<strong>写端全部关闭</strong>（管道写端引用计数为0），read返回0 (就像读到文件结尾)。</p>
<p>(2)  管道写端<strong>没</strong>有<strong>全部关闭</strong>，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)。</p>
</li>
</ol>
<p>往管道<strong>「写数据」</strong>：</p>
<ol>
<li><p>管道<strong>读端全部关闭</strong>：</p>
<p>进程异常终止（也可使用捕捉 <strong>SIGPIPE</strong> 信号，使进程不终止，errno设置为EPIPE）。</p>
</li>
<li><p>管道读端<strong>没有全部关闭</strong>：</p>
<p>(1) 管道已满，write阻塞。</p>
<p>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</p>
</li>
</ol>
<h3 id="pipe程序示例"><a href="#pipe程序示例" class="headerlink" title="pipe程序示例"></a>pipe程序示例</h3><p>【实际步骤】</p>
<blockquote>
<p>「父进程」向「子进程」发送消息：</p>
<ol>
<li>创建管道；</li>
<li>fork；</li>
<li>父进程关闭读端 fd[0] ，子进程关闭写端 fd[1] ；</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 创建 pipe</span></span><br><span class="line">  ret = pipe(fd);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pipe create error: &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. fork</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == (pid = fork())) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error: &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 父进程关闭读端 fd[0] ，子进程关闭写端 fd[1] </span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程写管道</span></span><br><span class="line">    close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 父进程sleep，管道无数据且写端未全部关闭，子进程阻塞等待</span></span><br><span class="line">    write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str)); <span class="comment">// 写入数据</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    close(fd[<span class="number">1</span>]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123; <span class="comment">// 子进程读管道</span></span><br><span class="line">    close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">    ret =read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;  <span class="comment">// 读数据</span></span><br><span class="line">      perror(<span class="string">&quot;read error: &quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(STDOUT_FILENO, buf, ret); <span class="comment">// 输出到屏幕</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO指*<em>先进先出**</em>（first in，first out），常被称为<strong>有名管道</strong>（named pipe），以区分管道(pipe)。管道(pipe)只能用于 「有血缘关系」的进程间。<strong>使用 FIFO，不相关的进程也能交换数据</strong>。</p>
<p>FIFO是<strong>Linux基础文件类型</strong>中的一种。但，<strong>FIFO文件在磁盘上没有数据块</strong>，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行<code>read/write</code>，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">// 默认 O_CREAT | O_EXCL</span></span><br></pre></td></tr></table></figure>



<h3 id="FIFO读写性质"><a href="#FIFO读写性质" class="headerlink" title="FIFO读写性质"></a>FIFO读写性质</h3><p><strong>只有读写都存在时，才能打开FIFO</strong>。及以下情况：</p>
<ol>
<li>有进程以只写方式打开，且有进程以只读方式打开；</li>
<li>以读写方式打开。</li>
</ol>
<p>由下面程序可验证:</p>
<ul>
<li><strong>当没有写进程打开 FIFO 时读进程打开 FIFO 将阻塞</strong>；</li>
<li><strong>当所有读进程结束后，写进程将终止</strong>。</li>
</ul>
<h3 id="FIFO程序示例"><a href="#FIFO程序示例" class="headerlink" title="FIFO程序示例"></a>FIFO程序示例</h3><p>【<strong>写进程</strong>实际步骤】</p>
<blockquote>
<ol>
<li>创建 FIFO （已存在则跳过）；</li>
<li>以只写方式打开 FIFO；</li>
<li>写数据；</li>
<li>关闭 FIFO 写。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter like this: ./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 创建 FIFO （已存在则跳过）</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(argv[<span class="number">1</span>], S_IRUSR | S_IWUSR) &amp;&amp; errno != EEXIST)</span><br><span class="line">        sys_err(<span class="string">&quot;caon&#x27;t create FIFO&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 以只写方式打开 FIFO</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 写数据</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello FIFO %d\n&quot;</span>, i++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭 FIFO</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【<strong>读进程</strong>实际步骤】</p>
<blockquote>
<ol>
<li>创建 FIFO （已存在则跳过）；</li>
<li>以只读方式打开 FIFO；</li>
<li>读数据；</li>
<li>关闭 FIFO 读。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out fifoname\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 创建 FIFO （已存在则跳过）</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(argv[<span class="number">1</span>], S_IRUSR | S_IWUSR) &amp;&amp; errno != EEXIST)</span><br><span class="line">        sys_err(<span class="string">&quot;caon&#x27;t create FIFO&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 以只读方式打开 FIFO</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 读数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">        sleep(<span class="number">3</span>);           <span class="comment">//多个读端时应增加睡眠秒数,放大效果.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 关闭 FIFO 读</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管道和FIFO的额外属性"><a href="#管道和FIFO的额外属性" class="headerlink" title="管道和FIFO的额外属性"></a>管道和FIFO的额外属性</h2><ul>
<li><strong>O_NONBLOCK</strong> 标志对管道和FIFO的影响</li>
</ul>
<p><img src="https://i.loli.net/2020/08/19/OwERLep16s9Kgqa.png" alt="O_NONBLOCK标志对管道和FIFO的影响.png"></p>
<ul>
<li><strong>原子性</strong> 完全由所请求字节是否小于等于 <code>PIPE_BUF</code> 。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《UNIX环境高级编程：第3版》</p>
<p>《UNIX网络编程：第2卷 进程间通信》</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>unp</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>高效事件处理模式--Proactor模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F--Proactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>同步I/O模型</strong>通常用于实现<strong>Reactor模式</strong>，<strong>异步I/O模型</strong>则用于实现<strong>Proactor模式</strong>。</p>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>与 Reactor 模式不同，Proactor 模式将所有 <strong>I/O 操作</strong>都交给<strong>主线程</strong>和<strong>内核</strong>来处理， <strong>工作线程</strong>仅仅负责<strong>业务逻辑</strong>。</p>
<ul>
<li><strong>主线程</strong>：负责<strong>监听已连接文件描述符</strong>上是否有事件发生。</li>
<li><strong>内核</strong>：负责处理<strong>I/O读写</strong>操作。</li>
<li><strong>工作线程</strong>：仅负责<strong>业务逻辑</strong>。</li>
</ul>
<img src="https://i.loli.net/2020/12/17/BHf5AtxvRQsWUV1.png" alt="Proactor模式.png" style="zoom:67%;" />

<p>使用异步 I/O 模型（以 aio_read 和 aio_write为例）实现的 Proactor 模式的工作流程是：</p>
<ol>
<li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以 通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li>
</ol>
<p>主线程中的 epoll_wait 调用<strong>仅能用来检测监听（已连接）socket</strong> 上的连接请求事件，而<strong>不能用来检测连接 socket</strong> 上的读写事件。</p>
<hr>
<p>参考：《Linux高性能服务器编程》 游双</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>高效事件处理模式--Reactor模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F--Reactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>同步I/O模型</strong>通常用于实现<strong>Reactor模式</strong>，<strong>异步I/O模型</strong>则用于实现<strong>Proactor模式</strong>。</p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><ul>
<li><strong>主线程（I/O处理单元）</strong>：只负责<strong>监听文件描述符</strong>上是否有事件发生，有的话以及将该事件通知工作线程。</li>
<li><strong>工作线程（逻辑单元）</strong>：<strong>读写数据</strong>，<strong>接受新的连接</strong>，<strong>处理用户请求</strong>均在工作线程中完成。</li>
</ul>
<img src="https://i.loli.net/2020/12/17/4QTMAk8369fYsDv.png" alt="Reactor模式.png" style="zoom:67%;" />

<p>使用同步 I/O 模型（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</p>
<ol>
<li>主线程往 epoll 内核事件表中注册 socket 上的<strong>读就绪事件</strong>。</li>
<li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li>
<li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的<strong>写就绪事件</strong>。</li>
<li>主线程调用 epoll_wait 等待 socket 可写。</li>
<li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作进程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li>
</ol>
<hr>
<p>参考：《Linux高性能服务器编程》 游双</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>高效并发模式--半同步/半异步模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F--%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>并发编程的目的是让程序“同时”执行多个任务。若程序是<strong>计算密集型</strong>的，并发编程并没有优势，相反由于任务的切换使得效率降低。但如果程序是<strong>I/O密集型</strong>的，比如经常读写文件，访问数据库等，则情况不同。由于I/O操作的速度远没有CPU计算的速度快，所以当程序阻塞于I/O操作将浪费大量CPU时间。</p>
<p>并发模式是指I/O处理单元和多个逻辑单元之间的协调完成任务的方法。</p>
<p><font color=red><strong>并发模式</strong>中，<strong>“同步”</strong>指的是程序完全按照代码序列的顺序执行；<strong>“异步”</strong>指的是程序的执行需要由系统事件来驱动。</font></p>
<p>以<strong>异步线程</strong>执行的程序相对复杂，难于调适和扩展，并且<strong>不适合于大量的并发</strong>。<strong>同步线程</strong>则相反，程序效率相对较低，实时性较差，但逻辑简单。</p>
<h3 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h3><p><strong>同步线程</strong>用于处理客户逻辑，相当于逻辑单元；<strong>异步线程</strong>用于处理I/O事件，相当于I/O处理单元。</p>
<img src="https://i.loli.net/2020/12/21/uP2neT3l7QIZaUF.png" alt="半同步半异步模式工作流程.png" style="zoom: 80%;" />

<h3 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步/半反应堆模式"></a>半同步/半反应堆模式</h3><blockquote>
<p><strong>half-sync / half-reactive</strong></p>
<p>事件处理模式是<strong>Reactor模式</strong>：要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。</p>
</blockquote>
<img src="https://i.loli.net/2020/12/21/gcyLzCZjOGFfid4.png" alt="半同步-半反应堆模式.png" style="zoom:80%;" />

<p><strong>主线程</strong>：<strong>异步</strong>线程。负责监听<strong>所有 socket</strong> 上的事件。</p>
<ul>
<li>当有新的连接请求到来，主线程接受连接请求得到新的连接socket，然后往epoll内核事件表中注册socket上的读写事件。</li>
<li>有新的已连接客户端请求到来或有数据要发送至客户端，主线程将该连接socket插入请求队列。</li>
</ul>
<p><strong>工作线程</strong>：<strong>同步</strong>线程。所有的工作线程都休眠在请求队列上，当有任务到来，它们通过竞争获得任务的接管权。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>主线程和工作线程共享请求队列：主线程添加任务，工作线程取出任务，都需要对请求队列加锁保护，耗费CPU时间。</li>
<li>每个工作线程在同一时间只能处理一个客户请求：若客户较多，工作线程较少，则请求队列中任务堆积，客户端响应慢。若增加工作线程，线程切换耗费大量CPU时间。</li>
</ul>
<h3 id="相对高效的半同步-半异步模式"><a href="#相对高效的半同步-半异步模式" class="headerlink" title="相对高效的半同步/半异步模式"></a>相对高效的半同步/半异步模式</h3><blockquote>
<p>每个线程都是<strong>异步线程</strong>，故并非严格意义上的半同步/半异步模式。</p>
</blockquote>
<img src="https://i.loli.net/2020/12/21/i6BpGWfeAcVD4YU.png" alt="高效的半同步-半异步模式.png" style="zoom:80%;" />

<p><strong>主线程</strong>：<strong>异步</strong>线程。<strong>只</strong>负责管理<strong>监听socket（listen_socket）</strong>。当有新的连接请求到来，主线程接受连接请求得到新的连接socket，并将新返回的连接socket派发给某个工作线程。</p>
<p><strong>工作线程</strong>：<strong>异步</strong>线程。负责管理<strong>请求socket（connected_socket）</strong>。主线程向工作线程派发新的连接socket后，工作线程负责该socket的任何I/O操作，直到客户端关闭。</p>
<hr>
<p>参考：《Linux高性能服务器编程》 游双</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>高效并发模式--领导者/追随者模式</title>
    <url>/UNP/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F--%E9%A2%86%E5%AF%BC%E8%80%85%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>并发模式是指I/O处理单元和多个逻辑单元之间的协调完成任务的方法。</p>
<p><font color=red><strong>并发模式</strong>中，<strong>“同步”</strong>指的是程序完全按照代码序列的顺序执行；<strong>“异步”</strong>指的是程序的执行需要由系统事件来驱动。</font></p>
<h3 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者/追随者模式"></a>领导者/追随者模式</h3><p>领导者/追随者模式是<strong>多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式</strong>。</p>
<p><strong>领导者线程</strong>：在任意时间点，程序都仅有一个领导者线程。负责监听I/O事件。</p>
<p><strong>追随者线程</strong>：当前时间点，除领导者线程之外的所有线程都是追随者，都休眠在线程池中等待成为新的领导者。</p>
<p>当前的领导者如果检测到I/O事件：</p>
<ol>
<li>从线程池中推线新的领导者；</li>
<li>旧的领导者去处理I/O事件；</li>
<li>新的领导者等待新的I/O事件。</li>
</ol>
<img src="https://i.loli.net/2020/12/22/5NeaoEdxAW4THrX.png" alt="领导者-追随者模式.png" style="zoom:80%;" />

<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><img src="https://i.loli.net/2020/12/22/JFtIr9V6qHRlj2E.png" alt="领导者-追随者模式的组件.png" style="zoom:80%;" />

<ul>
<li><p><strong>句柄集（HandleSet）</strong></p>
<p>句柄（Handle）用于表示<strong>I/O资源</strong>，Linux下通常是文件描述符。句柄集管理从多句柄。</p>
<ul>
<li><code>wait_for_event()</code>：监听句柄集中的所有句柄的I/O事件，并将就绪事件通知给领导者进程。</li>
<li><code>register_handle()</code>：绑定句柄和事件处理器。</li>
<li><code>unregister_handle()</code>：解绑句柄和事件处理器。</li>
</ul>
</li>
<li><p><strong>线程集（ThreadSet）</strong></p>
<p><strong>所有工作线程</strong>，包括领导者线程和追随者线程。线程集主要负责<strong>线程之间的同步</strong>，以及<strong>推选新的领导者</strong>。线程状态包括：</p>
<img src="https://i.loli.net/2020/12/22/erUN2d16DGFc9Tg.png" alt="领导者-追随者模式的状态转移.png" style="zoom: 80%;" />

<ul>
<li>Leader：领导者身份，等待句柄集上的I/O事件。当检测到新的I/O事件，可以推选新的领导者，本线程转为Processing处理事件，也可能指定其他追溯者来处理事件；</li>
<li>Processing：正在处理事件；</li>
<li>Follower：追随者身份，等待成为新的领导者，也可能被当前领导者指定来处理新的任务。</li>
</ul>
</li>
<li><p><strong>事件处理器（EventHandler）和具体事件处理器（ConcreteEventHandler）</strong></p>
<p>事件处理器通常包含一个或多个回调函数<code>handle_event</code>。这些回调函数用于处理事件对应的业务逻辑。</p>
</li>
</ul>
<h4 id="优势-amp-缺陷"><a href="#优势-amp-缺陷" class="headerlink" title="优势&amp;缺陷"></a>优势&amp;缺陷</h4><p>优势：</p>
<ol>
<li>不需要在线程之间传递任何额外的数据（领导者自己监听I/O事件并处理请求）；</li>
<li>线程之间无须同步队请求队列的访问（对比半同步/半反应堆模式）。</li>
</ol>
<p>缺陷：</p>
<ol>
<li>仅支持一个事件源集合</li>
<li>无法让每个工作线程独立地管理多个客户连接</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>unp</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos扩容</title>
    <url>/doc/Centos%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p>CVM存储在 <code>/var</code> 下，虽然固态硬盘大部分存储空间，都给了 <code>/var</code> ，但是虚拟机多一点，就担心空间不足。于是便通过以下步骤对 <code>/var</code> 进行扩容。</p>
<p>更新–查看磁盘分区情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lsblk</span><br><span class="line">NAME              MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0 447.1G  0 disk </span><br><span class="line">├─sda1              8:1    0    50M  0 part /boot/efi</span><br><span class="line">├─sda2              8:2    0     1G  0 part /boot</span><br><span class="line">└─sda3              8:3    0 446.1G  0 part </span><br><span class="line">  ├─centos00-root 253:0    0    80G  0 lvm  /</span><br><span class="line">  ├─centos00-swap 253:1    0    64G  0 lvm  [SWAP]</span><br><span class="line">  └─centos00-var  253:2    0 742.1G  0 lvm  /var</span><br><span class="line">sdb                 8:16   0 447.1G  0 disk </span><br><span class="line">└─centos00-var    253:2    0 742.1G  0 lvm  /var</span><br><span class="line">sdc                 8:32   0 447.1G  0 disk</span><br></pre></td></tr></table></figure>



<ol>
<li><p>查看分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -hT</span><br><span class="line">Filesystem              Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root xfs        40G  3.9G   37G  10% /</span><br><span class="line">devtmpfs                devtmpfs   12G     0   12G   0% /dev</span><br><span class="line">tmpfs                   tmpfs      12G     0   12G   0% /dev/shm</span><br><span class="line">tmpfs                   tmpfs      12G   33M   12G   1% /run</span><br><span class="line">tmpfs                   tmpfs      12G     0   12G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdc2               xfs       497M  155M  343M  32% /boot</span><br><span class="line">/dev/sdc1               vfat       50M   12M   39M  23% /boot/efi</span><br><span class="line">/dev/mapper/centos-var  xfs       375G  254G  121G  68% /var  # 大小 375G</span><br><span class="line">tmpfs                   tmpfs     2.4G     0  2.4G   0% /run/user/0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看磁盘编号</p>
<p>也可以使用 <code>fdisk -l</code> 查看磁盘信息。其中 <code>/dev/sdb</code> 是用于扩容的磁盘。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls /dev/sd*</span><br><span class="line">/dev/sda  /dev/sdb  /dev/sdc  /dev/sdc1  /dev/sdc2  /dev/sdc3</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建pv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate /dev/sdb </span><br><span class="line">  Physical volume &quot;/dev/sdb&quot; successfully created.</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看vg组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize    VFree</span><br><span class="line">  centos   1   3   0 wz--n- &lt;446.59g    0    # 此时vfree为0</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展vg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgextend centos /dev/sdb </span><br><span class="line">  Volume group &quot;centos&quot; successfully extended</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次查看vg组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgs</span><br><span class="line">  VG     #PV #LV #SN Attr   VSize  VFree  </span><br><span class="line">  centos   2   3   0 wz--n- &lt;1.35t 931.51g     # 此时vfree为 931.51g</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展lv（+500G）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvextend -L +500G /dev/mapper/centos-var </span><br><span class="line">  Size of logical volume centos/var changed from &lt;374.59 GiB (95895 extents) to &lt;874.59 GiB (223895 extents).</span><br><span class="line">  Logical volume centos/var successfully resized.</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统重新读取大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# xfs_growfs /dev/mapper/centos-var </span><br><span class="line">meta-data=/dev/mapper/centos-var isize=256    agcount=4, agsize=24549120 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=98196480, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line">log      =internal               bsize=4096   blocks=47947, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 98196480 to 229268480</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看扩容是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   40G  3.9G   37G  10% /</span><br><span class="line">devtmpfs                  12G     0   12G   0% /dev</span><br><span class="line">tmpfs                     12G     0   12G   0% /dev/shm</span><br><span class="line">tmpfs                     12G   33M   12G   1% /run</span><br><span class="line">tmpfs                     12G     0   12G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdc2                497M  155M  343M  32% /boot</span><br><span class="line">/dev/sdc1                 50M   12M   39M  23% /boot/efi</span><br><span class="line">/dev/mapper/centos-var   875G  254G  621G  30% /var        # 大小 375G + 500G = 875G</span><br><span class="line">tmpfs                    2.4G     0  2.4G   0% /run/user/0</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx服务器安装配置</title>
    <url>/doc/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>环境：</strong></p>
<blockquote>
<p>Linux CentOS 7</p>
<p>3.10.0-1062.9.1.el7.x86_64</p>
</blockquote>
<p><font color=red><strong><em>强调：server{} 包含在http{}内部，每一个server{}都是一个虚拟主机（站点）！！！</em></strong></font></p>
<h2 id="Nginx服务器安装配置"><a href="#Nginx服务器安装配置" class="headerlink" title="Nginx服务器安装配置"></a>Nginx服务器安装配置</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install pcre* -y</span><br><span class="line">yum install openssl* -y</span><br></pre></td></tr></table></figure>

<h3 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h3><ol>
<li><p>Nginx下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf nginx-1.19.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查配置文件是否生效</p>
<p>进入解压目录，根据提示安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Nginx服务器配置"><a href="#Nginx服务器配置" class="headerlink" title="Nginx服务器配置"></a>Nginx服务器配置</h2><h3 id="nginx命令添加"><a href="#nginx命令添加" class="headerlink" title="nginx命令添加"></a>nginx命令添加</h3><p>创建软连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;bin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<h3 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h3><p>启动nginx服务器，查看进程状态，通过ip访问测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx # 启动nginx服务器</span><br><span class="line"></span><br><span class="line">ps -aux|grep nginx # 查看nginx进程</span><br></pre></td></tr></table></figure>

<h3 id="配置服务器主配置文件"><a href="#配置服务器主配置文件" class="headerlink" title="配置服务器主配置文件"></a>配置服务器主配置文件</h3><blockquote>
<p>vi /usr/local/nginx/conf/nginx.conf</p>
</blockquote>
<ol>
<li><p>文件第一行添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user    root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除<strong>server部分</strong></p>
</li>
<li><p>在http括号内添加一行</p>
<p><strong>这是自定义nginx sever配置文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">include /root/nginx/*.conf;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自定义服务器配置"><a href="#自定义服务器配置" class="headerlink" title="自定义服务器配置"></a>自定义服务器配置</h3><p>编辑自定义nginx sever配置文件</p>
<blockquote>
<p>vim /root/nginx/nginx-server.conf</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; <span class="comment">#监听IP端口 </span></span><br><span class="line">    server_name localhost; <span class="comment">#主机名</span></span><br><span class="line">    location /&#123;</span><br><span class="line">        root /root/nginx/html;</span><br><span class="line">        index  index.html index.htm; <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查配置文件"><a href="#检查配置文件" class="headerlink" title="检查配置文件"></a>检查配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>提示如下：成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master nginx]# nginx -t</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<h3 id="重启服务器"><a href="#重启服务器" class="headerlink" title="重启服务器"></a>重启服务器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload </span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在配置文件中的根目录创建 index.html，随便输几个字母（eg: Nginx test…），保存退出。浏览器访问测试。</p>
<blockquote>
<p>vim /root/nginx/html/index.html</p>
</blockquote>
<h2 id="Nginx配置文件注释"><a href="#Nginx配置文件注释" class="headerlink" title="Nginx配置文件注释"></a>Nginx配置文件注释</h2><h3 id="Nginx主配置"><a href="#Nginx主配置" class="headerlink" title="Nginx主配置"></a>Nginx主配置</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-Nginx主配置文件</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody; </span></span><br><span class="line">user    root</span><br><span class="line"><span class="comment">#开启进程数 &lt;=CPU数 </span></span><br><span class="line">worker_processes 1; </span><br><span class="line">  </span><br><span class="line"><span class="comment">#错误日志保存位置 </span></span><br><span class="line"><span class="comment">#error_log logs/error.log; </span></span><br><span class="line"><span class="comment">#error_log logs/error.log notice; </span></span><br><span class="line"><span class="comment">#error_log logs/error.log info; </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#进程号保存文件 </span></span><br><span class="line"><span class="comment">#pid logs/nginx.pid; </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#等待事件 </span></span><br><span class="line">events &#123; </span><br><span class="line">  <span class="comment">#每个进程最大连接数（最大连接=连接数x进程数）  </span></span><br><span class="line">  worker_connections 1024; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http &#123; </span><br><span class="line">  <span class="comment">#文件扩展名与文件类型映射表 </span></span><br><span class="line">  include mime.types;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">#默认文件类型 </span></span><br><span class="line">  default_type application/octet-stream; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#日志文件输出格式 这个位置相于全局设置 </span></span><br><span class="line">  <span class="comment">#log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; </span></span><br><span class="line">  <span class="comment"># &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; </span></span><br><span class="line">  <span class="comment"># &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#请求日志保存位置 </span></span><br><span class="line">  <span class="comment">#access_log logs/access.log main; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#打开发送文件 </span></span><br><span class="line">  sendfile on; </span><br><span class="line">  <span class="comment">#tcp_nopush on; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#连接超时时间 </span></span><br><span class="line">  <span class="comment">#keepalive_timeout 0; </span></span><br><span class="line">  keepalive_timeout 65; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#打开gzip压缩 </span></span><br><span class="line">  <span class="comment">#gzip on; </span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#设定请求缓冲 </span></span><br><span class="line">  client_header_buffer_size 1k; </span><br><span class="line">  large_client_header_buffers 4 4k; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#设定负载均衡的服务器列表 </span></span><br><span class="line">  upstream tomcat-servers &#123;</span><br><span class="line">    <span class="comment">#weigth参数表示权值，权值越高被分配到的几率越大 </span></span><br><span class="line">    <span class="comment">#max_fails 当有#max_fails个请求失败，就表示后端的服务器不可用，默认为1，将其设置为0可以关闭检查 </span></span><br><span class="line">    <span class="comment">#fail_timeout 在以后的#fail_timeout时间内nginx不会再把请求发往已检查出标记为不可用的服务器 </span></span><br><span class="line">    <span class="comment">#这里指定多个源服务器，ip:端口,80端口的话可写可不写 </span></span><br><span class="line">    server 127.0.0.1:8080 weight=5 max_fails=2 fail_timeout=600s; </span><br><span class="line">    <span class="comment">#server 127.0.0.2:8080 weight=3 max_fails=2 fail_timeout=600s;  </span></span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">    include /root/nginx/*conf;    <span class="comment"># 添加自定义的配置文件！！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="Nginx虚拟主机配置"><a href="#Nginx虚拟主机配置" class="headerlink" title="Nginx虚拟主机配置"></a>Nginx虚拟主机配置</h3><div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏-Nginx自定义虚拟主机配置</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;  //监听端口为80，可以自定义其他端口，也可以加上IP地址，如，listen 127.0.0.1:8080;</span><br><span class="line">    server_name  localhost; //定义网站域名，可以写多个，用空格分隔</span><br><span class="line">    <span class="comment">#charset koi8-r; //定义网站的字符集，一般不设置，而是在网页代码中设置</span></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main; //定义访问日志，相当于局部变量 ,可以针对每一个server（即每一个站点）设置它们自己的访问日志</span></span><br><span class="line">    <span class="comment">##在server&#123;&#125;里有很多location配置段</span></span><br><span class="line">    <span class="comment">#对本server&quot;/&quot;启用负载均衡</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;  //定义网站根目录，目录可以是相对路径也可以是绝对路径</span><br><span class="line">        index  index.html index.htm; <span class="comment">#定义首页索引文件的名称</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#以下是一些反向代理的配置可删除. </span></span><br><span class="line">        <span class="comment"># proxy_redirect off;  </span></span><br><span class="line">        <span class="comment"># proxy_set_header Host $host;  </span></span><br><span class="line">        <span class="comment"># proxy_set_header X-Real-IP $remote_addr;  </span></span><br><span class="line">        <span class="comment"># proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span></span><br><span class="line">        <span class="comment"># client_max_body_size 10m; #允许客户端请求的最大单文件字节数  </span></span><br><span class="line">        <span class="comment"># client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，  </span></span><br><span class="line">        <span class="comment"># proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)  </span></span><br><span class="line">        <span class="comment"># proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)  </span></span><br><span class="line">        <span class="comment"># proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)  </span></span><br><span class="line">        <span class="comment"># proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小  </span></span><br><span class="line">        <span class="comment"># proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置  </span></span><br><span class="line">        <span class="comment"># proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）  </span></span><br><span class="line">        <span class="comment"># proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设定查看Nginx状态的地址  </span></span><br><span class="line">    location /NginxStatus &#123;  </span><br><span class="line">        stub_status on;  </span><br><span class="line">        access_log off;  </span><br><span class="line">        <span class="comment">#allow 192.168.1.88; </span></span><br><span class="line">        <span class="comment">#deny all; </span></span><br><span class="line">        <span class="comment">#auth_basic &quot;NginxStatus&quot;;  </span></span><br><span class="line">        <span class="comment">#auth_basic_user_file conf/htpasswd;  </span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#error_page  404              /404.html;  //定义404页面</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;  //当状态码为500、502、503、504时，则访问50x.html</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;  //定义50x.html所在路径</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#定义访问php脚本时，将会执行本location&#123;&#125;部分指令</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;  //proxy_pass后面指定要访问的url链接，用proxy_pass实现代理。</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;  //定义FastCGI服务器监听端口与地址，支持两种形式，1 IP:Port， 2 unix:/path/to/sockt</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;  //定义SCRIPT_FILENAME变量，后面的路径/scripts为上面的root指定的目录</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params; //引用prefix/conf/fastcgi_params文件，该文件定义了fastcgi相关的变量</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;   //访问的url中，以/.ht开头的，如，www.example.com/.htaccess，会被拒绝，返回403状态码。</span></span><br><span class="line">    <span class="comment">#    deny  all;  //这里的all指的是所有的请求。</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="SSL配置"><a href="#SSL配置" class="headerlink" title="SSL配置"></a>SSL配置</h2><p>Nginx 默认安装的情况下<code>ssl模块</code>并未被安装，如果要使用该模块则需要在编译nginx时指定<code>with-http_ssl_module</code>参数。</p>
<ol>
<li><p>查看ngixn版本极其编译参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入nginx源码目录</p>
</li>
<li><p>重新编译模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>make</code>  <strong><em>全完别 make install 覆盖安装</em></strong></p>
</li>
<li><p>备份旧的nginx程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>将刚刚编译好的nginx覆盖掉原有的nginx（这个时候nginx要停止状态 — <code>kill 9</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看模块安装结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># or</span></span></span><br><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查配置&amp;启动nginx</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhoulifeng/p/10236116.html">nginx服务器搭建以及配置</a></p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Nginx</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown学习总结笔记</title>
    <url>/doc/Markdown%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF等多种格式的文档。<br>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>Typora 官网：<a href="https://typora.io/">https://typora.io/</a><br>吐槽点：换行会自动加入空行，难受…</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>标题使用<kbd>#</kbd>表示，可分为1-6级标题，几级标题使用几个<kbd>#</kbd>，并以空格分隔标题名，如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文本格式"><a href="#2-文本格式" class="headerlink" title="2. 文本格式"></a>2. 文本格式</h2><h3 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2.1  字体"></a>2.1  字体</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_粗斜体文本<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-分隔线"><a href="#2-2-分隔线" class="headerlink" title="2.2 分隔线"></a>2.2 分隔线</h3><p>使用三个及以上<kbd>*</kbd>、<kbd>-</kbd>可建立分隔线，字符间不许其他符号，格式如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span></span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h3><p>若要对文本内容添加删除线，如<del>删除线内容</del>，只需要在文字的两端加上两个波浪线 <kbd>~~</kbd> 即可格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线内容~~</span><br></pre></td></tr></table></figure>

<h3 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h3><p>下划线通过HTML标签<kbd>&lt;u&gt;</kbd>实现，如下</p>
<p><u>下划线文本</u></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-脚注"><a href="#2-5-脚注" class="headerlink" title="2.5 脚注"></a>2.5 脚注</h3><p>脚注是对文本内容的补充说明，样式如下：<br>文本内容文本内容[^Markdown]。<br>[^Markdown]: Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">文本内容文本内容[^Markdown]。</span><br><span class="line">[<span class="symbol">^Markdown</span>]: <span class="link">Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-列表格式"><a href="#3-列表格式" class="headerlink" title="3. 列表格式"></a>3. 列表格式</h2><p>Markdown中列表可分为无序列表和有序列表。<br><strong>无序列表</strong>：使用<kbd>* </kbd>、<kbd>+ </kbd> 、<kbd>- </kbd>作为标记符。样式如下：</p>
<ul>
<li>*第一项</li>
<li>*第二项</li>
</ul>
<ul>
<li>-第一项</li>
<li>-第二项</li>
</ul>
<ul>
<li>+第一项</li>
<li>+第二项</li>
</ul>
<p>markdown书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> <span class="emphasis">*第一项</span></span><br><span class="line"><span class="emphasis">*</span> <span class="emphasis">*第二项</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- -第一项</span></span><br><span class="line"><span class="emphasis">- -第二项</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">+ +第一项</span></span><br><span class="line"><span class="emphasis">+ +第二项</span></span><br></pre></td></tr></table></figure>

<p><strong>有序列表</strong>：有序列表使用数字并加上<kbd>. </kbd>来表示，样式如下：</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<p>书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure>

<p><strong>列表嵌套</strong>：多层列表嵌套，子列表添加一个<kbd>tab</kbd>或者四个空格缩进即可，样式如下：</p>
<ol>
<li>第一项<ul>
<li>第一项嵌套（可有序）</li>
<li>第二项嵌套（可有序）</li>
</ul>
</li>
<li>第二项</li>
</ol>
<p>书写格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">   *</span> 第一项嵌套（可有序）</span><br><span class="line"><span class="bullet">   *</span> 第二项嵌套（可有序）</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br></pre></td></tr></table></figure>

<h2 id="4-区块"><a href="#4-区块" class="headerlink" title="4. 区块"></a>4. 区块</h2><p>Markdown 区块引用是在段落开头使用 <kbd>></kbd> 符号 ，然后后面紧跟一个<strong>空格</strong>符号。样式如下：</p>
<blockquote>
<p>Markdown区块演示<br>Markdown区块演示</p>
</blockquote>
<p>书写格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Markdown区块演示</span><br><span class="line">&gt; Markdown区块演示</span><br></pre></td></tr></table></figure>

<p>区块可嵌套使用，如下：</p>
<blockquote>
<p>外层区块</p>
<blockquote>
<p>内层区块</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 外层区块</span><br><span class="line">&gt; &gt; 内层区块</span><br></pre></td></tr></table></figure>

<h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h2><p>段落上的函数或代码片段可用反引号<kbd>`</kbd>包起来，如：</p>
<p><code>cout</code><br><code>cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;cout&#96;</span><br><span class="line">&#96;cout &lt;&lt; &quot;ans &#x3D; &quot; &lt;&lt; ans &lt;&lt; endl;&#96;</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong>使用<kbd>```</kbd><strong>独占一行</strong>包起来，代码高亮设置可加上语言标记前如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```markdown</span></span><br><span class="line"><span class="code">Markdown代码块</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure>

<h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6. 链接"></a>6. 链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]() 格式:</span><br><span class="line">[Google](www.google.com)</span><br><span class="line"></span><br><span class="line">&lt;&gt; 格式:</span><br><span class="line">&lt;www.google.com&gt;</span><br><span class="line"></span><br><span class="line">变量替代格式：</span><br><span class="line">[Google][google-link]</span><br><span class="line">[google-link]:www.google.com</span><br></pre></td></tr></table></figure>
<p><a href=""></a> 格式:<br><a href="www.google.com">Google</a></p>
<p>&lt;&gt; 格式:<br>&lt;<a href="http://www.google.com&gt;/">www.google.com&gt;</a></p>
<p>变量替代格式：<br>[Google][google-link]<br>[google-link]:<a href="http://www.google.com/">www.google.com</a></p>
<h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7. 图片"></a>7. 图片</h2><p>Markdown中图片以<kbd>![图片标签 属性](图片地址)</kbd>格式或以<kbd>&lt;img src="图片地址" 属性&gt;</kbd>书写。图片地址可分为：</p>
<ol>
<li><p>绝对地址，即一个完整的链接，可以是本地文件目录绝对地址，也可以是网络图片链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>](<span class="link">绝对地址</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;绝对地址&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相对地址，相对地址建议使用Linux地址格式，Windows格式的地址是以<kbd>\</kbd>分隔文件目录，使用这种地址格式在<strong>git上无法显示</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>](<span class="link">相对地址</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;相对地址&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>地址变量，不在图片出直接填写图片地址，通过变量，在文档结尾统一给出变量值。如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>][<span class="symbol">picture-link</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">picture-link</span>]:<span class="link">图片地址</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h2><p>Markdown使用<kbd>|</kbd>分隔不同的单元格，使用<kbd>-</kbd>分隔表头，该两种符号两侧至少一个空格（最左或最右除外）。<br>对齐方式：</p>
<ul>
<li><kbd>:-</kbd>代表左对齐</li>
<li><kbd>:-:</kbd>代表居中对齐</li>
<li><kbd>-:</kbd>代表右对齐</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中对齐 | 右对齐 |</span><br><span class="line">| :--- | :----: | ----: |</span><br><span class="line">| aaaa | bbbbbb | ccccc |</span><br><span class="line">| a    | b      | c     |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aaaa</td>
<td align="center">bbbbbb</td>
<td align="right">ccccc</td>
</tr>
<tr>
<td align="left">a</td>
<td align="center">b</td>
<td align="right">c</td>
</tr>
</tbody></table>
<h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h2><p>支持HTML元素，不在Markdown 涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。<br>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等</p>
<p>此外，Markdown还支持数学公式，画流程图、时序图、甘特图等。</p>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/leetcode/%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h3 id="丑数的定义"><a href="#丑数的定义" class="headerlink" title="丑数的定义"></a>丑数的定义</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。</p>
<blockquote>
<p>1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
</blockquote>
<h3 id="丑数的判断"><a href="#丑数的判断" class="headerlink" title="丑数的判断"></a>丑数的判断</h3><p>依次循环除以2、3、5直到不能整除，最后值为1则为丑数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">7</span>)     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出第N大的丑数"><a href="#找出第N大的丑数" class="headerlink" title="找出第N大的丑数"></a>找出第N大的丑数</h3><p>【思路】 <strong>动态规划</strong></p>
<p>丑数可以看做是2、3、5的幂的积。</p>
<p>根据幂得到一个丑数容易，问题的难点在于如何使得数据有序。依次递增存储丑数，使用三指针记录当前乘以2、3、5待选的丑数索引，再记录待选中间结果减少计算次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">7</span>) <span class="keyword">return</span> n; <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uglyNums</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// n个丑数 第一个为1</span></span><br><span class="line">    <span class="keyword">int</span> index_2 = <span class="number">0</span>, index_3 = <span class="number">0</span>, index_5 = <span class="number">0</span>; <span class="comment">// 当前乘2、3、5的丑数列表中值的下标</span></span><br><span class="line">    <span class="keyword">int</span> tmp_2 = <span class="number">2</span>, tmp_3 = <span class="number">3</span>, tmp_5 = <span class="number">5</span>;        <span class="comment">// 乘2、3、5的待选丑数（减少计算次数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        uglyNums[i] = min(tmp_2, min(tmp_3, tmp_5)); <span class="comment">// 取最小值</span></span><br><span class="line">        <span class="comment">// 更新待选丑数</span></span><br><span class="line">        <span class="comment">// 存在待选值相等的情况</span></span><br><span class="line">        <span class="keyword">if</span>(uglyNums[i] == tmp_2)&#123;</span><br><span class="line">            tmp_2 = uglyNums[++index_2] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uglyNums[i] == tmp_3)&#123;</span><br><span class="line">            tmp_3 = uglyNums[++index_3] * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uglyNums[i] == tmp_5)&#123;</span><br><span class="line">            tmp_5 = uglyNums[++index_5] * <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uglyNums[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超级丑数"><a href="#超级丑数" class="headerlink" title="超级丑数"></a>超级丑数</h3><p>超级丑数是指其所有质因数都是长度为 <code>k</code> 的质数列表 <code>primes</code> 中的正整数。</p>
<p>【思路】 <strong>动态规划</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到最小待选结果索引集合</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinValueIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minValue = tmp[<span class="number">0</span>];  <span class="comment">// 待选最小值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minValueIndexs</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] &lt; minValue)&#123;</span><br><span class="line">            minValue = tmp[i]; <span class="comment">// 最小值</span></span><br><span class="line">            minValueIndexs.clear(); <span class="comment">// 擦除旧索引</span></span><br><span class="line">            minValueIndexs.push_back(i); <span class="comment">// 新索引</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == minValue)&#123;</span><br><span class="line">            minValueIndexs.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minValueIndexs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第N个超级丑数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uglyNums</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// n个丑数  第一个丑数是1</span></span><br><span class="line">    <span class="keyword">int</span> k = primes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(k, <span class="number">0</span>)</span></span>;    <span class="comment">// 索引</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(primes)</span></span>;    <span class="comment">// 待选数据缓冲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpIndex = findMinValueIndex(tmp, k); <span class="comment">// 最小待选值索引</span></span><br><span class="line">        uglyNums[i] = tmp[tmpIndex[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; val : tmpIndex)&#123;</span><br><span class="line">            ++index[val];</span><br><span class="line">            tmp[val] = uglyNums[index[val]] * primes[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uglyNums[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="丑数-III-—-二分"><a href="#丑数-III-—-二分" class="headerlink" title="丑数 III — 二分"></a>丑数 III — 二分</h3><blockquote>
<p>请你帮忙设计一个程序，用来找出第 <code>n</code> 个丑数。</p>
<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong>。（1不算丑数）</p>
<p>来源：力扣 <a href="https://leetcode-cn.com/problems/ugly-number-iii/">https://leetcode-cn.com/problems/ugly-number-iii/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/** 【二分法】</span></span><br><span class="line"><span class="comment">给定一个丑数 X :</span></span><br><span class="line"><span class="comment">    1. 该数只能被a整除 (该数一定是a 的整数倍)   &#123;X/a&#125; - &#123;情况4 + 情况5 + 情况7&#125;</span></span><br><span class="line"><span class="comment">    2. 该数只能被b整除 (该数一定是b 的整数倍)   &#123;X/b&#125; - &#123;情况4 + 情况6 + 情况7&#125;</span></span><br><span class="line"><span class="comment">    3. 该数只能被c整除 (该数一定是c 的整数倍)   &#123;X/c&#125; - &#123;情况5 + 情况6 + 情况7&#125;</span></span><br><span class="line"><span class="comment">    4. 该数只能被a和b同时整除 (该数一定是a、b最小公倍数的整数倍)        &#123;X/ab&#125; - &#123;情况7&#125;</span></span><br><span class="line"><span class="comment">    5. 该数只能被a和c同时整除 (该数一定是a、c最小公倍数的整数倍)        &#123;X/ac&#125; - &#123;情况7&#125;</span></span><br><span class="line"><span class="comment">    6. 该数只能被b和c同时整除 (该数一定是b、c最小公倍数的整数倍)        &#123;X/bc&#125; - &#123;情况7&#125;</span></span><br><span class="line"><span class="comment">    7. 该数只能被a和b和c同时整除 (该数一定是a、b、c的最小公倍数的整数倍) &#123;X/abc&#125;</span></span><br><span class="line"><span class="comment">(1, X] 有多少个丑数 :</span></span><br><span class="line"><span class="comment">    &#123;X/a&#125; + &#123;X/b&#125; + &#123;X/c&#125; - &#123;X/ab&#125; - &#123;X/ac&#125; - &#123;X/bc&#125; + &#123;X/abc&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ab, ac, bc, abc;  <span class="comment">// 最小公倍数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">二分查找第 n 个正整数丑数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>&amp; n, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span>&amp; c, <span class="keyword">long</span> <span class="keyword">long</span> left, <span class="keyword">long</span> <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算 (1, mid] 有多少个丑数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = mid/a + mid/b + mid/c - mid/ab - mid/ac - mid/bc + mid/abc; </span><br><span class="line">    <span class="keyword">if</span>(num == n)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; n)</span><br><span class="line">        <span class="keyword">return</span> binarySearch(n, a, b, c, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(n, a, b, c, left, mid<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两数最小公倍数</span></span><br><span class="line"><span class="comment">// 乘积 = 最小公倍数 * 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">leastCommonMultiple</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mult = (<span class="keyword">long</span> <span class="keyword">long</span>)a * b;</span><br><span class="line">    <span class="comment">// 辗转相除求最大公约数</span></span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mult / a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 计算最小公倍数</span></span><br><span class="line">        ab = leastCommonMultiple(a, b);</span><br><span class="line">        ac = leastCommonMultiple(a, c);</span><br><span class="line">        bc = leastCommonMultiple(b, c);</span><br><span class="line">        abc = leastCommonMultiple(ab, c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = min(a, min(a, b));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> right = left * n;     <span class="comment">// 第 n 个丑数不超过第一个丑数的 n 倍</span></span><br><span class="line">        <span class="keyword">long</span> ans = binarySearch(n, a, b, c, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans - min(ans % a, min(ans % b, ans % c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题记录</title>
    <url>/leetcode/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43. 1～n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">43. 1～n整数中1出现的次数</a></h3><blockquote>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>暴力解法：对于区间内的每<strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p> <strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt; 2^31</code></li>
</ul>
<p>个数的每一位进行判断。显然不太友好。</p>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p><strong>有意思的解法</strong>（<a href="https://blog.csdn.net/yi_Afly/article/details/52012593">参考链接</a>）：</p>
<p>考虑将n的十进制的每一位单独拿出讨论，给定一个n，其最后一位（个位）记为<code>last_bit</code>。<code>last_bit</code>从0到9记为一个周期。一个周期中1出现的次数为1次。</p>
<p>从1到n，总共有<strong>round = n/10</strong>个完整的周期。再看<code>last_bit</code>值，当值大于0时，1又出现了一次。</p>
<p> [1, n]中个位出现1的次数 = round + (last_bit &gt; 0)?1 : 0</p>
<blockquote>
<p>将n的各个位分为两类：个位与其它位。</p>
<p>对个位来说：</p>
<ul>
<li>若个位大于0，1出现的次数为<code>round*1+1</code></li>
<li>若个位等于0，1出现的次数为<code>round*1</code></li>
</ul>
<p>对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，则：</p>
<ul>
<li>若weight为0，则1出现次数为<code>round*base</code></li>
<li>若weight为1，则1出现次数为<code>round*base+former+1</code></li>
<li>若weight大于1，则1出现次数为<code>rount*base+base</code></li>
</ul>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last_bit, round;</span><br><span class="line">    <span class="keyword">long</span> base; <span class="comment">// 防止溢出</span></span><br><span class="line">    round = n;</span><br><span class="line">    base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(round)&#123;</span><br><span class="line">        last_bit = round % <span class="number">10</span>; <span class="comment">//round 最后数值</span></span><br><span class="line">        round = round / <span class="number">10</span>;  <span class="comment">// round 最后数值从 0~9 有多少个完整的周期</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == last_bit)</span><br><span class="line">            count += round * base;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == last_bit)</span><br><span class="line">            count += round * base + n % base + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count += round * base + base;</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">49. 丑数</a></h3><blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p><strong>判断丑数的方法</strong>：首先除2，直到不能整除为止，然后除5到不能整除为止，然后除3直到不能整除为止。最终判断剩余的数字是否为1，如果是1则为丑数，否则不是丑数。</p>
<p><strong>查找第N大的丑数</strong>：根据丑数的性质，仅含有2、3、5质因子，除1以外，后面的某个丑数一定是前面某个丑数乘以2或3或5的结果。因此可以以空间换时间，维护一个从小到大的丑数列表。</p>
<p><strong><em>疑问：使用空间存储备选的三个丑数，感觉是减少了计算次数，但是LeetCode上提交的时间效率居然更低？？？</em></strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ugly_number_list;</span><br><span class="line">        <span class="keyword">int</span> mult_2_index, mult_3_index, mult_5_index; <span class="comment">// 当前乘2、3、5的丑数列表中值的下标</span></span><br><span class="line">        ugly_number_list.push_back(<span class="number">1</span>);</span><br><span class="line">        mult_2_index = mult_3_index = mult_5_index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">            <span class="keyword">int</span> min_num = min(ugly_number_list[mult_2_index]*<span class="number">2</span>,</span><br><span class="line">                 min(ugly_number_list[mult_3_index]*<span class="number">3</span>, ugly_number_list[mult_5_index]*<span class="number">5</span>));</span><br><span class="line">            ugly_number_list.push_back(min_num); <span class="comment">// 第 k 大丑数</span></span><br><span class="line">            <span class="keyword">if</span>(min_num == ugly_number_list[mult_2_index]*<span class="number">2</span>)&#123;</span><br><span class="line">                ++mult_2_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min_num == ugly_number_list[mult_3_index]*<span class="number">3</span>)&#123;</span><br><span class="line">                ++mult_3_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min_num == ugly_number_list[mult_5_index]*<span class="number">5</span>)&#123;</span><br><span class="line">                ++mult_5_index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ugly_number_list.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">51. 数组中的逆序对</a></h3><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

</blockquote>
<p><strong>【解题思路】</strong> </p>
<p>首先暴力解法，利用冒泡排序，交换次数即是逆序对数量，时间复杂度 <code>O(n^2)</code> 。</p>
<p>再有，利用<strong>归并排序</strong>思想，先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。时间复杂度 <code>O(nlogn)</code> 。递归算法空间复杂度 <code>O(n+logn)</code> ，非递归算法空间复杂度 <code>O(n)</code> </p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 交换次数 = 逆序对数 O(n*n) </span></span><br><span class="line"><span class="comment">//归并排序 将数组分为两个子数组，先统计子数组逆序对数目，在合并子数组统计相邻子数组之间的逆序对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 存储过程中的数据</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// mergeSort(nums, 0, nums.size()-1, tmp, sum);</span></span><br><span class="line">    mergeSort_2(nums, tmp, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归 归并排序 [begin, end] 时间复杂度O(nlogn) 空间复杂的O(n+logn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (begin &gt;&gt; <span class="number">1</span>) + (end &gt;&gt; <span class="number">1</span>);  <span class="comment">// (begin + end) &gt;&gt; 1 担心溢出</span></span><br><span class="line">    mergeSort(nums, begin, mid, tmp, sum);</span><br><span class="line">    mergeSort(nums, mid+<span class="number">1</span>, end, tmp, sum);</span><br><span class="line">    merge(nums, begin, mid, end, tmp, sum); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 归并排序 时间复杂度O(nlogn) 空间复杂的O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort_2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin, mid, end, length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(length &lt; nums.size())&#123;</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin + length &lt; nums.size())&#123;</span><br><span class="line">            mid = begin + length - <span class="number">1</span>;</span><br><span class="line">            end = mid + length;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= nums.size())</span><br><span class="line">                end = nums.size() - <span class="number">1</span>;</span><br><span class="line">            merge(nums, begin, mid, end, tmp, sum);</span><br><span class="line">            begin = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并相邻有序两子数组 [begin, mid] [mid+1, end]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = begin, right = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp_index = begin;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid &amp;&amp; right &lt;= end)&#123; <span class="comment">// 归并到 tmp 数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt;= nums[right])</span><br><span class="line">            tmp[tmp_index++] = nums[left++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum += mid - left + <span class="number">1</span>; <span class="comment">// 左边子数组有比左边子数组当前所指值大的数组数目（即逆序对数目）</span></span><br><span class="line">            tmp[tmp_index++] = nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid) <span class="comment">// 左边数组还有数未排序 (有序)</span></span><br><span class="line">        tmp[tmp_index++] = nums[left++];</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= end) <span class="comment">// 右边数组还有数未排序 (有序)</span></span><br><span class="line">        tmp[tmp_index++] = nums[right++];</span><br><span class="line">    <span class="comment">// 将排序结果 更新到原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; ++i)&#123;</span><br><span class="line">        nums[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52. 两个链表的第一个公共节点</a></h3><blockquote>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom: 50%;" /></a></p>
<p>在节点 c1 开始相交。</p>
</blockquote>
<p>【<strong>解题思路</strong>】 </p>
<p>假设A链长度：<strong>a+n</strong>  B链长度：<strong>b+n</strong>，且 <strong>a&lt;b</strong>。</p>
<p>pA 从头走到尾走了 <strong>a+n</strong> 个位置，pB 也走了 <strong>a+n</strong> 个位置，且 pB 距离尾部还有 <strong>(b+n)-(a+n) = b-a</strong> 个位置。此时 pA 指向B链，当 pB 达到链尾时，pA 从B链移动了 b-a 个位置，距离第一个公共结点还需 <strong>a</strong> 步，此时让 pB 指向A链，那么 pB 距离第一个公共结点也是 <strong>a</strong> 步。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">            <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != pA)</span><br><span class="line">                    pA = pA-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pA = headB;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span> != pB)</span><br><span class="line">                    pB = pB-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pB = headA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span></span><br><span class="line"><span class="comment">        if(NULL == headA || NULL == headB)</span></span><br><span class="line"><span class="comment">            return NULL;</span></span><br><span class="line"><span class="comment">        // 先计算每条链表长度</span></span><br><span class="line"><span class="comment">        int len_A = 0, len_B = 0;</span></span><br><span class="line"><span class="comment">        ListNode *pNodeA = headA, *pNodeB = headB;</span></span><br><span class="line"><span class="comment">        while(pNodeA)&#123;</span></span><br><span class="line"><span class="comment">            ++len_A;</span></span><br><span class="line"><span class="comment">            pNodeA = pNodeA-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while(pNodeB)&#123;</span></span><br><span class="line"><span class="comment">            ++len_B;</span></span><br><span class="line"><span class="comment">            pNodeB = pNodeB-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 较长的链表 先移动指针 假设 pNodeA 指向较长的链表</span></span><br><span class="line"><span class="comment">        if(len_A &gt; len_B)&#123;</span></span><br><span class="line"><span class="comment">            pNodeA = headA;</span></span><br><span class="line"><span class="comment">            pNodeB = headB;</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            pNodeA = headB;</span></span><br><span class="line"><span class="comment">            pNodeB = headA;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int k = abs(len_A - len_B);</span></span><br><span class="line"><span class="comment">        while(k--)&#123;</span></span><br><span class="line"><span class="comment">            pNodeA = pNodeA-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 现在指针所指链表后续是一样长 同步移动</span></span><br><span class="line"><span class="comment">        while(pNodeA &amp;&amp; pNodeB)&#123;</span></span><br><span class="line"><span class="comment">            if(pNodeA == pNodeB)</span></span><br><span class="line"><span class="comment">                return pNodeA;</span></span><br><span class="line"><span class="comment">            pNodeA = pNodeA-&gt;next;</span></span><br><span class="line"><span class="comment">            pNodeB = pNodeB-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/leetcode/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="买卖股票的最佳时机（动态规划）"><a href="#买卖股票的最佳时机（动态规划）" class="headerlink" title="买卖股票的最佳时机（动态规划）"></a>买卖股票的最佳时机（动态规划）</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你<strong>最多只允许完成一笔交易</strong>（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">前i天的最大收益 = max&#123;前i-1天的最大收益, 第i天的价格 - 前i-1天中的最低价格&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre_min = prices[<span class="number">0</span>]; <span class="comment">// 前 i-1 天中的最低价格</span></span><br><span class="line">    <span class="keyword">int</span> max_earn = <span class="number">0</span>;        <span class="comment">// 前 i-1 天的最大收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        max_earn = max(max_earn, prices[i] - pre_min);</span><br><span class="line">        pre_min = min(pre_min, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_earn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-II（贪心）"><a href="#买卖股票的最佳时机-II（贪心）" class="headerlink" title="买卖股票的最佳时机 II（贪心）"></a>买卖股票的最佳时机 II（贪心）</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你<strong>可以尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>来源：力扣（LeetCode） <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 【贪心】</span></span><br><span class="line"><span class="comment">    // 遇到低价（比前后都低）便买入</span></span><br><span class="line"><span class="comment">    // 遇到高价比前后都高）就卖出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 持有时间必然是价格上升时间段 才有最大利益</span></span><br><span class="line"><span class="comment">    // \          /</span></span><br><span class="line"><span class="comment">    //  \  /\    /</span></span><br><span class="line"><span class="comment">    //   \/  \  /</span></span><br><span class="line"><span class="comment">    //        \/</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])</span><br><span class="line">                sum += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-III（动态规划）"><a href="#买卖股票的最佳时机-III（动态规划）" class="headerlink" title="买卖股票的最佳时机 III（动态规划）"></a>买卖股票的最佳时机 III（动态规划）</h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你<strong>最多</strong>可以完成 <strong>两笔</strong> 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、无买卖操作            0</span></span><br><span class="line"><span class="comment">    2、第一次买入            buy_first</span></span><br><span class="line"><span class="comment">    3、第一次买卖交易完成     sell_first</span></span><br><span class="line"><span class="comment">    4、第二次买入            buy_second</span></span><br><span class="line"><span class="comment">    5、第二次交易完成        sell_second</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> buy_first = -prices[<span class="number">0</span>], sell_first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy_second = -prices[<span class="number">0</span>], sell_second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        sell_second = max(sell_second, prices[i] + buy_second);</span><br><span class="line">        buy_second = max(buy_second, sell_first - prices[i]);</span><br><span class="line">        sell_first = max(sell_first, buy_first + prices[i]);</span><br><span class="line">        buy_first = max(buy_first, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(sell_first, sell_second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机-IV（动态规划）"><a href="#买卖股票的最佳时机-IV（动态规划）" class="headerlink" title="买卖股票的最佳时机 IV（动态规划）"></a>买卖股票的最佳时机 IV（动态规划）</h3><blockquote>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a> </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、无买卖操作               0</span></span><br><span class="line"><span class="comment">    2、第j次买入股票            buy[j]  0 &lt; j &lt;= k</span></span><br><span class="line"><span class="comment">    3、第j次卖出股票            sell[j]  0 &lt; j &lt;= k</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || days &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buy</span><span class="params">(k, -prices[<span class="number">0</span>])</span></span>;  <span class="comment">// buy[j] 第j次买入股票后的收益</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sell</span><span class="params">(k, <span class="number">0</span>)</span></span>;          <span class="comment">// sell[j] 第j次卖出股票后的收益</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = k - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">            sell[j] = max(sell[j], buy[j] + prices[i]);</span><br><span class="line">            buy[j] = max(buy[j], sell[j<span class="number">-1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sell[<span class="number">0</span>] = max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + prices[i]);</span><br><span class="line">        buy[<span class="number">0</span>] = max(buy[<span class="number">0</span>], -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_earn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; val : sell)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_earn &lt; val)</span><br><span class="line">            max_earn = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_earn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票的最佳时机含手续费（动态规划）"><a href="#买卖股票的最佳时机含手续费（动态规划）" class="headerlink" title="买卖股票的最佳时机含手续费（动态规划）"></a>买卖股票的最佳时机含手续费（动态规划）</h3><blockquote>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、持有股票     hold</span></span><br><span class="line"><span class="comment">    2、售出股票     sellout</span></span><br><span class="line"><span class="comment">* 最后一天不持有股票的利润肯定更大</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hold = -prices[<span class="number">0</span>]; <span class="comment">// 持有股票</span></span><br><span class="line">    <span class="keyword">int</span> sellout = <span class="number">0</span>;        <span class="comment">// 售出股票 不持有</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_hold = max(hold, sellout - prices[i]); </span><br><span class="line">        sellout = max(sellout, hold + prices[i] - fee);</span><br><span class="line">        hold = tmp_hold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sellout; <span class="comment">// 最后一天不持有股票利润肯定更大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最佳买卖股票时机含冷冻期（动态规划）"><a href="#最佳买卖股票时机含冷冻期（动态规划）" class="headerlink" title="最佳买卖股票时机含冷冻期（动态规划）"></a>最佳买卖股票时机含冷冻期（动态规划）</h3><blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<p>来源：力扣（LeetCode）<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【动态规划】</span></span><br><span class="line"><span class="comment">第i天结束时的可能状态：</span></span><br><span class="line"><span class="comment">    1、持有股票     hold</span></span><br><span class="line"><span class="comment">    2、售出股票     sell</span></span><br><span class="line"><span class="comment">    3、冷静期       cool</span></span><br><span class="line"><span class="comment">* 最后一天不持有股票的利润肯定更大</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = prices.size();</span><br><span class="line">    <span class="keyword">if</span>(days &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hold = -prices[<span class="number">0</span>];  <span class="comment">// 持有</span></span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;           <span class="comment">// 售出</span></span><br><span class="line">    <span class="keyword">int</span> cool = <span class="number">0</span>;           <span class="comment">// 冷静期</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_sell = max(sell, hold + prices[i]);</span><br><span class="line">        <span class="keyword">int</span> tmp_hold = max(hold, cool -prices[i]);</span><br><span class="line">        cool = max(cool, sell);</span><br><span class="line">        sell = tmp_sell;</span><br><span class="line">        hold = tmp_hold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-数学</title>
    <url>/leetcode/%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><blockquote>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p>这个题和《剑指offer》的一个排列题一样，允许字符重复。（LJ牛客，测试用例没覆盖全）</p>
<p>首先想到解决字符有重复就是先排序。在传递数组值得时候，如果是值传递那问题就简单了些。<strong>连续有序的序列中，依序用后续序列中的不重复的值替换第一个值，每次替换后，后续序列都是连续有序的！（这里非常巧妙）</strong></p>
<p>但是换作引用传递，事情就复杂了，每次递归处理前需要排序一次，还要考虑替换后的复原，避免重复选择等问题。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏解题代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="comment">//if(nums.size() &gt; 0)&#123;</span></span><br><span class="line">    sort(nums.begin(), nums.end()); <span class="comment">// 先排序</span></span><br><span class="line">    range(nums, <span class="number">0</span>, res);</span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nums 通过值传递</span></span><br><span class="line"><span class="comment">// 每次交换后 后续序列还是连续有序序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start_index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start_index == nums.size()<span class="number">-1</span>)&#123;</span><br><span class="line">        res.push_back(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start_index; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != start_index &amp;&amp; nums[start_index] == nums[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        swap(nums[start_index], nums[i]);</span><br><span class="line">        range(nums, start_index+<span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>笔记</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-栈</title>
    <url>/leetcode/%E6%A0%88/</url>
    <content><![CDATA[<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
</blockquote>
<p><strong>【解题思路】</strong> </p>
<p> 左括号入栈等待右括号进行闭合出栈。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏解题代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size()%<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> stack_char[s.size()/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index_stack_top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;)&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;]&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack_char[++index_stack_top] = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(index_stack_top &lt; <span class="number">0</span> </span><br><span class="line">                    || <span class="literal">false</span> == isPair(stack_char[index_stack_top], s[i])</span><br><span class="line">                    || index_stack_top &gt; s.size() / <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --index_stack_top;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack_char[++index_stack_top] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index_stack_top &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//判断两字符是否配对</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPair</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;a, <span class="keyword">const</span> <span class="keyword">char</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="string">&#x27;(&#x27;</span> == a &amp;&amp; <span class="string">&#x27;)&#x27;</span> == b)</span><br><span class="line">            || (<span class="string">&#x27;[&#x27;</span> == a &amp;&amp; <span class="string">&#x27;]&#x27;</span> == b)</span><br><span class="line">            || (<span class="string">&#x27;&#123;&#x27;</span> == a &amp;&amp; <span class="string">&#x27;&#125;&#x27;</span> == b))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><blockquote>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p>输出: [1,3,2]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<p><strong>【解题思路】</strong></p>
<p>左子树 –&gt; 根节点 –&gt; 右子树</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏解题代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_array;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; m_stack;</span><br><span class="line">        TreeNode* p_node = root;</span><br><span class="line">        <span class="keyword">while</span>(p_node || !m_stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p_node)&#123;</span><br><span class="line">                m_stack.push(p_node);</span><br><span class="line">                p_node = p_node-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p_node = m_stack.top();</span><br><span class="line">                inorder_array.push_back(p_node-&gt;val);</span><br><span class="line">                m_stack.pop();</span><br><span class="line">                p_node = p_node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inorder_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></h3><blockquote>
<p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p>
<p>由于答案可能很大，因此返回答案模 10^9 + 7。 </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 </span><br><span class="line">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A &lt;= 30000</code></li>
<li><code>1 &lt;= A[i] &lt;= 30000</code></li>
</ol>
</blockquote>
<p><strong>【解题】</strong></p>
<p>利用单调递增栈，计算当前值在连续子数组中为最小值的次数。即需要找到当前值往前第一个、往后第一个小于它的元素位置。</p>
<p>这个题解法很多，但是有时间限制就很难受！！！</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏解题代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 计算当前值在连续子数组中为最小值的次数 stack 单调递增栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;  </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m_stack; <span class="comment">// 单调递增栈</span></span><br><span class="line">        vector&lt;int&gt; pre_low(A.size(), -1), follow_low(A.size(), A.size());</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> current_index = <span class="number">0</span>; current_index &lt; A.size(); ++current_index)&#123;</span><br><span class="line">            <span class="comment">// 当前数值大于栈顶所指数组中的值 则右边第一个小于它的位置（下标）出现</span></span><br><span class="line">            <span class="keyword">while</span>(!m_stack.empty() &amp;&amp; A[current_index] &lt; A[m_stack.top()])&#123;</span><br><span class="line">                follow_low[m_stack.top()] = current_index;</span><br><span class="line">                m_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果栈不为空 因为是单调递增栈 故当前所指值找到 左边第一个不大于它的位置（下标）出现</span></span><br><span class="line">            <span class="keyword">if</span>(!m_stack.empty())</span><br><span class="line">                pre_low[current_index] = m_stack.top();</span><br><span class="line">            <span class="comment">//当前值下标进栈</span></span><br><span class="line">            m_stack.push(current_index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 就算总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; A.size(); ++index)&#123;</span><br><span class="line">            sum += (index - pre_low[index]) * (follow_low[index] - index) * A[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算当前值在连续子数组中为最小值的次数 </span></span><br><span class="line"><span class="comment">    int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123;  </span></span><br><span class="line"><span class="comment">        int pre_low_index, follow_low_index;</span></span><br><span class="line"><span class="comment">        long sum = 0;</span></span><br><span class="line"><span class="comment">        for(int current_index = 0; current_index &lt; A.size(); ++current_index)&#123;</span></span><br><span class="line"><span class="comment">            // 查找数组A中 在 current_index 前，不小于 A[current_index] 的值位置（下标）</span></span><br><span class="line"><span class="comment">            pre_low_index = current_index - 1;</span></span><br><span class="line"><span class="comment">            while(pre_low_index &gt;= 0 &amp;&amp; A[pre_low_index] &gt; A[current_index]) // 此处不取等 </span></span><br><span class="line"><span class="comment">                --pre_low_index;</span></span><br><span class="line"><span class="comment">            // 查找数组A中 在 current_index 后，不小于 A[current_index] 的值位置（下标）</span></span><br><span class="line"><span class="comment">            follow_low_index = current_index + 1; </span></span><br><span class="line"><span class="comment">            while(follow_low_index &lt; A.size() &amp;&amp; A[follow_low_index] &gt;= A[current_index]) // 此处去等 当有重复数字时算法也满足</span></span><br><span class="line"><span class="comment">                ++follow_low_index;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 连续子数组中 A[current_index] 为最小值的 数组组合方式</span></span><br><span class="line"><span class="comment">            // 当前位置前有 current_index - pre_low_index 种取法</span></span><br><span class="line"><span class="comment">            // 当前位置后有 follow_low_index - current_index 种取法</span></span><br><span class="line"><span class="comment">            sum += (current_index - pre_low_index) * (follow_low_index - current_index) * A[current_index];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sum % 1000000007;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 超时！！！ 计算每个连续子数组最小值  DP</span></span><br><span class="line"><span class="comment">    int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123;        </span></span><br><span class="line"><span class="comment">        if(A.size() &lt; 1)</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        int* from_index_sub = new int[A.size()]; // from_index_sub[k] 表示[k, current_index]连续子数组中最小的值</span></span><br><span class="line"><span class="comment">        //memset(from_index_sub, 0, A.size()*sizeof(long)); </span></span><br><span class="line"><span class="comment">        int current_index = 0;</span></span><br><span class="line"><span class="comment">        long sum = 0;</span></span><br><span class="line"><span class="comment">        while(current_index &lt; A.size())&#123;</span></span><br><span class="line"><span class="comment">            for(int i = 0; i &lt; current_index; ++i)&#123;</span></span><br><span class="line"><span class="comment">                if(from_index_sub[i] &gt; A[current_index])</span></span><br><span class="line"><span class="comment">                    from_index_sub[i] = A[current_index];</span></span><br><span class="line"><span class="comment">                sum += from_index_sub[i]; </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            from_index_sub[current_index] = A[current_index];</span></span><br><span class="line"><span class="comment">            sum += from_index_sub[current_index];</span></span><br><span class="line"><span class="comment">            ++current_index; </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        delete[] from_index_sub;</span></span><br><span class="line"><span class="comment">        return sum % 1000000007;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></h3><blockquote>
<p>给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bcabc&quot;</span><br><span class="line">输出: &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbacdcbc&quot;</span><br><span class="line">输出: &quot;acdb&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>【解题思路】</strong></p>
<p>使用栈存储不重复的字符序列，当新字符小于栈顶，且栈顶字符在后续字符串中还会出现时，抛出栈顶字符。</p>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏解题代码</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">m_stack</span><span class="params">(<span class="number">27</span>, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> stack_top = <span class="number">-1</span>;  <span class="comment">// 指向栈顶元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m_count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 记录字母出现的次数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">m_visited</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 对应字符是否已在栈中</span></span><br><span class="line">    <span class="comment">// 计算字符串中每个字母出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s) </span><br><span class="line">        ++m_count[c - <span class="string">&#x27;a&#x27;</span>]; </span><br><span class="line">    <span class="comment">// 通过栈得到 字典序最小的无重复字符的序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">false</span> == m_visited[c - <span class="string">&#x27;a&#x27;</span>])&#123; <span class="comment">// 当前字符还未使用</span></span><br><span class="line">            <span class="comment">// 栈非空 &amp;&amp; 栈顶字符 &gt; 当前字符 &amp;&amp; 后续字符串中还存在栈顶字符</span></span><br><span class="line">            <span class="keyword">while</span>(stack_top &gt;= <span class="number">0</span> &amp;&amp; m_stack[stack_top] &gt; c </span><br><span class="line">                &amp;&amp; m_count[m_stack[stack_top] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                m_visited[m_stack[stack_top] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>; <span class="comment">// 出栈前设置为未使用</span></span><br><span class="line">                --stack_top; <span class="comment">// 出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            m_stack[++stack_top] = c; <span class="comment">// 入栈</span></span><br><span class="line">            m_visited[c - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --m_count[c - <span class="string">&#x27;a&#x27;</span>]; <span class="comment">// 更新后续字符串中 当前字符的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_stack.resize(stack_top+<span class="number">1</span>); <span class="comment">// resize 改变字符串大小</span></span><br><span class="line">    <span class="keyword">return</span> m_stack;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size()%<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> stack_char[s.size()/<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index_stack_top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;)&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;]&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack_char[++index_stack_top] = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(index_stack_top &lt; <span class="number">0</span> </span><br><span class="line">                    || <span class="literal">false</span> == isPair(stack_char[index_stack_top], s[i])</span><br><span class="line">                    || index_stack_top &gt; s.size() / <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --index_stack_top;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack_char[++index_stack_top] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index_stack_top &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//判断两字符是否配对</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPair</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;a, <span class="keyword">const</span> <span class="keyword">char</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="string">&#x27;(&#x27;</span> == a &amp;&amp; <span class="string">&#x27;)&#x27;</span> == b)</span><br><span class="line">            || (<span class="string">&#x27;[&#x27;</span> == a &amp;&amp; <span class="string">&#x27;]&#x27;</span> == b)</span><br><span class="line">            || (<span class="string">&#x27;&#123;&#x27;</span> == a &amp;&amp; <span class="string">&#x27;&#125;&#x27;</span> == b))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>笔记</category>
        <category>leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Theme-Butterfly(一) 快速开始</title>
    <url>/hexo/Hexo-Theme-Butterfly(%E4%B8%80)-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<blockquote>
<p>感谢原作者 <a href="https://jerryc.me/">JerryC</a> 。</p>
<p>由于主题更新，此文件中部分配置可能失效。请参考作者博客或文档：<a href="https://demo.jerryc.me/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a> 。</p>
</blockquote>
<h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><p>在hexo博客根目录克隆Butterfly主题到 <code>themes</code> 文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>

<h1 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h1><p>修改博客更目录配置文件 <code>_config.yml</code> ，将主题改为 <code>butterfly</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>

<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pug 以及 stylus 的渲染器</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install cheerio@0.22.0 --save</span><br></pre></td></tr></table></figure>

<h1 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h1><p>为了减少升级主题后带来的不便，<code>Butterfly</code> 使用了 <a href="https://hexo.io/docs/data-files.html">data files</a> 特性。推荐把主题默认的配置文件 <code>_config.yml</code> 复製到 Hexo 根目录下的 <code>source/_data/</code> 目录下，然后将文件名改为 <code>butterfly.yml</code>（如果 <code>source/_data/</code> 的目录不存在就创建一个）。</p>
<blockquote>
<p>升级：在主题目录下 <code>git pull</code></p>
</blockquote>
<p><strong><em>注意</em></strong>：<em>由于主题在添加功能或者修復 Bugs 的情况下，可能会涉及到配置文件的修改。这时候，如果升级主题，需要把新增加的配置添加到 <code>butterfly.yml</code> 去，不然很大机会会出现报错。</em></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Theme-Butterfly(三) 主题配置</title>
    <url>/hexo/Hexo-Theme-Butterfly(%E4%B8%89)-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>感谢原作者 <a href="https://jerryc.me/">JerryC</a> </p>
<p>由于主题更新，此文件中部分配置可能失效。请参考作者博客或文档：<a href="https://demo.jerryc.me/posts/4aa8abbe/">Butterfly 安裝文档(三) 主题配置-1</a>  <a href="https://demo.jerryc.me/posts/ceeb73f/">Butterfly 安装文档(四) 主题配置-2</a></p>
</blockquote>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>修改配置文件 <code>_config.yml</code> ，主题支持三种语言</p>
<ul>
<li>default(en)</li>
<li>zh-CN (简体中文)</li>
<li>zh-TW (繁体中文)</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><p>修改配置文件 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">jakelin&#x27;s</span> <span class="string">blogs</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">jakelin&#x27;s</span> <span class="string">blogs</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">一个记录分享学习、生活的地方</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">jakelin</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">email:</span></span><br></pre></td></tr></table></figure>

<h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h2><p>配置 <code>butterfly.yml</code> ，必须是 <code>/xxx/</code> 后面 <code>||</code> 分开，然后为图标名。<strong>可自行定义！</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">清单||fa</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">音乐</span> <span class="string">||</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">照片</span> <span class="string">||</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-picture-o</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">电影</span> <span class="string">||</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-film</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/messageboard/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code Blocks (代码相关)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">pale</span> <span class="string">night</span> <span class="comment"># Butterfly 支持 6 种代码高亮样式：default / darker / pale night / light / ocean / mac</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 代码是否启用复制功能</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># show the code language</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true:代码框不展开，需点击 &#x27;&gt;&#x27; 打开 false:展开 none:不显示&#x27;&gt;&#x27;按钮，代码块展开</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span> <span class="comment"># 代码自动换行</span></span><br></pre></td></tr></table></figure>

<h2 id="社交图片"><a href="#社交图片" class="headerlink" title="社交图片"></a>社交图片</h2><p>Butterfly 支持 <a href="https://fontawesome.com/icons?from=io"><strong>font-awesome v5</strong></a> 图标。书写格式 图标名： <code>url || 描述性文字</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># social settings (社交图标设置)</span></span><br><span class="line"><span class="comment"># formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/username</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:emailname@email.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure>

<h2 id="主页文章节选-自动节选和文章页-description"><a href="#主页文章节选-自动节选和文章页-description" class="headerlink" title="主页文章节选 (自动节选和文章页 description)"></a>主页文章节选 (自动节选和文章页 description)</h2><p>在 butterfly 里，有三种可供选择:</p>
<ol>
<li>description  只显示 description</li>
<li>both  优先选择 description，如果没有配置 description，则显示自动节选的内容</li>
<li>auto_excerpt  只显示自动节选</li>
</ol>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">300</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure>

<h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p>顶部图有 2 种配置：具体 url 和（留空，true 和 false，三个效果一样）#</p>
<h3 id="Page页"><a href="#Page页" class="headerlink" title="Page页"></a>Page页</h3><ul>
<li><p>当具体 <strong>url</strong> 时</p>
<p>主页的顶部图可以在 <code>Butterfly.yml</code> 设置 <code>index_img</code></p>
<p>archives 页的顶部图可以在 <code>Butterfly.yml</code> 设置 <code>archive_img</code></p>
<p>其他 <code>page</code> 页的顶部图可以在各自的 md 页面设置 <code>front-matter</code> 中的 <code>top_img</code></p>
<blockquote>
<p>页面如果没有设置各自的 top_img，则会显示 default_top_img 图片</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>当顶部图留空，<code>true</code> 和 <code>false</code></p>
<p>主页会显示纯颜色的顶部图</p>
<p>其他 page 的顶部图没有设置时，也会显示纯颜色的顶部图</p>
</li>
</ul>
<h3 id="Post页"><a href="#Post页" class="headerlink" title="Post页"></a>Post页</h3><p>post 页的顶部图会优先显示各自 front-matter 中的 <code>top_img</code>, </p>
<p>如果没有设置，则会缩略图（即各自 front-matter 中的 <code>cover</code>)，</p>
<p>如果没有则会显示 <code>default_top_img</code> 图片</p>
<h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>要为文章置顶，需要安装插件 (<a href="https://github.com/netcan/hexo-generator-index-pin-top"><strong>hexo-generator-index-pin-top</strong></a> 或者 <a href="https://github.com/hexo-next/hexo-generator-indexed"><strong>hexo-generator-indexed</strong></a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-indexed --save # 实测成功</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">npm install hexo-generator-index-pin-top  --save # 未成功</span><br></pre></td></tr></table></figure>



<p>如果使用 <code>hexo-generator-index-pin-top</code>, 需要先卸载掉 <code>hexo-generator-index</code>，然后在文章的 <code>front-matter</code> 区域里添加 <code>top: true</code> 属性来把这篇文章置顶</p>
<p>如果使用 <code>hexo-generator-indexed</code>, 需要先卸载掉 <code>hexo-generator-index</code>，然后在文章的 <code>front-matter</code> 区域里添加 <code>sticky: 1</code> 属性来把这篇文章置顶。数值越大，置顶的优先级越大</p>
<h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h2><p>文章的 markdown 文档上，在 <code>Front-matter</code> 添加 <code>cover</code>, 并填上要显示的图片地址</p>
<p>如果不配置 cover, 可以设置显示默认的 cover</p>
<p>如果不想在首页显示 cover, 可以设置为 <code>false</code></p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br></pre></td></tr></table></figure>

<p>当配置多张图片时，会随机选择一张作为 cover。此时写法应为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png</span></span><br></pre></td></tr></table></figure>

<h2 id="文章页相关配置"><a href="#文章页相关配置" class="headerlink" title="文章页相关配置"></a>文章页相关配置</h2><h3 id="文章meta显示"><a href="#文章meta显示" class="headerlink" title="文章meta显示"></a>文章meta显示</h3><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span>  <span class="comment"># created or updated or both 主页文章日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示标签</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 文章页日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示标签</span></span><br></pre></td></tr></table></figure>

<h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><p>为你的博客文章展示文章版权和许可协议。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure>

<p>由于 Hexo 4.1 开始，默认对网址进行解码，以至于如果是中文网址，会被解码，可设置 <code>decode: true</code> 来显示中文网址。</p>
<p>如果有文章（例如：转载文章）不需要显示版权，可以在文章 <code>Front-matter</code> 单独设置 <code>copyright: false</code></p>
<h3 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h3><p>在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置。</p>
<p>对于没有提供二维码的，可配置一张软件的 icon 图片，然后在 link 上添加相应的打赏链接。用户点击图片就会跳转到链接去。</p>
<p>link 可以不写，会默认为图片的链接。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sponsor/reward (打赏)</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/wechat.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">wechat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">alipay</span></span><br></pre></td></tr></table></figure>

<h3 id="文章隐藏"><a href="#文章隐藏" class="headerlink" title="文章隐藏"></a>文章隐藏</h3><p>如需要文章隐藏功能，请装插件 <a href="https://github.com/hexo-next/hexo-generator-indexed"><strong>hexo-generator-indexed</strong></a> 或者 <a href="https://github.com/printempw/hexo-hide-posts"><strong>hexo-hide-posts</strong></a></p>
<h3 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h3><p>在文章页，会有一个目录，用于显示 TOC。配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># toc (目录)</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># 是否显示TOC</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>   <span class="comment"># 是否显示章节数(自动给章节编号)</span></span><br><span class="line">  <span class="attr">auto_open:</span> <span class="literal">true</span> <span class="comment"># 进入文章页面时，是否自动打开 sidebar 显示TOC</span></span><br></pre></td></tr></table></figure>

<p>为特定的文章配置：</p>
<blockquote>
<p>在你的文章 md 文件的头部，加入 <code>toc_number</code>、<code>toc</code> 和 <code>auto_open</code>，并配置 true 或者 false 即可</p>
</blockquote>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>相关文章推荐的原理是根据文章 tags 的比重来推荐</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Related Articles</span></span><br><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">3</span> <span class="comment"># Number of posts displayed</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期显示创建日期或更新日期</span></span><br></pre></td></tr></table></figure>

<h3 id="文章锚点"><a href="#文章锚点" class="headerlink" title="文章锚点"></a>文章锚点</h3><p>开启文章锚点后，当你在文章页进行滚动时，文章链接会根据标题 ID 进行替换<br>(注意：每替换一次，会留下一个歷史记录。所以如果一篇文章有很多锚点的话，网页的歷史记录会很多。)</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="comment"># when you scroll in post, the URL will update according to header id.</span></span><br><span class="line"><span class="attr">anchor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Avatar (头像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span>  <span class="comment"># 头像是否一直转圈</span></span><br></pre></td></tr></table></figure>

<h2 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h2><p>可开启图片 Figcaption 描述文字显示</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># figcaption (是否开启图片描述)</span></span><br><span class="line"><span class="attr">photofigcaption:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Footer设置"><a href="#Footer设置" class="headerlink" title="Footer设置"></a>Footer设置</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Footer Settings (页脚设置)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># 博客起始时间</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2020</span>  </span><br><span class="line"><span class="comment"># 自定义页脚文本 支持HTML</span></span><br><span class="line"><span class="attr">footer_custom_text:</span>  <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">&lt;a</span> <span class="string">href=&quot;https://xxxxxxx.cn/&quot;&gt;blog&lt;/a&gt;!</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer_copyright:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ICP:</span> <span class="comment">#备案信息</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">/img/icp.png</span></span><br></pre></td></tr></table></figure>

<h2 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a>右下角按钮</h2><p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bottom right button (右下角按钮)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (簡繁轉換)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The text of a button</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">简</span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Time delay</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Simplified Chinese</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">&#x27;繁&#x27;</span></span><br><span class="line">  <span class="comment"># The text of the button when the language is Traditional Chinese</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">&#x27;简&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read Mode (阅读模式)</span></span><br><span class="line"><span class="attr">readmode:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dark mode (夜间模式)</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="侧边栏排版"><a href="#侧边栏排版" class="headerlink" title="侧边栏排版"></a>侧边栏排版</h2><p>配置 <code>butterfly.yml</code></p>
<p>可自行决定哪个项目需要显示，可决定位置，也可以设置不显示侧边栏。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aside (侧边栏)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># left or right 侧边栏位置</span></span><br><span class="line">  <span class="attr">card_author:</span> <span class="comment">## 作者卡片</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">  <span class="attr">card_announcement:</span> <span class="comment">## 公告</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">Welcome!</span></span><br><span class="line">  <span class="attr">card_categories:</span>  <span class="comment">## 分类</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">2</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">  <span class="attr">card_tags:</span>      <span class="comment">## 标签</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">card_recent_post:</span>  <span class="comment">## 最新文章</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">  <span class="attr">card_archives:</span>  <span class="comment">## 归档</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">  <span class="attr">card_webinfo:</span> <span class="literal">true</span> <span class="comment">## 网站信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># busuanzi count for PV / UV in site</span></span><br><span class="line"><span class="comment"># 不算子统计</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time difference between publish date and now (网站运行时间)</span></span><br><span class="line"><span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">publish_date:</span> <span class="number">7</span><span class="string">/28/2020</span> <span class="number">00</span><span class="string">:00:00</span></span><br></pre></td></tr></table></figure>

<h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>选用<a href="https://github.com/xCss/Valine"><strong>Valine</strong></a>，参考<a href="https://valine.js.org/quickstart.html"><strong>快速开始</strong></a> 配置 LeanCloud 应用，以及查看相应的配置说明。。</p>
<p>并配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># valine</span></span><br><span class="line"><span class="comment"># https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appId:</span>   <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span> <span class="comment"># i18n: zh-CN/zh-TW/en/ja</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">留下你的昵称和邮箱...可快速收到回复</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info (nick/mail/link)</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Record reviewer IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">emojiCDN:</span> <span class="comment"># emoji CDN</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">true</span> <span class="comment"># enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span></span><br><span class="line">  <span class="attr">requiredFields:</span> <span class="string">nick,mail</span> <span class="comment"># required fields (nick/mail)</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># dispaly comment count in top_img</span></span><br></pre></td></tr></table></figure>

<p><strong>邮件提醒</strong>使用配置，参考：<a href="https://github.com/zhaojun1998/Valine-Admin"><strong>Valine Admin</strong></a> 。</p>
<h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>选择 <a href="https://github.com/overtrue/share.js/"><strong>sharejs</strong></a> 就好</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Share.js</span></span><br><span class="line"><span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span></span><br></pre></td></tr></table></figure>

<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><h3 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h3><p>你需要安装 <a href="https://github.com/oncletom/hexo-algolia"><strong>hexo-algolia</strong></a> 或 <a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch"><strong>hexo-algoliasearch</strong></a>. 根据它们的说明文档去做相应的配置。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Algolia search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># if there are no result</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">&#x27;$&#123;hits&#125; results found in $&#123;time&#125; ms&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="本地搜索系统"><a href="#本地搜索系统" class="headerlink" title="本地搜索系统"></a>本地搜索系统</h3><p>你需要安装 <a href="https://github.com/PaicHyperionDev/hexo-generator-search"><strong>hexo-generator-search</strong></a>. 根据它的文档去做相应配置。注意格式只支持 xml。</p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># if there are no result</span></span><br></pre></td></tr></table></figure>

<h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wordcount (字数统计)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="图片查看模式"><a href="#图片查看模式" class="headerlink" title="图片查看模式"></a>图片查看模式</h2><p>选择 <code>fancybox</code></p>
<p>配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lightbox (图片大图查看模式)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># You can only choose one, or neither</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># medium-zoom</span></span><br><span class="line"><span class="comment"># https://github.com/francoischalifour/medium-zoom</span></span><br><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fancybox</span></span><br><span class="line"><span class="comment"># http://fancyapps.com/fancybox/3/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Snacker弹窗"><a href="#Snacker弹窗" class="headerlink" title="Snacker弹窗"></a>Snacker弹窗</h2><p>开启 <code>Snacker</code> ，配置 <code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Snackbar (Toast Notification 弹窗)</span></span><br><span class="line"><span class="comment"># https://github.com/polonel/SnackBar</span></span><br><span class="line"><span class="comment"># position 弹窗位置</span></span><br><span class="line"><span class="comment"># 可选 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right</span></span><br><span class="line"><span class="attr">snackbar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">bottom-left</span></span><br><span class="line">  <span class="attr">bg_light:</span> <span class="string">&#x27;#49b1f5&#x27;</span> <span class="comment"># The background color of Toast Notification in light mode</span></span><br><span class="line">  <span class="attr">bg_dark:</span> <span class="string">&#x27;#121212&#x27;</span> <span class="comment"># The background color of Toast Notification in dark mode</span></span><br></pre></td></tr></table></figure>

<h2 id="美化-特效"><a href="#美化-特效" class="headerlink" title="美化/特效"></a>美化/特效</h2><p>完整设置参考：<a href="https://demo.jerryc.me/posts/ceeb73f/#%E7%BE%8E%E5%8C%96-%E7%89%B9%E6%95%88">https://demo.jerryc.me/posts/ceeb73f/#美化-特效</a></p>
<h3 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mouse click effects: words (鼠標點擊效果: 文字)</span></span><br><span class="line"><span class="attr">ClickShowText:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">富强</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">民主</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">文明</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">和谐</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自由</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">平等</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">公正</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">法治</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">爱国</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">敬业</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">诚信</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">友善</span></span><br><span class="line">  <span class="attr">fontSize:</span> <span class="string">25px</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Theme-Butterfly(二) 主题页面</title>
    <url>/hexo/Hexo-Theme-Butterfly(%E4%BA%8C)-%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<blockquote>
<p>感谢原作者 <a href="https://jerryc.me/">JerryC</a> </p>
<p>由于主题更新，此文件中部分配置可能失效。请参考作者博客或文档：<a href="https://demo.jerryc.me/posts/dc584b87/">Butterfly 安装文档(二) 主题页面</a> </p>
</blockquote>
<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h2><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>title</strong></td>
<td>【必需】页面标题</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>【必需】页面创建日期</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>【必需】标签、分类和友情链接三个页面需要配置</td>
</tr>
<tr>
<td>description</td>
<td>页面描述（需要设置主页文章节选）</td>
</tr>
<tr>
<td>keywords</td>
<td>页面关键字</td>
</tr>
<tr>
<td>comments</td>
<td>是否要显示页面评论模块，默认true</td>
</tr>
<tr>
<td>top_img</td>
<td>页面顶部图片</td>
</tr>
</tbody></table>
<p>查看完整参数：<a href="https://demo.jerryc.me/posts/dc584b87/#Page-Front-matter">Page Front-matter</a></p>
<h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><table>
<thead>
<tr>
<th>标签</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>title</strong></td>
<td>【必需】文章标题</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>tags</td>
<td>文章标签</td>
</tr>
<tr>
<td>categories</td>
<td>文章分类</td>
</tr>
<tr>
<td>description</td>
<td>文章描述（没看到哪儿显示……）</td>
</tr>
<tr>
<td></td>
<td>文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td>
</tr>
<tr>
<td>keywords</td>
<td>文章关键字</td>
</tr>
<tr>
<td>comments</td>
<td>显示文章评论模块，默认true</td>
</tr>
<tr>
<td>top_img</td>
<td>页面顶部图片</td>
</tr>
</tbody></table>
<p>查看完整参数：<a href="https://demo.jerryc.me/posts/dc584b87/#Post-Front-matter">Post Front-matter</a></p>
<h1 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h1><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page tags</code></li>
<li>你会找到 <code>source/tags/index.md</code> 这个文件</li>
<li>根据 <a href="#Page-Front-matter"><strong>Page Front-matter</strong></a> 修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签页</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: tags</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: /img/page-tags-top.png</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>

<h1 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h1><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page categories</code></li>
<li>你会找到 <code>source/categories/index.md</code> 这个文件</li>
<li>根据 <a href="#Page-Front-matter"><strong>Page Front-matter</strong></a> 修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: /img/page-categories-top.jpg</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>

<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><h2 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建友情链接页面</h2><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page link</code></li>
<li>你会找到 <code>source/link/index.md</code> 这个文件</li>
<li>根据 <a href="#Page-Front-matter"><strong>Page Front-matter</strong></a> 修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: link</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: /img/page-link-top.jpg</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure>

<h2 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a>友情链接添加</h2><p>在 Hexo 博客目录中的 <code>source/_data</code>，创建一个文件 <code>link.yml</code>，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- class_name: 友情链接簇</span><br><span class="line">  class_desc: 友情链接簇描述</span><br><span class="line">  link_list:</span><br><span class="line">    1:</span><br><span class="line">      name: 链接名</span><br><span class="line">      link: 链接地址</span><br><span class="line">      avatar: 链接头像</span><br><span class="line">      descr: 链接描述</span><br><span class="line">    2:</span><br><span class="line">      name: 链接名</span><br><span class="line">      link: 链接地址</span><br><span class="line">      avatar: 链接头像</span><br><span class="line">      descr: 链接描述</span><br><span class="line"></span><br><span class="line">- class_name: 网站</span><br><span class="line">  class_desc: 值得推荐的网站</span><br><span class="line">  link_list:</span><br><span class="line">    - name: Youtube</span><br><span class="line">      link: https:&#x2F;&#x2F;www.youtube.com&#x2F;</span><br><span class="line">      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;9ZkGg8v3azHJfM1.png</span><br><span class="line">      descr: 视频网站</span><br><span class="line">    - name: Weibo</span><br><span class="line">      link: https:&#x2F;&#x2F;www.weibo.com&#x2F;</span><br><span class="line">      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;TLJBum386vcnI1P.png</span><br><span class="line">      descr: 中国最大社交分享平台</span><br><span class="line">    - name: Twitter</span><br><span class="line">      link: https:&#x2F;&#x2F;twitter.com&#x2F;</span><br><span class="line">      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;5VyHPQqR6LWF39a.png</span><br><span class="line">      descr: 社交分享平台</span><br></pre></td></tr></table></figure>

<p><code>class_name</code> 和 <code>class_desc</code> 支持 <code>html</code> 格式书写，如不需要，也可以留空。</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><p>音乐界面使用了插件  。使用方法参考 <a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md"><strong>插件文档</strong></a> 。</p>
<p>首先在 Hexo 根目录 <code>_config</code> 里配置 <code>asset_inject</code> 为 <code>false</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>然后在你需要使用 <code>aplayer</code> 的页面 <code>Front-matter</code> 添加</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">aplayer: true</span><br></pre></td></tr></table></figure>

<p>这样只会在需要 aplayer 的页面插入 js 和 css。</p>
<h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><p>电影界面使用了插件 <a href="https://github.com/mythsman/hexo-douban"><strong>hexo-douban</strong></a> ，使用方法参考插件文档。</p>
<h1 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h1><p>主题内置了一个简单的 404 页面，可在设置中开启，<code>butterfly.yml</code> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;Page not found&#x27;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">/img/page-404.jpg</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本地浏览： <a href="http://localhost:4000/404.html">http://localhost:4000/404.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Hexo+GitHub搭建个人博客</title>
    <url>/hexo/Linux%E4%B8%8Bgithub+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# uname -a</span><br><span class="line">Linux iZwz9c74ta983j746ynevpZ 3.10.0-1127.10.1.el7.x86_64 #1 SMP Wed Jun 3 14:28:03 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="更新源（可略过）"><a href="#更新源（可略过）" class="headerlink" title="更新源（可略过）"></a>更新源（可略过）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 备份原 源文件</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# mv /etc/yum.repos.d /etc/yum.repos.d.bak</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZr ~]# mkdir /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 阿里云</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo --no-check-certificate</span><br><span class="line"></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum clean all</span><br><span class="line"></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum makecache</span><br><span class="line"></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum update -y</span><br></pre></td></tr></table></figure>

<h2 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# yum install -y git</span><br></pre></td></tr></table></figure>

<h3 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h3><h4 id="node-js安装包下载"><a href="#node-js安装包下载" class="headerlink" title="node.js安装包下载"></a>node.js安装包下载</h4><p><strong>网址：</strong> <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<p><strong>阿里云镜像：</strong> <a href="https://npm.taobao.org/mirrors/node">https://npm.taobao.org/mirrors/node</a></p>
<p>下载对应二进制安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# wget https://npm.taobao.org/mirrors/node/v14.6.0/node-v14.6.0-linux-x64.tar.gz --no-check-certificate</span><br></pre></td></tr></table></figure>

<h4 id="node-js安装部署"><a href="#node-js安装部署" class="headerlink" title="node.js安装部署"></a>node.js安装部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# tar -zxf node-v14.6.0-linux-x64.tar.gz </span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# mv node-v14.6.0-linux-x64 /opt/nodejs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软连接</span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# ln -s /opt/nodejs/bin/node /usr/local/bin/node </span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# ln -s /opt/nodejs/bin/npm /usr/local/bin/npm </span><br></pre></td></tr></table></figure>

<h3 id="Hexo安装部署"><a href="#Hexo安装部署" class="headerlink" title="Hexo安装部署"></a>Hexo安装部署</h3><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm install hexo-cli -g</span><br><span class="line">/opt/nodejs/bin/hexo -&gt; /opt/nodejs/lib/node_modules/hexo-cli/bin/hexo</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.1.2 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">+ hexo-cli@4.0.0</span><br><span class="line">added 61 packages from 315 contributors in 46.255s</span><br></pre></td></tr></table></figure>

<p>若安装hexo报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm install hexo-cli -g</span><br><span class="line">npm ERR! code CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! errno CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: certificate is not yet valid</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2010-03-31T20_55_08_156Z-debug.log</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm install hexo-cli -g --no-check-certificate</span><br><span class="line">npm ERR! code CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! errno CERT_NOT_YET_VALID</span><br><span class="line">npm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: certificate is not yet valid</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2010-03-31T20_55_35_518Z-debug.log</span><br></pre></td></tr></table></figure>

<p>原因是https的自签名失败，临时解决办法：关闭ssl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# npm config set strict-ssl false</span><br></pre></td></tr></table></figure>

<h4 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h4><p>将 hexo 命令添加到全局，采用软连接方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# ln -s /opt/nodejs/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure>

<h2 id="Hexo博客环境部署"><a href="#Hexo博客环境部署" class="headerlink" title="Hexo博客环境部署"></a>Hexo博客环境部署</h2><h3 id="初始化Hexo博客根目录"><a href="#初始化Hexo博客根目录" class="headerlink" title="初始化Hexo博客根目录"></a>初始化Hexo博客根目录</h3><p><strong><em>强烈建议先换npm源！！！见：<a href="#%E6%9B%B4%E6%8D%A2npm%E6%BA%90">更换npm源</a></em></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# mkdir /var/hexoblog</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ ~]# hexo init /var/hexoblog/</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">Submodule &#x27;themes/landscape&#x27; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#x27;themes/landscape&#x27;</span><br><span class="line">Cloning into &#x27;themes/landscape&#x27;...</span><br><span class="line">remote: Enumerating objects: 8, done.</span><br><span class="line">remote: Counting objects: 100% (8/8), done.</span><br><span class="line">remote: Compressing objects: 100% (6/6), done.</span><br><span class="line">remote: Total 1071 (delta 1), reused 5 (delta 1), pack-reused 1063</span><br><span class="line">Receiving objects: 100% (1071/1071), 3.22 MiB | 12.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (586/586), done.</span><br><span class="line">Submodule path &#x27;themes/landscape&#x27;: checked out &#x27;73a23c51f8487cfcd7c6deec96ccc7543960d350&#x27;</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line">[ .................] - fetchMetadata: sill pacote range manifest for kind-of@^3.0.2 fetched in 386ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>卡住在这……，猜测是npm源问题，更换国内源</p>
<h4 id="更换npm源"><a href="#更换npm源" class="headerlink" title="更换npm源"></a>更换npm源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看 默认源</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# npm config get registry</span><br><span class="line">https://registry.npmjs.org/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 更换阿里源</span></span></span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# npm config set registry https://registry.npm.taobao.org</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# npm config get registry</span><br><span class="line">https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<p>若init失败，<strong>须清空文件夹下内容，ls -a 查看还有一个影藏文件</strong>，再次初始化。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# rm ./* -rf</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# ls -a</span><br><span class="line">.  ..  .gitignore</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# rm .gitignore -f</span><br></pre></td></tr></table></figure>

<h3 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h3><p>生成静态文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# hexo g</span><br><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# ls -l </span><br><span class="line">total 132</span><br><span class="line">-rw-r--r--   1 root root  2367 Jul 28 15:54 _config.yml</span><br><span class="line">-rw-r--r--   1 root root 25111 Jul 28 15:59 db.json</span><br><span class="line">drwxr-xr-x 189 root root  4096 Jul 28 15:54 node_modules</span><br><span class="line">-rw-r--r--   1 root root   581 Jul 28 15:59 package.json</span><br><span class="line">-rw-r--r--   1 root root 74694 Jul 28 15:54 package-lock.json</span><br><span class="line">drwxr-xr-x   7 root root  4096 Jul 28 15:59 public        ## 存放生成的静态文件</span><br><span class="line">drwxr-xr-x   2 root root  4096 Jul 28 15:54 scaffolds</span><br><span class="line">drwxr-xr-x   3 root root  4096 Jul 28 15:54 source</span><br><span class="line">drwxr-xr-x   3 root root  4096 Jul 28 15:54 themes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<h3 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br><span class="line">或</span><br><span class="line">http:&#x2F;&#x2F;服务器IP地址:4000&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h2><h3 id="创建github-io仓储"><a href="#创建github-io仓储" class="headerlink" title="创建github.io仓储"></a>创建github.io仓储</h3><p>新建仓库，仓库名为：<code>your_github_user_name.github.io</code></p>
<h3 id="GitHub-Pages-默认已开启"><a href="#GitHub-Pages-默认已开启" class="headerlink" title="GitHub Pages(默认已开启)"></a>GitHub Pages(默认已开启)</h3><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><h3 id="浏览器访问-1"><a href="#浏览器访问-1" class="headerlink" title="浏览器访问"></a>浏览器访问</h3><blockquote>
<p><code>https://your_github_user_name.github.io</code></p>
</blockquote>
<h3 id="添加SSH-keys-已有忽略"><a href="#添加SSH-keys-已有忽略" class="headerlink" title="添加SSH keys(已有忽略)"></a>添加SSH keys(已有忽略)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成SSH Key，等待输入按下 Enter 回车键三次</span></span><br><span class="line">ssh-keygen -t rsa  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制公钥 添加到 github</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h3 id="测试GitHub连接"><a href="#测试GitHub连接" class="headerlink" title="测试GitHub连接"></a>测试GitHub连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz9c74ta983j746ynevpZ hexoblog]# ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27;github.com (52.74.223.119)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">RSA key fingerprint is MD5:16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Hi JakeLin0fly! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<h3 id="设置Github账户信息"><a href="#设置Github账户信息" class="headerlink" title="设置Github账户信息"></a>设置Github账户信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot; </span><br><span class="line">git config --global user.email &quot;GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Hexo部署到GitHub-Pages"><a href="#Hexo部署到GitHub-Pages" class="headerlink" title="Hexo部署到GitHub Pages"></a>Hexo部署到GitHub Pages</h2><h3 id="Hexo-config-yml修改"><a href="#Hexo-config-yml修改" class="headerlink" title="Hexo _config.yml修改"></a>Hexo _config.yml修改</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h3 id="同步到GitHub"><a href="#同步到GitHub" class="headerlink" title="同步到GitHub"></a>同步到GitHub</h3><p>需要安装插件 <code>hexo-deployer-git</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>Hexo命令，详细命令参考：<a href="https://hexo.io/docs/commands">https://hexo.io/docs/commands</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo cl    ## 删除 public/  db.json</span><br><span class="line">hexo g    ## 构建项目 主要是生成 public/  db.json</span><br><span class="line">hexo d    ## 部署到配置文件中设置的仓库</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-theme-next主题配置</title>
    <url>/hexo/hexo-theme-next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>2020-08-02 版本信息</p>
<blockquote>
<p>nodejs : v12.18.3</p>
<p>hexo: 5.0.0<br> hexo-cli: 4.1.0</p>
<p>NexT :  <a href="https://github.com/next-theme/hexo-theme-next/releases/tag/v8.0.0-rc.5">v8.0.0-rc.5</a></p>
</blockquote>
<h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p><img src="https://i.loli.net/2020/08/03/IFlo6fVkXJ8HpUv.png" alt="Next主题首页截图.png"></p>
<p><img src="https://i.loli.net/2020/08/03/X1WITxsLjgeuSpK.png" alt="Next主题博客界面截图.png"></p>
<h1 id="获取Next"><a href="#获取Next" class="headerlink" title="获取Next"></a>获取Next</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h1 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h1><p>根目录 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h1 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h1><h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p>将主题配置文件放在 <code>网站很目录</code> 下，命名为 <code>_config.next.yml</code> ，详情见：<a href="https://theme-next.js.org/docs/getting-started/configuration">Configuration</a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp themes/next/_config.yml ./_config.next.yml</span><br></pre></td></tr></table></figure>

<h2 id="选择主题风格"><a href="#选择主题风格" class="headerlink" title="选择主题风格"></a>选择主题风格</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse   #预览参考 https://theme-next.js.org/muse/</span></span><br><span class="line"><span class="comment">#scheme: Mist     #预览参考 https://theme-next.js.org/mist/</span></span><br><span class="line"><span class="comment">#scheme: Pisces #预览参考 https://theme-next.js.org/pisces/</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span>  <span class="comment">#预览参考 https://theme-next.js.org/</span></span><br></pre></td></tr></table></figure>

<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment"># 显示图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span> <span class="comment"># 显示统计信息</span></span><br></pre></td></tr></table></figure>

<h3 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h3><p>生成编辑<code>Hexo/source/tags/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: tags</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h3><p>生成编辑<code>Hexo/source/categories/index.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-07-29</span><br><span class="line">type: categories</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">https://i.loli.net/2020/07/31/OZl2JxuSRrweIk5.jpg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>      <span class="comment"># 显示社交图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">true</span>  <span class="comment"># 只显示图标，不显示文字</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="首页显示的文章属性"><a href="#首页显示的文章属性" class="headerlink" title="首页显示的文章属性"></a>首页显示的文章属性</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span> <span class="comment"># 设为true 可以一行显示，文章的所有属性</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># 显示修改的时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">false</span> <span class="comment"># 设true时，如果创建时间和修改时间一样则显示一个时间</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>  <span class="comment"># 显示分类信息</span></span><br></pre></td></tr></table></figure>

<h2 id="footer信息"><a href="#footer信息" class="headerlink" title="footer信息"></a>footer信息</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2019</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Powered by Hexo &amp; NexT</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="目录设置"><a href="#目录设置" class="headerlink" title="目录设置"></a>目录设置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果为true，则所有标题将在标题宽度长于边栏宽度的情况下放在下一行。</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果为true，则将显示帖子中所有级别的TOC，而不是帖子中已激活的部分。</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span>  <span class="comment"># 字体转动 鬼畜。。。。</span></span><br><span class="line">  <span class="comment">#comment: Donate comment here.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span> <span class="comment"># 打赏二维码链接</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">https://i.loli.net/2020/08/01/na8BbXF1ow63OIJ.png</span> </span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">https://i.loli.net/2020/08/01/NALchOTe3vM8aYy.jpg</span></span><br></pre></td></tr></table></figure>

<h2 id="文章版权声明"><a href="#文章版权声明" class="headerlink" title="文章版权声明"></a>文章版权声明</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line"><span class="comment">#    light: default</span></span><br><span class="line"><span class="comment">#    dark: tomorrow-night</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">atom-one-dark-reasonable</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">atom-one-dark-reasonable</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="comment"># light: prism</span></span><br><span class="line">    <span class="comment"># dark: prism-dark</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism-vsc-dark-plus</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-vsc-dark-plus</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 复制按钮的开关</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>

<h2 id="GitHub-Banner"><a href="#GitHub-Banner" class="headerlink" title="GitHub_Banner"></a>GitHub_Banner</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="comment"># 你的GitHub地址</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>

<h2 id="配置本地搜索"><a href="#配置本地搜索" class="headerlink" title="配置本地搜索"></a>配置本地搜索</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="busuanzi统计"><a href="#busuanzi统计" class="headerlink" title="busuanzi统计"></a>busuanzi统计</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                     <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>             <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                 <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                  <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>

<h2 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h2><p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-word-counter --save</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-word-counter</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span> <span class="comment"># false会显示一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span> <span class="comment"># 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 底部footer是否显示字数统计属性文字</span></span><br></pre></td></tr></table></figure>

<h1 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h1><p>首先在 NexT 的配置文件 <code>_config.next.yml</code> 中取消下列对应样式文件的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source&#x2F;_data&#x2F;head.swig</span><br><span class="line">  #header: source&#x2F;_data&#x2F;header.swig</span><br><span class="line">  #sidebar: source&#x2F;_data&#x2F;sidebar.swig</span><br><span class="line">  #postMeta: source&#x2F;_data&#x2F;post-meta.swig</span><br><span class="line">  #postBodyEnd: source&#x2F;_data&#x2F;post-body-end.swig</span><br><span class="line">  #footer: source&#x2F;_data&#x2F;footer.swig</span><br><span class="line">  #bodyEnd: source&#x2F;_data&#x2F;body-end.swig</span><br><span class="line">  #variable: source&#x2F;_data&#x2F;variables.styl</span><br><span class="line">  #mixin: source&#x2F;_data&#x2F;mixins.styl</span><br><span class="line">  #style: source&#x2F;_data&#x2F;styles.styl</span><br></pre></td></tr></table></figure>

<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p>取消 <code>_config.next.yml</code> 中 <code>style: source/_data/styles.styl</code> 注释。</p>
<p>创建 <code>source/_data/styles.styl</code> ：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置背景图片</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    # 图片地址</span><br><span class="line">    background:url(https://i.loli.net/2020/08/02/pjAgE9dIcTZSCoB.jpg); </span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; <span class="comment">//不重复</span></span><br><span class="line">    <span class="attribute">background-size</span>: cover;      <span class="comment">//填充</span></span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h2><p><code>source/_data/styles.styl</code> 中增加样式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sidebar css </span></span><br><span class="line">.sidebar&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="圆角设置"><a href="#圆角设置" class="headerlink" title="圆角设置"></a>圆角设置</h2><p>取消 <code>_config.next.yml</code> 中 <code>style: source/_data/variables.styl</code> 注释。</p>
<p>创建 <code>source/_data/variables.styl</code> ：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 15px 15px 15px 15px;</span><br><span class="line"><span class="variable">$border</span>-radius       </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>valine评论</title>
    <url>/hexo/valine%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>站点配置文件 <code>url</code> 地加 <code>http</code> 头，否则文章末尾【本文链接】地址为：<strong>域名/域名/xxxxxxx</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://jakelin.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>记录类型：CNAME</p>
<ol start="2">
<li>主机记录：@</li>
<li>记录值：Github Pages项目域名</li>
</ol>
</li>
</ol>
<h2 id="注册LeanClound，获取APP-ID-和-APP-Key"><a href="#注册LeanClound，获取APP-ID-和-APP-Key" class="headerlink" title="注册LeanClound，获取APP ID 和 APP Key"></a>注册LeanClound，获取APP ID 和 APP Key</h2><p>注册链接： <a href="https://leancloud.cn/dashboard/login.html#/signup">LeanClound注册</a> </p>
<p>【创建应用】-&gt;【随便起个名】-&gt;【开发版】-&gt;[创建]</p>
<p><img src="https://i.loli.net/2020/08/03/kNErsH8PezWO1uj.png" alt="LeanClound创建应用.png"></p>
<p><img src="https://i.loli.net/2020/08/03/uxdiBNf6g4MKwOs.png" alt="获取key.png"></p>
<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">这里填</span> <span class="string">AppID</span>  <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">这里填</span> <span class="string">AppKey</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&#x27;ヾﾉ≧∀≦)o来啊，快活啊!&#x27;</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">false</span> <span class="comment"># Whether to enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [] <span class="comment"># Set required fields: [&#x27;nick&#x27;] | [&#x27;nick&#x27;,&#x27;mail&#x27;]</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>

<h2 id="添加邮件提醒"><a href="#添加邮件提醒" class="headerlink" title="添加邮件提醒"></a>添加邮件提醒</h2><p>见： <a href="https://tding.top/archives/ed8b904f.html">小丁的个人博客–Hexo-NexT 配置 Valine</a> </p>
<h2 id="云引擎绑定域名"><a href="#云引擎绑定域名" class="headerlink" title="云引擎绑定域名"></a>云引擎绑定域名</h2><p><font color=red><strong>强调：需要先备案！！！</strong></font></p>
<ol>
<li><p>环境变量设置</p>
<p>【云引擎】–&gt;【设置】–&gt;【添加环境变量】</p>
<blockquote>
<p>变量名：<code>ADMIN_URL</code></p>
<p>变量值：<code>http://你的leancloud域名主机记录.主域名</code>    如：<a href="http://leancloud.jakelin.cn/">http://leancloud.jakelin.cn</a></p>
</blockquote>
</li>
<li><p>云引擎域名绑定</p>
<p>【设置】–&gt;【域名绑定】–&gt;【云引擎、ClientEngine 域名】–&gt;【绑定新域名】</p>
<p>就上面环境变量的值，即是你需要绑定的域名</p>
<blockquote>
<p><code>http://你的leancloud域名主机记录.主域名</code></p>
</blockquote>
</li>
<li><p>域名解析</p>
<p>到域名所在提供商添加域名解析</p>
<blockquote>
<p>主机记录：<code>你的leancloud域名主机记录</code>（注：和上面的一致）</p>
<p>记录类型：<code>CNAME</code></p>
<p>记录值：上一步绑定新域名产生的记录值</p>
</blockquote>
<p><img src="https://i.loli.net/2020/08/15/cqtrpWxbSQRDkgG.png" alt="leancloud-域名解析记录值.png"></p>
</li>
<li><p>添加用户</p>
<p>添加leancloud评论管理用户。</p>
<p>【存储】–&gt;【结构化数据】–&gt;【_User】–&gt;【添加行】</p>
<p><strong><em>注：没有使用用户名成功登录，仅添加了邮箱后通过邮箱成功登录</em></strong></p>
</li>
<li><p>重新部署</p>
<p>修改了环境变量，须重新部署才能生效。</p>
<p>【云引擎】–&gt;【部署】–&gt;[重启]</p>
</li>
<li><p>登录评论管理</p>
<p>地址：<code>http://你的leancloud域名主机记录.主域名</code></p>
</li>
</ol>
<h2 id="休眠策略"><a href="#休眠策略" class="headerlink" title="休眠策略"></a>休眠策略</h2><p><strong>【写前面】</strong><font color=red><strong><em>定时任务每天早上不能唤醒，然后一天都在休眠。也就是早上唤醒一次后，定时任务才能正常执行！！！</em></strong></font>通过浏览器访问评论管理系统，会唤醒leanCloud。因此，我直接使用<strong>linux定时任务</strong>每天第一次唤醒leanCloud，然后<strong>leanCloud的定时任务</strong>负责一天的间隔时间唤醒。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试 curl</span></span><br><span class="line">/usr/bin/curl 你的leancloud评论管理地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入 每天7:59执行 访问网址</span></span><br><span class="line">59 7 * * * /usr/bin/curl 你的leancloud评论管理地址</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意</strong></font>：评论地址注意是 <strong>http</strong> 不是 https（因为我没有SSL，使用https无法唤醒）。</p>
<p><strong>免费版</strong>的 LeanCloud 容器，是有<strong>强制性休眠策略</strong>的，不能 24 小时运行：</p>
<ul>
<li>每天必须休眠 6 个小时</li>
<li>30 分钟内没有外部请求，则休眠。</li>
<li>休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。</li>
</ul>
<p>我设置的是定时任务，一个<strong>定时唤醒</strong>，一个<strong>定时检测</strong>过去24小时是否有漏发邮件。</p>
<p><strong><em>注意：还是可能出现问题，遇到了定时唤醒失败的情况，参考过GitHub Action，但是貌似就运行了一下就没了。。。</em></strong></p>
<p><img src="https://i.loli.net/2020/08/15/ZlauFhVYMsoykgE.png" alt="leancloud-定时任务.png"></p>
<p><img src="https://i.loli.net/2020/08/15/rF6YfotjdZgXxSm.png" alt="leancloud-定时任务resend-mails__.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://valine.js.org/quickstart.html">Valine-快速开始</a></p>
<p><a href="https://www.cnblogs.com/huanhao/p/emailvaline.html">Valine评论系统邮件提醒</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-theme-next提交给搜索引擎</title>
    <url>/hexo/hexo-theme-next%E6%8F%90%E4%BA%A4%E7%BB%99%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="站点地图生成"><a href="#站点地图生成" class="headerlink" title="站点地图生成"></a>站点地图生成</h1><ol>
<li><p>插件安装</p>
<ul>
<li><p>Google站点地图插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>百度站点地图插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修改站点配置文件</p>
</li>
</ol>
<p><code>_config.yml</code> 中加入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span> <span class="comment"># 提交给Google</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span> <span class="comment"># 提交给百度</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>重新构建项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="提交站点地图"><a href="#提交站点地图" class="headerlink" title="提交站点地图"></a>提交站点地图</h1><p>直接参考：<a href="https://fanandjiu.com/Hexo%E9%97%AE%E9%A2%98-%E6%8F%90%E4%BA%A4%E7%AB%99%E7%82%B9%E7%BB%99%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BB%A5%E5%8F%8ASEO/">Hexo问题-提交站点给搜索引擎以及SEO</a> </p>
<p><strong><em>注意：在Google进行DNS记录验证域名所有权时，因为阿里云域名解析的记录值不允许两个 <code>@</code> ，但将域名记录值 <code>@</code> 用以验证，验证完后再更改记录值是可行的。验证后需要一定的时间才能google搜索到！</em></strong> </p>
<p><img src="https://i.loli.net/2020/08/06/SBGhud2oF7V4ZKj.png" alt="DNS验证域名所有权-Google.png"></p>
<h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>参考：<a href="https://theme-next.js.org/docs/third-party-services/statistics-and-analytics.html">Statistics and Analytics</a> </p>
<h2 id="Google-分析"><a href="#Google-分析" class="headerlink" title="Google 分析"></a>Google 分析</h2><ol>
<li><p>创建一个 <a href="https://analytics.google.com/">Google Analytics</a> 账号</p>
</li>
<li><p>得到一个 <code>跟踪ID</code> ：UA-xxxxxx</p>
</li>
<li><p>修改Next配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span> <span class="string">你的跟踪ID</span> <span class="comment"># &lt;app_id&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="百度分析"><a href="#百度分析" class="headerlink" title="百度分析"></a>百度分析</h2><ol>
<li><p>去<a href="https://tongji.baidu.com/web/welcome/login">百度统计</a>，新增一个网站</p>
</li>
<li><p>复制统计代码中的 <code>hm.src = &quot;https://hm.baidu.com/hm.js?[这里的脚本ID]&quot;</code></p>
</li>
<li><p>修改Next配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Baidu Analytics</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">脚本ID</span> <span class="comment"># &lt;app_id&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>“三次握手”与“四次挥手”</title>
    <url>/net/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E2%80%9D%E4%B8%8E%E2%80%9C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D/</url>
    <content><![CDATA[<p>TCP是面向连接的协议。运输连接是用来传送TCP报文的。运输链接就有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>、<strong>连接释放</strong>。</p>
<h2 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h2><p>TCP建立连接过程中的三个重要问题：</p>
<ol>
<li>要使每一方能够确知对方的存在；</li>
<li>要允许双方协商一些参数（eg：最大窗口值）；</li>
<li>能够对运输实体资源（eg：缓存大小、连接表中的项目等）进行分配。</li>
</ol>
<p>TCP连接采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户端</strong>。被动等待连接建立的应用程序叫做<strong>服务器</strong>。</p>
<img src="https://i.loli.net/2020/10/25/BUtYroWNihSe6V7.png" alt="TCP三次握手.png" style="zoom: 67%;" />

<p>一开始，服务器进程创建<strong>传输控制块 TCB</strong>，准备接受客户进程的连接请求。然后服务器进程处于 <font color=red><strong>LISTEN</strong></font> 状态，等待客户的连接请求。</p>
<ol>
<li><p>客户进程创建<strong>传输控制块 TCB</strong>。向服务器进程发送连接请求报文段（同步位 <code>SYN=1</code> ，同时选择一个随机的初始序号值 <code>seq=x</code> ），客户进程进入  <font color=blue><strong>SYN_SENT</strong></font> 状态；</p>
<blockquote>
<p><strong>序号值</strong>是用来标记TCP数据流中的每一个字节的。<strong>同步报文段</strong>，不携带数据，但仍要<strong>消耗掉一个序号</strong>。</p>
</blockquote>
</li>
<li><p>服务器进程接收到连接请求报文段，如果同意建立连接，则向客户进程发送确认（同步位 <code>SYN=1</code>，确认位 <code>ACK=1</code>，确认号 <code>ack=x+1</code>，同时也为自己选择一个初始序号 <code>seq=y</code>），服务器进程进入  <font color=red><strong>SYN_RCVD</strong></font> 状态；</p>
<blockquote>
<p>同步报文段，不携带数据，但仍要<strong>消耗掉一个序号</strong>。报文段的数据可理解为：<strong>我已收到 x，期待收到 x+1</strong>。</p>
</blockquote>
</li>
<li><p>客户进程收到确认后，还要向服务器进程发送确认，客户进程进入  <font color=blue><strong>ESTABLISED</strong></font> 状态。</p>
<blockquote>
<p> 如果不携带数据则不消耗序号，即不带序号。</p>
</blockquote>
</li>
<li><p>服务器进程收到确认后，也进入  <font color=red><strong>ESTABLISED</strong></font> 状态。TCP连接建立，接下来进行数据传送。</p>
</li>
</ol>
<p>TCP建立连接的过程，有三个报文段，故该过程叫做<strong>三报文握手</strong>，即<strong>“三次握手”</strong>。如果将服务器进程确认报文段拆分成两个报文段：1、确认报文段（<code>ACK=1, ack=x+1</code>），2、同步报文（<code>SYN=1, seq=1</code>）。这样的过程就变成了<strong>四报文握手</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo tcpdump -i eth0 -nt <span class="string">&#x27;(src 172.20.12.30 and dst 172.20.12.27) or (src 172.20.12.27 and dst 172.20.12.30)&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、同步报文段：SYN=1, seq=3411381857 </span></span><br><span class="line">IP 172.20.12.27.38012 &gt; 172.20.12.30.80: Flags [S], seq 3411381857, win 29200, options [mss 1460,sackOK,TS val 3763862309 ecr 0,nop,wscale 7], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、同步报文段：SYN=1, seq=3063678231, ack=3411381858</span></span><br><span class="line">IP 172.20.12.30.80 &gt; 172.20.12.27.38012: Flags [S.], seq 3063678231, ack 3411381858, win 28960, options [mss 1460,sackOK,TS val 2338707997 ecr 3763862309,nop,wscale 7], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、确认报文段：ACK=1, ack=1   没有携带数据不消耗序号，没-S参数，ack值是相对偏移值</span></span><br><span class="line">IP 172.20.12.27.38012 &gt; 172.20.12.30.80: Flags [.], ack 1, win 229, options [nop,nop,TS val 3763862310 ecr 2338707997], length 0</span><br></pre></td></tr></table></figure>

<h2 id="TCP释放连接"><a href="#TCP释放连接" class="headerlink" title="TCP释放连接"></a>TCP释放连接</h2><p><strong>释放连接时中断端可以是客户端，也可以是服务器端</strong>。假设是客户进程发起中断连接请求。</p>
<img src="https://i.loli.net/2020/10/25/A7n6OUMl8YfCpjg.png" alt="TCP四次挥手.png" style="zoom:67%;" />

<p>一开始，客户进程和服务器进程均处于 <font color=green><strong>ESTABLISED</strong></font> 状态。</p>
<ol>
<li><p>客户进程向服务器进程发出TCP连接释放报文段（终止控制位 <code>FIN=1</code>，序号 <code>seq=u</code>），并停止再发送数据。客户进程进入 <font color=blue><strong>FIN-WAIT-1</strong></font> 状态。</p>
<blockquote>
<p>不携带数据，但也要消耗掉一个序号。</p>
</blockquote>
</li>
<li><p>服务器进程收到连接释放报文段后，向客户进程发送确认（<code>ACK=1, ack=u+1, seq=v</code>）。服务器进程进入 <font color=red><strong>CLOSE-WAIT</strong></font> 状态，**<em>半关闭**</em>状态。此时，服务器进程向客户进程发送还未传输完的数据。</p>
<blockquote>
<p>客户进程没有数据要发送，但若服务器进程发送数据，客户进程仍要接收。</p>
<p>实际抓包的数据：<code>ACK=1, ack=u</code>。</p>
</blockquote>
</li>
<li><p>客户进程收到确认后，进入 <font color=blue><strong>FIN-WAIT-2</strong></font> 状态，等待服务器进程发出释放连接请求报文段。</p>
</li>
<li><p>若服务器进程已经没有要向客户进程发送的数据，其通知TCP释放连接。向客户进程发送释放连接请求（<code>FIN=1, ACK=1, ack=u+1, seq=w</code>）。服务器进程进入 <font color=red><strong>LAST-ACK</strong></font> 状态，等待客户进程的确认。</p>
</li>
<li><p>客户进程收到服务器进程的释放连接请求报文，对其进行确认（<code>ACK=1, ack=w+1, seq=u+1</code>）。进入 <font color=blue><strong>TIME-WAIT</strong></font> 状态，等待 **<code>2MSL</code>**，客户进程TCP连接最终关闭。</p>
</li>
<li><p>服务器进程收到客户进程的确认，进入 <font color=red><strong>CLOSED</strong></font> 状态。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、结束报文段：FIN=1, ACK=1, seq=484, ack=5</span></span><br><span class="line">IP 172.20.12.30.80 &gt; 172.20.12.27.38728: Flags [F.], seq 484, ack 5, win 227, options [nop,nop,TS val 2340566655 ecr 3765720984], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、确认报文段：ACK=1, ack=484  注意：此处ack值没有+1 </span></span><br><span class="line">IP 172.20.12.27.38728 &gt; 172.20.12.30.80: Flags [.], ack 484, win 237, options [nop,nop,TS val 3765720984 ecr 2340566655], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、结束报文段：FIN=1, ACK=1, seq=5, ack=485  此处ack值+1了</span></span><br><span class="line">IP 172.20.12.27.38728 &gt; 172.20.12.30.80: Flags [F.], seq 5, ack 485, win 237, options [nop,nop,TS val 3765720984 ecr 2340566655], length 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、确认报文段：ACK=1, ack=5</span></span><br><span class="line">IP 172.20.12.30.80 &gt; 172.20.12.27.38728: Flags [.], ack 6, win 227, options [nop,nop,TS val 2340566656 ecr 3765720984], length 0</span><br></pre></td></tr></table></figure>

<h2 id="问题注意"><a href="#问题注意" class="headerlink" title="问题注意"></a>问题注意</h2><p><strong>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>
<p>因为当服务进程收到客户进程的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，<strong>当服务进程收到FIN报文时，很可能并不会立即关闭SOCKET</strong>，所以只能先回复一个ACK报文，告诉客户进程，”你发的FIN报文我收到了”。只有等到我服务进程所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。</p>
<p><strong>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p>
<ol>
<li><p>保证客户进程发送的最后一个 ACK 报文能够到达服务进程。</p>
</li>
<li><p>防止“已失效的连接请求报文段”出现在本连接中。</p>
<blockquote>
<p>客户端发送最后一个ACK报文后，再经过2MSL，本连接的的时间内所产生的所有报文段都从网络中消失。这样下一个新的连接中不会出现就连接的请求报文段。</p>
</blockquote>
</li>
</ol>
<p><strong>【问题3】建立连接为什么需要第三个确认报文（为什么客户进程还要发送一次确认）？</strong></p>
<p>为了防止已失效的连接请求报文段突然又传到服务器进程（被动连接端），因而产生错误。</p>
<blockquote>
<p>客户进程发出的连接请求，未收到回复确认，于是<strong>重传请求报文段</strong>。后来建立连接，数据传输完毕后释放了连接，此时延迟的失效报文段到达服务器进程，<strong>被误以为一次新的连接请求</strong>。于是服务器进程发出确认报文段，同一建立连接。假定没有第三个报文段进行确认，新的连接就建立了。白白浪费资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-五层模型</title>
    <url>/net/%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<img src="https://i.loli.net/2020/10/25/oMO4v7KFi2n9Psh.png" alt="TCP/IP协议族族中不同层次的协议.png" style="zoom: 67%;" />

<img src="https://i.loli.net/2020/10/25/3PAhBF6RnzjJGO7.png" alt="协议封装过程.png" style="zoom:67%;" />

<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul>
<li><strong>频分复用</strong>：所有用户在同样的时间占用不同的带宽资源</li>
<li><strong>时分复用</strong>：所有用户是在不同的时间占用相同的频带宽度</li>
<li>波分复用：光的频分复用</li>
</ul>
<p><strong>集线器</strong>：工作在物理层，<strong>简单的转发比特，不进行碰撞检测</strong>。不同鹏颛臾使用不同的速率则不能使用集线器互连。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>主要信道：<strong>点对点信道</strong> 、<strong>广播信道</strong> </p>
<p>三个基本问题：<strong>封装成帧</strong>、<strong>透明传输</strong>、<strong>差错检测（循环冗余检验CRC）</strong> </p>
<p>以太网帧不能小于<strong>64B</strong>，以太网的端到端往返时间称为<strong>争用期</strong>（碰撞窗口），凡是长度小于64字节的帧都是由于冲突而异常终止的无效帧。</p>
<p>数据链路层设备：</p>
<ul>
<li><p><strong>适配器</strong>：即”网卡“。串并转换、数据转存、安装设备驱动、实现以太网协。议。</p>
</li>
<li><p><strong>网桥</strong></p>
<ul>
<li>学习源地址</li>
<li>过滤同网端帧</li>
<li>转发异网端帧</li>
<li>扩散未知帧</li>
</ul>
</li>
<li><p>以太网交换机：实质就是多借口的<strong>网桥</strong>，能<strong>隔离碰撞域</strong>。</p>
<p><strong>广播风暴</strong>：一个数据帧或包被传输到本地网段 (由广播域定义)上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪。</p>
<p>生成树协议STP：阻塞一个或多个冗余端口。</p>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层向上只提供更<strong>简单灵活的、无连接的、尽最大努力交付</strong>的数据报服务。网络层不提供服务质量的承诺。</p>
<ul>
<li><p><strong>IP协议</strong></p>
<img src="https://i.loli.net/2020/10/25/mngxjNyYv74If6z.png" alt="IP数据报格式.png" style="zoom: 67%;" />
</li>
<li><p><strong>地址解析协议 ARP</strong></p>
</li>
<li><p><strong>逆地址解析协议 RARP</strong></p>
</li>
<li><p><strong>网际控制报文协议 ICMP</strong></p>
</li>
<li><p><strong>网际组管理协议 IGMP</strong></p>
</li>
<li><p>划分子网</p>
</li>
<li><p>路由选择协议</p>
<ul>
<li><strong>内部网关协议 RIP</strong></li>
<li><strong>内部网关协议 OSPF</strong></li>
<li>外部网关协议 BGP</li>
</ul>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>运输层向它上面的应用层提供<strong>通信服务</strong>。<strong>通信的真正端点并不是主机而是主机中的进程</strong>。</p>
<p>两种运输协议：<strong>面向连接的TCP</strong> 和 <strong>无连接的UDP</strong>。</p>
<ul>
<li><p><strong>用户数据报协议 UDP</strong>：无连接、尽最大努力交付、面向报文</p>
<ul>
<li><p>报文数据格式</p>
<img src="https://i.loli.net/2020/10/25/t8jmJIhCkTABOzu.png" alt="UDP用户数据报的首部和伪首部.png" style="zoom:67%;" />
</li>
</ul>
</li>
<li><p><strong>传输控制协议 TCP</strong>：面向连接、只能点到点、全双工通信、面向字节流</p>
<ul>
<li><p>报文数据格式</p>
<img src="https://i.loli.net/2020/10/25/MP8xVwous3nap7j.png" alt="TCP报文段的首部格式.png" style="zoom:67%;" />
</li>
<li><p>TCP可靠传输的实现：以字节为单位的滑动窗口、超时重传</p>
</li>
<li><p>TCP流量控制：流量控制就是让发送方发送速率不要太快，要让接收方来得及接收，发送窗口不超过接收窗口。</p>
<ul>
<li>滑动窗口</li>
</ul>
</li>
<li><p>TCP拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不至于过载。判断网络拥塞的依据就是出现了超时。</p>
<blockquote>
<p><a href="https://blog.csdn.net/sicofield/article/details/9708383">TCP的拥塞控制</a> </p>
</blockquote>
<ul>
<li><p><strong>慢开始</strong>：有小到大逐渐增大发送窗口。需设置慢开始门限。</p>
</li>
<li><p><strong>拥塞避免</strong>：让拥塞窗口 cwnd 缓慢地增大，按线性规律增长，使得网络比较不容易出现拥塞。</p>
</li>
<li><p><strong>快重传</strong>：要求接收方立即发送确认，即使收到失序的报文要立即发出对已收到报文段的重复确认。</p>
<p>eg：假定没有收到M3，但却收到了M4，必须理解发送对M2的重复确认</p>
</li>
<li><p><strong>快恢复</strong>：发送方知道只是丢失了个别报文，将调整慢开始门限为 cwnd/2 ，并开始执行拥塞避免算法。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可靠传输原理</strong></p>
<ul>
<li>停止等待协议：每发送完一个分组就停止发送，等到对方确认，收到确认再发下一个分组。确认和重传机制，可以在不可靠的传输网络上实现可靠通信。</li>
<li>连续ARP协议：发送方收到一个确认，发送窗口就向前滑动一个分组的位置；接收方不必对每个分组发送确认，对按序到达的最后一个分组发送确认。</li>
</ul>
</li>
<li><p><strong>TCP连接管理</strong></p>
<ul>
<li><p><strong>“三次握手”</strong>：TCP的连接建立</p>
<img src="https://i.loli.net/2020/10/25/BUtYroWNihSe6V7.png" alt="TCP三次握手.png" style="zoom:50%;" />
</li>
<li><p><strong>“四次握手”</strong>：TCP的连接释放</p>
<img src="https://i.loli.net/2020/10/25/A7n6OUMl8YfCpjg.png" alt="TCP四次握手.png" style="zoom:50%;" />
</li>
<li><p><strong>TCP的有限状态机</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>域名系统 DNS</li>
<li>动态主机配置协议 DHCP</li>
<li>超文本传送协议 HTTP</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>centos-k8s1.16.2集群安装部署</title>
    <url>/other/centos7-k8s1.16.2%20%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-centos-7-配置"><a href="#1-centos-7-配置" class="headerlink" title="1. centos 7 配置"></a>1. centos 7 配置</h2><p>关闭防火墙、关闭selinux、更新源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">防火墙</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭Selinux</span></span><br><span class="line">    sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或者</span></span></span><br><span class="line">    /etc/selinux/config</span><br><span class="line">    #将其中的 SELINUX=*处修改为如下</span><br><span class="line">    SELINUX=disabled</span><br><span class="line"><span class="meta">#</span><span class="bash">重启服务器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">运行命令getenforce 确保 selinux 为<span class="built_in">disable</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装wget</span></span><br><span class="line">yum install -y wget</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"><span class="meta">#</span><span class="bash">更新 源</span></span><br><span class="line">yum upgrade</span><br></pre></td></tr></table></figure>

<h2 id="2-host配置"><a href="#2-host配置" class="headerlink" title="2. host配置"></a>2. host配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash">k8s nodes</span></span><br><span class="line">192.169.1.86    k8s-master</span><br><span class="line">192.168.1.87    k8s-node1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/hostname</span></span><br><span class="line">结点名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建-etc-sysctl-d-k8s-conf文件"><a href="#3-创建-etc-sysctl-d-k8s-conf文件" class="headerlink" title="3. 创建/etc/sysctl.d/k8s.conf文件"></a>3. 创建/etc/sysctl.d/k8s.conf文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改内核参数</span></span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">执行sysctl -p /etc/sysctl.d/k8s.conf生效（sysctl --system）</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果有如下报错:</span></span><br><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</span><br><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory</span><br><span class="line"><span class="meta">#</span><span class="bash">解决方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装bridge-util软件，加载bridge模块，加载br_netfilter模块</span></span><br><span class="line">yum install -y bridge-utils.x86_64</span><br><span class="line">modprobe bridge</span><br><span class="line">modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭swap</span></span><br><span class="line">swapoff -a</span><br><span class="line">echo &quot;vm.swappiness=0&quot; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">使生效</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>

<h2 id="4-安装软件源配置"><a href="#4-安装软件源配置" class="headerlink" title="4. 安装软件源配置"></a>4. 安装软件源配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置k8s软件源</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo </span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="5-安装docker"><a href="#5-安装docker" class="headerlink" title="5. 安装docker"></a>5. 安装docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#先校正时间 否则 无法运行docker！！！！</span></span></span><br><span class="line">    # 1.安装ntpdate工具</span><br><span class="line">    sudo yum -y install ntp ntpdate</span><br><span class="line">    # 2.设置系统时间与网络时间同步</span><br><span class="line">    sudo ntpdate cn.pool.ntp.org</span><br><span class="line">    # 3.将系统时间写入硬件时间</span><br><span class="line">    sudo hwclock --systohc</span><br><span class="line">    # 4.查看系统时间</span><br><span class="line">    timedatectl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装docker</span></span><br><span class="line">yum install -y docker-io</span><br><span class="line"><span class="meta">#</span><span class="bash">启动docker并设置开机启动</span></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="6-安装kubernetes—-指定版本（1-16-2）"><a href="#6-安装kubernetes—-指定版本（1-16-2）" class="headerlink" title="6. 安装kubernetes—-指定版本（1.16.2）"></a>6. 安装kubernetes—-指定版本（1.16.2）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">查看软件包版本</span></span><br><span class="line">yum list --showduplicates | grep &#x27;kubeadm\|kubectl\|kubelet&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装软件 指定版本</span></span><br><span class="line">yum install -y kubelet-1.16.2 kubeadm-1.16.2 kubectl-1.16.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动服务并设置开机自启</span></span><br><span class="line">systemctl start kubelet &amp;&amp; systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<h2 id="7-修改配置"><a href="#7-修改配置" class="headerlink" title="7. 修改配置"></a>7. 修改配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">kubernetes 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/usr/bin 目录下 执行以下操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># kubelet  kubeadm  kubectl更新权限</span></span></span><br><span class="line">cd /usr/bin &amp;&amp; chmod a+x kubelet  kubeadm  kubectl</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">docker 配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#编辑 /lib/systemd/system/docker.service 在[Service] 下添加下面一行</span></span></span><br><span class="line">ExecStartPost=/sbin/iptables -P FORWARD ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#重启docker</span></span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="8-拉取镜像并tag"><a href="#8-拉取镜像并tag" class="headerlink" title="8. 拉取镜像并tag"></a>8. 拉取镜像并tag</h2><p>由于镜像默认从国外网站拉取，被墙，故自行从国内云拉取。<br>运行 <kbd>kubeadm config   images  list</kbd> 查看所需要的镜像以及版本号，再从阿里云拉取这些镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master bin]# kubeadm config   images  list</span><br><span class="line">W0108 19:53:17.464386   10103 version.go:101] could not fetch a Kubernetes version from the internet: unable to get URL &quot;https://dl.k8s.io/release/stable-1.txt&quot;: Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br><span class="line">W0108 19:53:17.464460   10103 version.go:102] falling back to the local client version: v1.16.2</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<p>拉取对应镜像<kbd>docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/镜像名:版本号</kbd></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 对应上面版本号</span></span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.16.2</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.3.15-0</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<p>tag镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.16.2 k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.16.2 k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.16.2 k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.16.2 k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.3.15-0 k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.2 k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<h2 id="9-使用kubeadm-init初始化集群（仅master）"><a href="#9-使用kubeadm-init初始化集群（仅master）" class="headerlink" title="9. 使用kubeadm init初始化集群（仅master）"></a>9. 使用kubeadm init初始化集群（仅master）</h2><p><strong><em>详细参数查询地址：</em></strong> <a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--apiserver-advertise-address string</span><br><span class="line">API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。</span><br><span class="line">--image-repository string     默认值：&quot;k8s.gcr.io&quot;</span><br><span class="line">选择用于拉取控制平面镜像的容器仓库</span><br><span class="line">--kubernetes-version string     默认值：&quot;stable-1&quot;</span><br><span class="line">为控制平面选择一个特定的 Kubernetes 版本。</span><br><span class="line">--service-cidr string     默认值：&quot;10.96.0.0/12&quot;</span><br><span class="line">为服务的虚拟 IP 地址另外指定 IP 地址段</span><br><span class="line">--pod-network-cidr string</span><br><span class="line">指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#部署Kubernetes Master</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#在192.168.1.86（Master）执行</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</span></span></span><br><span class="line"></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.1.86 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.16.2 \</span><br><span class="line">--service-cidr=10.1.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化成功，显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.86:6443 --token pwwmps.9cds2s34wlpiyznv \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a3220f1d2384fe5230cad2302a4ac1f233b03ea24c19c165adb5824f9c358336</span><br></pre></td></tr></table></figure>

<p>然后在master执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 等待命令执行完毕后执行如下命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在master上执行以下命令  </span></span></span><br><span class="line">mkdir -p $HOME/.kube  </span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  </span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#安装flannel网络组件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在master上执行以下命令</span></span></span><br><span class="line">kubectl apply -f  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 若出现无法下载安装flannel组件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看结点</span></span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看集群状态</span></span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能会出现node notready的情况 在master执行</span></span><br><span class="line">kubectl get pod --all-namespaces -o wide</span><br></pre></td></tr></table></figure>
<p><strong><em>Master结点初始化成功，状态可能是NotReady，要等一段时间</em></strong><br>如果初始化不成功，可以参考博文：<a href="https://www.jianshu.com/p/f53650a85131">https://www.jianshu.com/p/f53650a85131</a> 进行修复</p>
<h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><ol>
<li>由于没安装 <strong>flannel</strong> 组件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">kube-system   coredns-58cc8c89f4-dwg8r             0/1     Pending   0          24m   &lt;none&gt;         &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system   coredns-58cc8c89f4-jx7cw             0/1     Pending   0          24m   &lt;none&gt;         &lt;none&gt;       &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>无法直接从官网下载 flannel 组件安装 yml 文件</p>
<p>参考：<a href="https://blog.csdn.net/fuck487/article/details/102783300">https://blog.csdn.net/fuck487/article/details/102783300</a></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解决方法：自行创建 或 ftp 传输本地 kube-flannel.yml</span></span></span><br><span class="line">vi $HOME/kube-flannel.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># </span></span></span><br><span class="line"><span class="meta">    #</span><span class="bash"><span class="comment"># 粘贴内容 kube-flannel.yml </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装 </span></span></span><br><span class="line">[root@k8s-master ~]# kubectl apply -f ./kube-flannel.yml</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm created</span><br><span class="line">daemonset.apps/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.apps/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure>



<h2 id="10-补充命令"><a href="#10-补充命令" class="headerlink" title="10. 补充命令"></a>10. 补充命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 然后在 master 和 node 上都执行此命令</span></span></span><br><span class="line">[root@k8s-master bin]# modprobe ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh</span><br><span class="line">modprobe: ERROR: could not insert &#x27;ip_vs&#x27;: Unknown symbol in module, or unknown parameter (see dmesg)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 删去 ip_vs</span></span></span><br><span class="line">[root@k8s-master bin]# modprobe ip_vs_rr ip_vs_wrr ip_vs_sh</span><br><span class="line">modprobe: ERROR: could not insert &#x27;ip_vs_rr&#x27;: Unknown symbol in module, or unknown parameter (see dmesg)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在执行</span></span></span><br><span class="line">[root@k8s-master bin]# modprobe ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看确保内核开启了ipvs模块</span></span></span><br><span class="line">[root@k8s-master bin]# lsmod|grep ip_vs</span><br><span class="line">ip_vs                 145497  0 </span><br><span class="line">nf_conntrack          139224  7 ip_vs,nf_nat,nf_nat_ipv4,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  4 xfs,ip_vs,nf_nat,nf_conntrack</span><br></pre></td></tr></table></figure>

<h2 id="11-添加节点"><a href="#11-添加节点" class="headerlink" title="11. 添加节点"></a>11. 添加节点</h2><h3 id="获取-kubeadm-join-命令"><a href="#获取-kubeadm-join-命令" class="headerlink" title="获取 kubeadm join 命令"></a>获取 kubeadm join 命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获得添加结点命令 master上执行  kubeadm token create --<span class="built_in">print</span>-join-command</span></span><br><span class="line">[root@k8s-master ~]# kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.1.86:6443 --token a1qmdh.d79exiuqbzdr616o     --discovery-token-ca-cert-hash sha256:a3220f1d2384fe5230cad2302a4ac1f233b03ea24c19c165adb5824f9c358336</span><br></pre></td></tr></table></figure>

<h3 id="node节点上执行-join-添加结点"><a href="#node节点上执行-join-添加结点" class="headerlink" title="node节点上执行 join 添加结点"></a>node节点上执行 join 添加结点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 bin]# kubeadm join 192.168.1.86:6443 --token otjfah.zta4yo0bexibbj52     --discovery-token-ca-cert-hash sha256:60535ebe96b6a4cceab70d551f2b2b507a3641c3dc421469320b915e01377e5c</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;</span><br><span class="line">[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.16&quot; ConfigMap in the kube-system namespace</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>

<h2 id="12-删除节点"><a href="#12-删除节点" class="headerlink" title="12. 删除节点"></a>12. 删除节点</h2><p>master节点上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-master   Ready    master   3h9m   v1.16.2</span><br><span class="line">k8s-node1    Ready    &lt;none&gt;   116s   v1.16.2</span><br><span class="line">[root@k8s-master ~]# kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">node/k8s-node1 cordoned</span><br><span class="line">WARNING: ignoring DaemonSet-managed Pods: kube-system/kube-flannel-ds-amd64-gmq2b, kube-system/kube-proxy-q9ppx</span><br><span class="line">node/k8s-node1 drained</span><br><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS                     ROLES    AGE     VERSION</span><br><span class="line">k8s-master   Ready                      master   3h10m   v1.16.2</span><br><span class="line">k8s-node1    Ready,SchedulingDisabled   &lt;none&gt;   2m43s   v1.16.2</span><br><span class="line">[root@k8s-master ~]# kubectl delete node k8s-node1</span><br><span class="line">node &quot;k8s-node1&quot; deleted</span><br><span class="line">[root@k8s-master ~]# </span><br></pre></td></tr></table></figure>

<p>删除结点(k8s-node1)上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubeadm reset</span><br><span class="line">[reset] WARNING: Changes made to this host by &#x27;kubeadm init&#x27; or &#x27;kubeadm join&#x27; will be reverted.</span><br><span class="line">[reset] Are you sure you want to proceed? [y/N]: y    ## y 确认</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">W0109 13:39:15.848313   79539 removeetcdmember.go:79] [reset] No kubeadm config, using etcd pod spec to get data directory</span><br><span class="line">[reset] No etcd config found. Assuming external etcd</span><br><span class="line">[reset] Please, manually reset etcd to prevent further issues</span><br><span class="line">[reset] Stopping the kubelet service</span><br><span class="line">[reset] Unmounting mounted directories in &quot;/var/lib/kubelet&quot;</span><br><span class="line">[reset] Deleting contents of config directories: [/etc/kubernetes/manifests /etc/kubernetes/pki]</span><br><span class="line">[reset] Deleting files: [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf]</span><br><span class="line">[reset] Deleting contents of stateful directories: [/var/lib/kubelet /etc/cni/net.d /var/lib/dockershim /var/run/kubernetes /var/lib/cni]</span><br><span class="line"></span><br><span class="line">The reset process does not reset or clean up iptables rules or IPVS tables.</span><br><span class="line">If you wish to reset iptables, you must do so manually by using the &quot;iptables&quot; command.</span><br><span class="line"></span><br><span class="line">If your cluster was setup to utilize IPVS, run ipvsadm --clear (or similar)</span><br><span class="line">to reset your system&#x27;s IPVS tables.</span><br><span class="line"></span><br><span class="line">The reset process does not clean your kubeconfig files and you must remove them manually.</span><br><span class="line">Please, check the contents of the $HOME/.kube/config file.</span><br></pre></td></tr></table></figure>



<h2 id="附录：查询命令"><a href="#附录：查询命令" class="headerlink" title="附录：查询命令"></a>附录：查询命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看结点 在master执行</span></span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看集群状态 在master执行</span></span></span><br><span class="line">kubectl get cs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能会出现node notready的情况 在master执行</span></span><br><span class="line">kubectl get pod --all-namespaces -o wide</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s Weave Scope 部署配置</title>
    <url>/other/k8s%20weave%20scope%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-Weave-Scope-安装"><a href="#1-Weave-Scope-安装" class="headerlink" title="1. Weave Scope 安装"></a>1. Weave Scope 安装</h2><p>在 master 上通过以下命令安装Weave Scope：<br>kubectl apply -f “<a href="https://cloud.weave.works/k8s/scope.yaml?k8s-version=$">https://cloud.weave.works/k8s/scope.yaml?k8s-version=$</a>(kubectl version | base64 | tr -d ‘\n’)”<br>运行后会发现已经起来几个pod:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f &quot;https://cloud.weave.works/k8s/scope.yaml?k8s-version=$(kubectl version | base64 | tr -d &#x27;\n&#x27;)&quot;</span><br><span class="line">namespace/weave created</span><br><span class="line">serviceaccount/weave-scope created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/weave-scope created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/weave-scope created</span><br><span class="line">deployment.apps/weave-scope-app created</span><br><span class="line">service/weave-scope-app created</span><br><span class="line">deployment.apps/weave-scope-cluster-agent created</span><br><span class="line">daemonset.apps/weave-scope-agent created</span><br><span class="line">[root@k8s-master ~]# kubectl get pod -n weave  -o wide</span><br><span class="line">NAME                                        READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">weave-scope-agent-8zzq5                     1/1     Running   0          11s   192.168.1.92    k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-agent-jhcff                     1/1     Running   0          11s   192.168.1.85    k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-agent-qs45b                     1/1     Running   0          11s   192.168.1.133   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-app-848cd4d8b5-4rlnd            1/1     Running   0          11s   10.244.1.4      k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">weave-scope-cluster-agent-b4f45797c-7srs9   1/1     Running   0          11s   10.244.2.4      k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@k8s-master ~]# kubectl get service -n weave -o wide</span><br><span class="line">NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">weave-scope-app   ClusterIP   10.1.31.163   &lt;none&gt;        80/TCP    57s   app=weave-scope,name=weave-scope-app,weave-cloud-component=scope,weave-scope-component=app</span><br></pre></td></tr></table></figure>

<h2 id="2-访问配置"><a href="#2-访问配置" class="headerlink" title="2. 访问配置"></a>2. 访问配置</h2><p><code>k8s-service-type</code>-Kubernetes服务类型（用于以独立模式运行Scope），可以是 <code>LoadBalancer</code>或<code>NodePort</code>，默认情况下未指定（仅内部访问）<br>使用<kbd>kubectl edit</kbd> 方式修改 nodeport 的端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 首先 get svc 查看服务</span></span></span><br><span class="line">[root@k8s-master ~]# kubectl get svc --all-namespaces</span><br><span class="line">NAMESPACE     NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default       kubernetes        ClusterIP   10.1.0.1      &lt;none&gt;        443/TCP                  28h</span><br><span class="line">kube-system   kube-dns          ClusterIP   10.1.0.10     &lt;none&gt;        53/UDP,53/TCP,9153/TCP   28h</span><br><span class="line">weave         weave-scope-app   ClusterIP   10.1.31.163   &lt;none&gt;        80/TCP                   4m4s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 weave 服务</span></span></span><br><span class="line">[root@k8s-master ~]# kubectl edit svc/weave-scope-app -n weave</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 以下修改标记</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">spec:</span></span><br><span class="line"> clusterIP: 10.1.31.163</span><br><span class="line"> ports:</span><br><span class="line"> - name: app</span><br><span class="line">   nodePort: 30001        ## 新增 映射外网访问端口 30000-327627</span><br><span class="line">   port: 80        ## 默认 80 不能修改，修改后无法获取节点信息</span><br><span class="line">   protocol: TCP</span><br><span class="line">   targetPort: 4040</span><br><span class="line"> selector:</span><br><span class="line">   app: weave-scope</span><br><span class="line">   name: weave-scope-app</span><br><span class="line">   weave-cloud-component: scope</span><br><span class="line">   weave-scope-component: app</span><br><span class="line"> sessionAffinity: None</span><br><span class="line"> type: NodePort        ## 修改为 NodePort</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">status:</span></span><br><span class="line"> loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-web-浏览"><a href="#3-web-浏览" class="headerlink" title="3. web 浏览"></a>3. web 浏览</h2><p>在能访问 master 主机网络的主机上浏览器访问 <font color=red>master ip:nodePort</font>，如：<a href="http://192.168.1.86:30001/">http://192.168.1.86:30001/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>select函数-linux内核源码剖析</title>
    <url>/UNP/select%E5%87%BD%E6%95%B0-linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="用户态下select系统调用"><a href="#用户态下select系统调用" class="headerlink" title="用户态下select系统调用"></a>用户态下select系统调用</h1><p>select多路I/O转接服务器demo：<a href="https://github.com/JakeLin0fly/unp-code/blob/master/select_concurrent/select_server.c">select_server.c</a> </p>
<h2 id="select函数原型"><a href="#select函数原型" class="headerlink" title="select函数原型"></a>select函数原型</h2><blockquote>
<p>/usr/include/sys/select.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">        fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;        <span class="comment">//从fdset中删除fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;        <span class="comment">//判断fd是否已存在fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;        <span class="comment">//将fd添加到fdset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;                <span class="comment">//fdset所有位清0</span></span><br></pre></td></tr></table></figure>

<p><strong>select参数：</strong></p>
<blockquote>
<ol>
<li><p><strong>nfds</strong>：监控的文件描述符集中，待测试的<strong>最大描述符+1</strong></p>
</li>
<li><p><strong>readfds</strong>：监控有读数据到达文件描述符集合，传入传出参数</p>
</li>
<li><p><strong>writefds</strong>：监控有写数据到达文件描述符集合，传入传出参数</p>
</li>
<li><p><strong>exceptfds</strong>：监控异常发生达文件描述符集合，传入传出参数</p>
<p>a）带外数据到达</p>
<p>b）某个已置为分组模式的伪终端存在可从其主机端读取的控制状态信息</p>
</li>
<li><p><strong>timeout</strong>：定时阻塞监控时间，3种情况：</p>
<p>1）NULL，永远等下去</p>
<p>2）设置 timeval ，等待固定时间</p>
<p>3）设置 timeval 里时间均为0，检查描述字后立即返回，轮询</p>
</li>
</ol>
</blockquote>
<p><em>注意：<code>FD_</code>为前缀的函数并非系统调用，而是几个对<code>fd_set</code>进行相关位操作的<strong>宏</strong></em></p>
<p><code>fd_set</code>结构体的定义实际包含的是<code>fds_bits</code>位<strong>数组</strong>，其大小固定，由<code>FD_SETSIZE</code>指定，因此<font color=red><strong>每次select系统调用可监听处理的文件描述符最大数量为<code>FD_SETSIZE</code></strong></font>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure>



<h2 id="select函数作用"><a href="#select函数作用" class="headerlink" title="select函数作用"></a>select函数作用</h2><p><strong>select函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</strong></p>
<p><code>readfds</code>、<code>writefds</code>、<code>exceptfds</code>三个参数中，若不关注某个参数，可将其设为<code>NULL</code>。三个参数均为<code>NULL</code>相当于一个定时器。</p>
<h2 id="select函数局限"><a href="#select函数局限" class="headerlink" title="select函数局限"></a>select函数局限</h2><ol>
<li><p>select能监听的文件描述符个数受限于<code>FD_SETSIZE</code>，一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。</p>
<blockquote>
<p>/usr/include/sys/select.h</p>
<p>/usr/include/bits/typesizes.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of file descriptors in `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE              __FD_SETSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of descriptors that can fit in an `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE            1024</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>描述符集内任何与<strong>未就绪描述符</strong>对应的位返回时<strong>均清成0</strong>。为此，每次<strong>重新调用</strong>select函数时，我们都得<strong>再次</strong>把所有描述符集内所关心的位<strong>均置为1</strong>。</p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是<strong>轮询模型</strong>，会大大降低服务器响应效率，不应在select上投入更多精力。</p>
</li>
</ol>
<h2 id="套接字就绪条件"><a href="#套接字就绪条件" class="headerlink" title="套接字就绪条件"></a>套接字就绪条件</h2><img src="https://i.loli.net/2020/08/07/WdJIKFkZlCmUpoO.png" alt="select返回某个套接字就绪条件.png" style="zoom:67%;" />

<h1 id="select源码剖析"><a href="#select源码剖析" class="headerlink" title="select源码剖析"></a>select源码剖析</h1><blockquote>
<p>内核源码：linux-3.10</p>
<p>seelct源码：fs/select.c</p>
<p>内核源码链接：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v3.0/linux-3.10.tar.gz">https://mirrors.edge.kernel.org/pub/linux/kernel/v3.0/linux-3.10.tar.gz</a></p>
</blockquote>
<h2 id="select系统调用入口"><a href="#select系统调用入口" class="headerlink" title="select系统调用入口"></a>select系统调用入口</h2><ol>
<li>若设置超时时间，用户空间（微秒量级）拷贝到内核空间（纳秒量级）</li>
<li><code>core_sys_select</code> 真正执行入口</li>
<li>传出剩余时间差，返回给用户空间</li>
<li>正常结束，返回满足条件的描述符个数</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏select系统调用</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 永久等待      tvp == NULL</span></span><br><span class="line"><span class="comment">     * 2. 不等待         tvp-&gt;tv_sec == 0 &amp;&amp; tvp-&gt;tc_nsec == 0</span></span><br><span class="line"><span class="comment">     * 3. 等待指定时间   tvp-&gt;tv_sec != 0 || tvp-&gt;tc_nsec != 0  */</span></span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">        <span class="comment">/** 在设置超时情况下，拷贝用户空间下的相对超时时间（微秒量级）到内核 **/</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv))) </span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="comment">/** poll_select_set_timeout 设定成绝对的超时时间（纳秒量级） **/</span></span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** select 真正执行入口 **/</span></span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</span><br><span class="line">    <span class="comment">/* 将此次调用完成剩余的时间差值通过 tvp 指向的 timeval 结构返回给用户空间 */</span></span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="core-sys-select"><a href="#core-sys-select" class="headerlink" title="core_sys_select"></a>core_sys_select</h2><ol>
<li>先创建一个默认大小栈缓冲区（加快访问，但缓冲区大小可能不够）。</li>
<li>检查最大fd是否超出进程文件描述符位图所容量的最大值（默认1024），超过部分不监听（修正）。</li>
<li>计算前面创建的栈缓冲区是否足够存储输入、输出6个集合，若缓冲区大小不足则使用<code>kmalloc</code>分配内核空间。</li>
<li>将缓冲区分成6段，从用户空间拷贝输入集到内核空间，并将内核空间结果集清0。</li>
<li>执行主线 <strong>do_select</strong> 。</li>
<li>若无错误，拷贝内核结果集到用户空间</li>
<li>正常结束，返回满足条件的描述符数</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏core_sys_select</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set_bits fds;</span><br><span class="line">    <span class="keyword">void</span> *bits;</span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 需要将用户空间传进来的inset、outset、exset拷贝到内核空间，并且</span></span><br><span class="line"><span class="comment">     * 需要等容量的空间来存储结果集，之后会将结果集的内容写回到用户空间。</span></span><br><span class="line"><span class="comment">     * 定义一个SELECT_STACK_ALLOC(256字节)大小的栈上缓冲区，用于缓存输入输出结果集。</span></span><br><span class="line"><span class="comment">     * 如果缓存的空间大小不够，那么再使用kmalloc()动态分配，</span></span><br><span class="line"><span class="comment">     * 优先使用栈缓存而不用动态内存可以加快访问 */</span></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* rdlock加锁：保护struct files的访问 */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    fdt = files_fdtable(current-&gt;files);</span><br><span class="line">    max_fds = fdt-&gt;max_fds;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">/* 基于current宏，检查传入的最大fd对应参数n是否超出当前进程打开的</span></span><br><span class="line"><span class="comment">    * 文件描述符表内所示位图容量的最大数值，超出修正*/</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">        n = max_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * n个bits至少需要size个long才能装下（long表示bits段），</span></span><br><span class="line"><span class="comment">     * 为了存储输入输出集，我们需要6*size个long的存储空间</span></span><br><span class="line"><span class="comment">     * 栈上数组空间不足以存放本次select要处理的fd集合所需总计内存，</span></span><br><span class="line"><span class="comment">     * 则使用kmalloc从内核空间分配所需的连续物理内存 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = FDS_BYTES(n);</span><br><span class="line">    bits = stack_fds;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!bits)</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将数组分成6段 */</span></span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   size;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line">    <span class="comment">/* 依次从用户空间拷贝输入集数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">        (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">        (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* 将输出集清0 */</span></span><br><span class="line">    zero_fd_set(n, fds.res_in);</span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line">    <span class="comment">/* 主线 核心 */</span></span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 最后 将结果集返回用户空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">        set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">        set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="do-select（最核心）"><a href="#do-select（最核心）" class="headerlink" title="do_select（最核心）"></a>do_select（最核心）</h2><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><h4 id="poll-table-entry"><a href="#poll-table-entry" class="headerlink" title="poll_table_entry"></a>poll_table_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;                  <span class="comment">//wait等待队列项</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *wait_address;     <span class="comment">//wait的等待队列头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="poll-table-page"><a href="#poll-table-page" class="headerlink" title="poll_table_page"></a>poll_table_page</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="poll-table"><a href="#poll-table" class="headerlink" title="poll_table"></a>poll_table</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _key;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure>

<h4 id="poll-wqueues"><a href="#poll-wqueues" class="headerlink" title="poll_wqueues"></a>poll_wqueues</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span></span><br><span class="line">    poll_table pt;                      <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span>      <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span>   <span class="comment">//正在轮询的进程</span></span><br><span class="line">    <span class="keyword">int</span> triggered;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> inline_index;</span><br><span class="line">    <span class="comment">//记录poll信息的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="do-select源码剖析"><a href="#do-select源码剖析" class="headerlink" title="do_select源码剖析"></a>do_select源码剖析</h3><ol>
<li>初始化内核数据，再次检查并修正最大文件描述符</li>
<li>等待队列构建，并初始化等待队列</li>
<li>无穷循环开始轮询事件监测，核心调用转poll</li>
<li>结果写入内核空间的结果集</li>
<li>释放内核相应数据结构空间</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">点击显示/隐藏do_select</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>; <span class="comment">/* timed_out指示是否已经超时，超时1，未超时0 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">/* 借助当前进程已打开的文件描述符表检查传入且合法的已打开最大fd，并修正传入的n */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line">    <span class="comment">/* poll_initwait初始化poll_wqueues结构体table，这一结构体用于本次select调用</span></span><br><span class="line"><span class="comment">     * 对所有传入的待监听fd进行【轮询工作】，每个fd对应一个poll_table_entry。</span></span><br><span class="line"><span class="comment">     * 初始化poll_wqueues：</span></span><br><span class="line"><span class="comment">     * 1. 初始化poll_wqueues中的poll_table：</span></span><br><span class="line"><span class="comment">     *      * 设置监听注册函数为 __pollwait</span></span><br><span class="line"><span class="comment">     * 2. 设置polling_task指向当前进程PCB。*/</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">/* 根本不等待情况处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>; <span class="comment">/* 注意：设为NULL了！！！ */</span></span><br><span class="line">        timed_out = <span class="number">1</span>;  <span class="comment">/* 还没开始就已经超时，这样就实现了根本不等待... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 重新估算相对超时时间... */</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">/* 无穷循环开始轮询事件监测 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;</span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;  <span class="comment">/* 跳过我们不关心的bits段 */</span></span><br><span class="line">                i += BITS_PER_LONG;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 以BITS_PER_LONG个为一组依次挂载到等待队列，并对事件进行检测，</span></span><br><span class="line"><span class="comment">             * 如果没有事件到来，仅有第一次循环完成挂载，后续循环只监测事件。*/</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n)  <span class="comment">/* 超出了关心的文件描述符范围[0, n)，那么跳出... */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(bit &amp; all_bits)) <span class="comment">/* 跳过我们不关心的bit */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                f = fdget(i);</span><br><span class="line">                <span class="comment">/* 因为没有rdlock加锁，因此当前进程中描述符i对应的文件可能已经</span></span><br><span class="line"><span class="comment">                 * 被异步关闭。这就是为什么需要判断file是否为空的原因 */</span></span><br><span class="line">                <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">                    f_op = f.file-&gt;f_op;</span><br><span class="line">                    <span class="comment">/* 注意：mask = POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM; */</span></span><br><span class="line">                    mask = DEFAULT_POLLMASK; </span><br><span class="line">                    <span class="comment">/* 如果这个文件支持poll()，那么我们就向这个文件注册监听函数；</span></span><br><span class="line"><span class="comment">                     * 如果不支持，那么我们就忽略掉这个文件描述符 */</span></span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">                        wait_key_set(wait, in, out, bit); <span class="comment">/* 设置poll_table中想要监听的事件 */</span></span><br><span class="line"><span class="comment">/* #核心调用#</span></span><br><span class="line"><span class="comment">* 在这里会根据fd的不同创建类别调用真正的poll函数，</span></span><br><span class="line"><span class="comment">* socket下对应是sock_poll，如ipv4/tcp下会继续调用tcp_poll，</span></span><br><span class="line"><span class="comment">* 在这里完成调用poll_table注册的函数指针__poll_wait挂载等待队列操作（实际借助poll_wait封装调用）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(f.file, wait); <span class="comment">/* 对文件注册监听函数，并返回资源的当前状态 */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fdput(f);</span><br><span class="line">                    <span class="comment">/* 完成检测操作获取事件mask结果。events验证，其中retval表示就绪的资源数 */</span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">                        res_in |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        <span class="comment">/* 保证仅在第一次循环时，完成本次fd对应挂载等待队列，</span></span><br><span class="line"><span class="comment">                         * 不论是否收到设备事件通知，本次调用仅挂载一次，因此置空poll_table注册的poll */</span></span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;  <span class="comment">//</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">                        res_out |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">                        res_ex |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 结果写入内核空间的结果集 */</span></span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">            cond_resched();</span><br><span class="line">        &#125;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>;  <span class="comment">/* 将wait-&gt;_qproc设为NULL，表示我们不希望再进行监听注册 */</span></span><br><span class="line">        <span class="comment">/* 事件发生、超时、中断，跳出死循环 */</span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;  <span class="comment">/* 发生了错误，我们也跳出死循环 */</span></span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 能够到达这一步就说明没有发生就绪、中断以及超时 */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 判断poll_wqueues是否已触发，如果还没有触发，那就</span></span><br><span class="line"><span class="comment">           设置当前运行状态为可中断阻塞并进行睡眠，等待被唤醒。</span></span><br><span class="line"><span class="comment">         * 被唤醒之后重新进行迭代，获取资源就绪情况。</span></span><br><span class="line"><span class="comment">         * 在向资源注册监听与判断poll_wqueues是否已触发在这段时间内，可能资源异步就绪了，</span></span><br><span class="line"><span class="comment">           如果没有触发标志，那么可能就会丢失资源就绪这个事件，可能导致select()永久沉睡。</span></span><br><span class="line"><span class="comment">         * 这就是为什么需要poll_wqueues.triggered字段的原因。  */</span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                       to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 1. 卸载安装到资源监听队列上的poll_table_entry</span></span><br><span class="line"><span class="comment">     * 2. 释放poll_wqueues占用的资源  */</span></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>select负责将超时时间从用户空间（微秒级）拷贝到内核空间（纳秒级），接着转真正入口<code>core_sys_select</code>。</p>
<p><code>core_sys_select</code>函数调用树如下（图片来源网络）：</p>
<img src="https://i.loli.net/2020/08/07/hzjyYkINFRbuqaH.png" alt="core_sys_select调用树.png" style="zoom:67%;" />

<h2 id="select注意点"><a href="#select注意点" class="headerlink" title="select注意点"></a>select注意点</h2><ol>
<li>select函数第一个参数<code>nfds</code>为监控的文件描述符集中，待测试的<strong>最大描述符+1</strong>。</li>
<li>每次调用select均需要将用户空间数据拷贝到内核空间</li>
<li>select能监听的文件描述符个数受限于<code>FD_SETSIZE</code>，一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。修改后需重新编译内核。</li>
<li>每次select调用都要轮询完成将所有<code>fd</code>的挂载到等待队列，以及对事件进行检测。</li>
<li>内核轮询检测监听集合中每一个描述符是否有事件发生，有事件到来时，不知道是哪些文件描述符有数据可以读写，需要把所有的文件描述符都轮询一遍才能知道。</li>
<li>有事件发生，轮询完一遍，将内核空间中的整个结果集 <code>bitmap</code> 拷贝到用户空间。</li>
<li>用户进程仅知道有多少满足条件的描述符，需要遍历监听集合去查询。</li>
<li>select函数<code>readfds</code>、<code>writefds</code>、<code>exceptfds</code>三个集合参数均为<strong>传入传出参数</strong>，在每次调用select时需要对三个参数进行赋值。</li>
<li>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select 采用的是轮询模型，会大大降低服务器响应效率。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《UNIX网络编程 卷一：套接字联网API》</p>
<p><a href="http://www.pandademo.com/2016/11/linux-kernel-select-source-dissect/">Linux内核select源码剖析</a></p>
<p><a href="https://www.jianshu.com/p/da6642369ef0">https://www.jianshu.com/p/da6642369ef0</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>unp</tag>
        <tag>I/O复用</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Posix消息队列</title>
    <url>/UNP/Posix%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>程序示例可见参考链接：<a href="https://blog.csdn.net/zx714311728/article/details/53197196"><em>Posix消息队列_ZX714311728的博客-CSDN博客</em></a> </p>
</blockquote>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以认为是一个消息链表，消息队列是<strong>随内核持续</strong>的。队列中每个消息的属性有：</p>
<ol>
<li><p>一个无符号整数<strong>优先级</strong>（Posix）或一个长整数类型（System V）；</p>
</li>
<li><p>消息的<strong>数据部分长度</strong>（可以为0）；</p>
</li>
<li><p><strong>数据</strong>本身（如果长度大于0）。</p>
</li>
</ol>
<p>链表头含有当前队列的两个属性：</p>
<ol>
<li>队列中运行的最大消息数 <code>mq_maxmsg</code> ；</li>
<li>每个消息的最大大小 <code>mq_msgsize</code> 。</li>
</ol>
<p>消息队列的可能布局如下：</p>
<p><img src="https://gitee.com/jakel-in/images/raw/master/2021-02/%E5%90%AB%E6%9C%89%E4%B8%89%E4%B8%AA%E6%B6%88%E6%81%AF%E7%9A%84Posix%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E8%83%BD%E5%B8%83%E5%B1%80.png"></p>
<p>Posix 消息队列与System V消息队列主要区别：</p>
<ol>
<li>Posix 消息队列的读总是返回「最高优先级的最早消息」；System V 消息队列的读则可以返回任一指定优先级消息。</li>
<li>往空队列放置消息时，Posix 消息队列允许产生一个信号或启动一个线程；System V则不提供类似机制。</li>
</ol>
<p>Posix消息队列与管道或FIFO的主要区别：</p>
<ol>
<li><p>在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。对管道和FIFO来说，除非读出者已存在，否则先有写入者是没有意义的。</p>
</li>
<li><p>管道和FIFO是字节流模型，没有消息边界。消息队列则指定了数据长度，有边界。</p>
</li>
</ol>
<h2 id="mq-open-、-mq-close和-mq-unlink"><a href="#mq-open-、-mq-close和-mq-unlink" class="headerlink" title="mq_open 、  mq_close和 mq_unlink"></a>mq_open 、  mq_close和 mq_unlink</h2><blockquote>
<p>mq_xxx() 函数不是标准库函数，所以链接时需指定库，通过在最后加上 <strong><code>-lrt</code></strong> 选项来指定</p>
</blockquote>
<h3 id="mq-open"><a href="#mq-open" class="headerlink" title="mq_open"></a>mq_open</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 「创建」新消息队列或「打开」已存在的消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，<strong>消息队列描述符</strong>； 出错，-1</p>
<p>mode 和 attr 仅创建时使用</p>
<p>创建的 “文件” 存放在 <code>/dev/mqueue/</code> 下</p>
</blockquote>
<p><code>name</code> 规则：必须以一个<code>/</code> 开头，并且不能再包含任何其他斜杠符；</p>
<p><code>oflag</code> ：O_RDONLY、O_WRONLY、O_RDWR三者之一，按位或上O_CREAT、O_EXCL</p>
<p><code>mode</code> ：S_ISRUSR、S_ISWUSR、S_ISRGRP、S_ISWGRP、S_ISROTH、S_ISWOTH </p>
<p><code>attr</code> ：mq_open 只能设置 mq_maxmsg 和 mq_msgsize 属性，并且两个必须要同时设置；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mq_flags;<span class="comment">// 阻塞标志， 0或O_NONBLOCK</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg;<span class="comment">// 最大消息数</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize;<span class="comment">// 每个消息最大大小</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs;<span class="comment">// 当前消息数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mq-close和mq-unlink"><a href="#mq-close和mq-unlink" class="headerlink" title="mq_close和mq_unlink"></a>mq_close和mq_unlink</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭已打开的消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqd)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错，-1</p>
</blockquote>
<p>与 <code>close</code>  函数类似：调用进程可以不再使用该描述符，但消息队列并不从系统中删除。</p>
<p> 一个进程终止时，它的所有打开的消息队列都关闭，如同调用了mq_close。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除消息队列的name</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错，-1</p>
</blockquote>
<p>每个消息队列有一个保存其当前打开的描述符数的引用计数，只有当引用计数为0时，才删除该消息队列。当一个消息队列的引用计数仍大于0时，其 name 就能删除，但是该队列的析构（这与从系统中删除其名字不同）要等到最后一个 mq_close 发生时才进行。</p>
<h2 id="mq-getattr、-mq-setattr"><a href="#mq-getattr、-mq-setattr" class="headerlink" title="mq_getattr、  mq_setattr"></a>mq_getattr、  mq_setattr</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取、设置消息队列属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqd, struct mq_attr *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错，-1</p>
<p>mq_setattr 只能设置 mq_flags 属性；mq_getattr 返回全部4个属性。</p>
</blockquote>
<h2 id="mq-send、-mq-receive"><a href="#mq-send、-mq-receive" class="headerlink" title="mq_send、  mq_receive"></a>mq_send、  mq_receive</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往消息队列中放置一个消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从消息队列中取走一个消息</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *prio)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>mq_send</code> 中优先级 prio 要小于 <code>MQ_PRIO_MAX</code>；</li>
<li><code>mq_send</code> 的 prio 参数：<ul>
<li>为非空指针，优先级通过该指针存放；</li>
<li>为空指针，指定优先级值为 0 。</li>
</ul>
</li>
<li><code>mq_receive</code> 总是返回指定队列中 最高优先级的最早消息；</li>
<li><code>mq_receive</code> 的 len 参数值不能小于能加到所指队列中消息的最大大小（mq_msgsize）。若小于该值则立即返回 EMSGSIZE 错误。</li>
</ul>
<h2 id="消息队列限制"><a href="#消息队列限制" class="headerlink" title="消息队列限制"></a>消息队列限制</h2><ul>
<li><code>mq_maxmsg</code>：消息队列中最大消息数</li>
<li><code>mq_msgsize</code>：给定消息队列的最大字节数</li>
<li><code>MQ_OPEN_MAX</code>：一个进程能够同时拥有的打开着的消息队列的最大数目（Posix要求它至少为8）</li>
<li><code>MQ_PRIO_MAX</code>：任意消息的最大优先级值加1</li>
</ul>
<h2 id="mq-notify"><a href="#mq-notify" class="headerlink" title="mq_notify"></a>mq_notify</h2><p>Posix消息队列允许<strong>异步事件通知</strong>，以告知何时有一个消息放置到了某个空消息队列中。这种通知有两种方式可供选择：</p>
<ol>
<li>产生一个信号</li>
<li>创建一个线程来执行指定的函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为指定队列建立或删除异步事件通知</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqd, <span class="keyword">const</span> struct sigevent *notification)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值：成功，0；出错-1</p>
</blockquote>
<ul>
<li><code>notification</code> 参数：<ul>
<li>非空，该进程被注册为接收该消息队列的通知</li>
<li>空指针，当前进程被注册为接收该消息队列的通知，已存在的注册将被撤销</li>
</ul>
</li>
<li>对一个消息队列来说，任一时刻只有一个进程可以被注册</li>
<li>当通知被发送给注册进程时，注册即被撤销，该进程若要重新注册，则必须重新调用 mq_notify() （一次注册，接收一次）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> sigval &#123;          <span class="comment">/* Data passed with notification */</span></span><br><span class="line">    <span class="keyword">int</span> sival_int;         <span class="comment">/* Integer value */</span></span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;         <span class="comment">/* Pointer value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sigev_notify; <span class="comment">/* Notification method */</span></span><br><span class="line">    <span class="keyword">int</span> sigev_signo;  <span class="comment">/* Notification signal */</span></span><br><span class="line">    <span class="keyword">union</span> sigval sigev_value;  <span class="comment">/* Data passed with</span></span><br><span class="line"><span class="comment">                                         notification */</span></span><br><span class="line">    <span class="keyword">void</span> (*sigev_notify_function) (<span class="keyword">union</span> sigval);  <span class="comment">/* Function used for thread notification (SIGEV_THREAD) */</span></span><br><span class="line">    <span class="keyword">void</span> *sigev_notify_attributes;   <span class="comment">/* Attributes for notification thread (SIGEV_THREAD) */</span></span><br><span class="line">    <span class="keyword">pid_t</span> sigev_notify_thread_id;   <span class="comment">/* ID of thread to signal (SIGEV_THREAD_ID) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sigev_notify</code> 取值：<ul>
<li>SIGEV_NONE：事件发生时，什么也不做；</li>
<li>SIGEV_SIGNAL：事件发生时，将sigev_signo指定的信号发送给指定的进程；</li>
<li>SIGEV_THREAD：事件发生时，内核会（在此进程内）以 sigev_notify_attributes 为线程属性创建一个线程，并让其执行 sigev_notify_function，并以 sigev_value 为其参数</li>
</ul>
</li>
<li><code>sigev_signo</code>：在 sigev_notify=SIGEV_SIGNAL 时使用，指定信号类别</li>
<li><code>sigev_value</code>：sigev_notify=SIGEV_SIGEV_THREAD 时使用，作为 sigev_notify_function 的参数</li>
<li><code>sigev_notify_function</code>：在 sigev_notify=SIGEV_THREAD 时使用，其他情况下置NULL</li>
</ul>
<h2 id="Posix实时信号"><a href="#Posix实时信号" class="headerlink" title="Posix实时信号"></a>Posix实时信号</h2><p>信号可划分为两个大组：</p>
<ol>
<li>值在 SIGRTMIN（值34） 和 SIGRTMAX（值64） 之间（包括两者在内）的<strong>实时信号</strong>；</li>
<li>所有<strong>其他信号</strong>：SIGALRM、SIGINT、SIGKILL等</li>
</ol>
<p>实时信号中 “<strong>实时</strong>” 的意思是：</p>
<ol>
<li><strong>信号是排队的</strong>，是按先进先出(FIFO)顺序排队的。同一信号产生3次，则递交3次</li>
<li>当有多个 SIGRTMIN 到 SIGRTMAX 范围内的解阻塞信号排队时，值较小的信号先与较大的信号递交</li>
<li>实时信号能比非实时信号<strong>携带更多信息</strong></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>unp</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>unp</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
</search>
